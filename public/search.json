[{"title":"SQL笔记","url":"/2022/09/14/DBMS/SQL%E7%AC%94%E8%AE%B0/","content":"SQL简介\n英文：Structured Query Language，简称SQL\n结构化查询语言，一门操作关系型数据库的编程语言\n定义操作所有关系型数据库的统一标准\n对于同一个需求，每一种数据库操作的方式可能会存在一些不一样的地方，我们称为“方言”\n\nSQL通用语法\nSQL语句可以单行或多行书写，以分号结尾。\nMySQL数据库的SQL语句不区分大小写，关键字建议使用大写。\n注释\n单行注释：– 注释内容 或 # 注释内容（MySQL 特有）\n多行注释：&#x2F;* 注释 *&#x2F;\n\n\n\nSQL分类\nDDL(Data Definition Language)数据定义语言，用来定义数据库对象：数据库，表，列等\nDML(Data Manipulation Language)数据操作语言，用来对数据库中表的数据进行增删改\nDQL(Data Query Language)数据查询语言，用来查询数据库中表的记录（数据）\nDCL(Data Control Language)数据控制语言，用来定义数据库的访问权限和安全级别，及创建用户\n\nDDL操作数据库\n查询\nSHOW DATABASES;\n\n创建\n\n创建数据库\nCREATE DATABASE 数据库名称;\n\n创建数据库（判断，如果不存在则创建）\nCREATE DATABASE IF NOT EXISTS 数据库名称;\n\n\n删除\n\n删除数据库\nDROP DATABASE 数据库名称;\n\n删除数据库（判断，如果存在则删除）\nDROP DATABASE IF EXISTS 数据库名称;\n\n\n使用数据库\n\n查看当前使用的数据库\nSELECT DATABASE();\n\n使用数据库\nUSE 数据库名称;\n\n\n\n操作表创建表\nCREATE TABLE 表名 (    字段名1\t数据类型1，    字段名2\t数据类型2，    ...    字段名n\t数据类型n );\n\n注意：最后一行末尾，不能加逗号\n\n数据类型\n\nMySQL支持多种类型，可以分为三类：\n\n数值\n日期\n字符串\n\n\n\n\n\n查询表\n\n查询当前数据库下所有表名称\nSHOW TABLES;\n\n查询表结构\nDESC 表名称;\n\n修改表\n\n修改表名\nALTER TABLE 表名 RENAME TO 新的表名;\n\n添加一列\nALTER TABLE 表名 ADD 列名 数据类型;\n\n修改数据类型\nALTER TABLE 表名 MODIFY 列名 新数据类型;\n\n修改列名和数据类型\nALTER TABLE 表名 CHANGE 列名 新列名 新数据类型;\n\n删除列\nALTER TABLE 表名 DROP 列名;\n\n删除表\n\n删除表\nDROP TABLE 表名;\n\n删除表时判断表是否存在\nDROP TABLE IF EXISTS 表名;\n\nDML添加数据\n给指定列添加数据\nINSERT INTO 表名(列名1,列名2,...) VALUES(值1，值2，...);\n\n给全部列添加数据\nINSERT INTO 表名 VALUES(值1,值2,...);\n\n批量添加数据\nINSERT INTO 表名(列名1,列名2,...) VALUES(值 1,值2,...);\n\nINSERT INTO 表名 VALUES (值1,值2,...),(值1,值2,...),(值1,值2,...)...;\n\n修改数据\n修改表数据\nUPDATE 表名 SET 列名1=值1,列名2=值2,... [WHERE 条件];\n\n注意：修改语句中如果不加条件，则将所有数据都修改！\n\n\n删除数据\n删除数据\nDELETE FROM 表名 WHERE 条件;\n\n注意：删除语句中如果不加条件，则将所有数据都删除！\n\n\nDQL查询语法SELECT\t字段列表FROM\t表名列表WHERE\t条件列表GROUP BY\t分组字段HAVING\t分组后条件ORDER BY\t排序字段LIMIT\t分页限定\n\n基础查询\n查询多个字段\nSELECT 字段列表 FROM 表名;SELECT * FROM 表名; -- 查询所有数据\n\n去除重复记录\nSELECT DISTINCT 字段列表 FROM 表名;\n\n起别名\nAS: AS 也可以省略\n\n条件查询(WHERE)\n条件查询语法\nSELECT 字段列表 FROM 表名 WHERE 条件列表;\n\n排序查询(ORDER BY)\n排序查询语法\nSELECT 字段列表 FROM 表名 ORDER BY 排序字段名1 [排序方式1],排序字段名2 [排序方式2] ...;\n\n排序方式：\n\nASC：升序排序（默认值）\nDESC：降序排列\n\n注意：如果有多个排序条件，当前边的条件值一样时，才会根据第二条件进行排序\n\n\n聚合函数\n概念：\n将一列数据作为一个整体，进行纵向计算。\n\n聚合函数分类\n\n\n聚合函数语法：\nSELECT 聚合函数名(列名) FROM 表;\n\n注意：null值不参与所有聚合函数运算\n\n\n分组查询(GROUP BY)\n分组查询语法\nSELECT 字段列表 FROM 表名 [WHERE 分组前条件限定] GROUP BY 分组字段名 [HAVING 分组后条件过滤];\n\n注意：分组之后，查询的字段为聚合函数和分组字段，查询其他字段无任何意义\nwhere和having区别：\n\n执行时机不一样：where是分组之前进行限定，不满足where条件，则不参与分组，而having是分组之后对结果进行过滤\n\n可判断的条件不一样：where不能对聚合函数进行判断，having可以\n执行顺序：where&gt;聚合函数&gt;having\n\n\n\n\n分页查询(LIMIT)\n分页查询语法\nSELECT 字段列表 FROM 表名 LIMIT 起始索引 , 查询条目;\n\n\n起始索引：从0开始\n计算公式：起始索引 &#x3D; (当前页码-1) * 每页显示的条数\ntips:\n\n分页查询limit是MySQL数据库的方言\nOracle分页查询使用rownumber\nSQL Server分页查询使用top\n\n\n\n","categories":["WEBbackend"],"tags":["sql"]},{"title":"向量数据库","url":"/2023/04/18/DBMS/%E5%90%91%E9%87%8F%E6%95%B0%E6%8D%AE%E5%BA%93/","content":"向量数据库是一种专门用于存储和查询向量数据的数据库。它们可以处理高维度、大规模的向量数据，并提供高效的相似性搜索功能。在传统的关系型数据库中，数据通常以表格形式存储，而向量数据库则将数据表示为向量，这有助于更加准确地描述数据之间的相似性。\n\n\n向量数据库可以应用于多个领域，如计算机视觉、自然语言处理、推荐系统等。例如，在图像搜索中，我们可以将每张图片表示为一个向量，然后使用向量数据库来快速找到与输入图片最相似的其他图片。在推荐系统中，我们也可以使用向量数据库来查找与用户喜好最相似的商品或内容。\n向量数据库检索向量数据库检索指的是在向量数据库中针对特定查询向量进行相似性搜索的过程。在向量数据库中，每个向量数据都被表示为一个向量，并且每个向量都有一个唯一的ID。当执行向量检索时，首先将查询向量转换为向量形式，然后通过相似性函数计算每个向量与查询向量之间的相似度。最后，将所有向量按照相似度排序，以找到最相似的向量。\n在执行向量检索时，需要选择相应的相似性函数来计算向量之间的相似度。常见的相似性函数包括余弦相似度、欧几里得距离、曼哈顿距离等。同时，还可以使用一些加速技术，如局部敏感哈希（LSH）和树型结构（如KD-Tree），来加快相似性搜索过程。\n关于ANNANN是Approximate Nearest Neighbor的缩写，中文翻译为“近似最近邻”。它是一种基于向量相似度的搜索技术，用于在大规模高维度数据集中进行高效的相似性搜索。ANN可以解决传统最近邻搜索（exact nearest neighbor）难以应对的高维问题，即使是亿级别的数据集也能够快速检索。\n与传统精确最近邻搜索不同，ANN允许返回近似最近邻结果，这意味着虽然结果不是100%准确的，但其可能非常接近真实答案，并且差异可以被可控制和调整。通过牺牲一定的精确度，ANN可以显著提高查询速度和存储效率。\nANN通常使用一些加速技术来实现高效的相似性搜索。其中一些方法包括局部敏感哈希（LSH）、树型结构（如KD-Tree、Ball-Tree）、保序回归等。这些方法都旨在将数据划分为多个子空间，以便更快地查找最相似的向量。\n常见的向量数据库Faiss, AnnoyMilvus：世界上最快的向量数据库Pinecone，这个提供 Google Cloud 或 AWS 的托管服务Qdrant，开源版及商业版都有pgvector，PostgreSQL 的扩展\n实现ChatGPT与向量数据库的集成\n选择一个向量数据库：首先选择一个向量数据库，如Faiss, Annoy, 或者Milvus。根据你的需求和场景，选择适合你项目的向量数据库。\n\n使用OpenAI API：要使用ChatGPT，你需要访问OpenAI的API。在Java中，你可以使用Java的HTTP客户端（如Apache HttpClient或OkHttp）来与API进行交互。\n\n将文本转换为向量：在将文本发送给ChatGPT之前，你需要将其转换为向量。这可以通过诸如Hugging Face的Transformers库实现。不过，Transformers库是Python的，因此你需要找到一个Java实现或使用类似于Jep的工具将Python代码嵌入到Java应用中。\n\n存储向量：使用所选的向量数据库将生成的向量存储起来。这可能需要为Java编写或找到一个客户端库，以便与向量数据库进行交互。\n\n查询向量数据库：根据需求，你可能需要查询向量数据库以找到与输入文本最相关的内容。这通常涉及计算输入文本向量与数据库中向量之间的相似度。向量数据库通常会提供查询功能来实现这一点。\n\n\n以下是一个简化的Java实现示例，展示了如何与OpenAI API进行交互以及与向量数据库的集成：\nimport okhttp3.*;import org.json.*;public class ChatGPTIntegration &#123;    public static void main(String[] args) &#123;        String prompt = &quot;你好，我想了解Java编程。&quot;;        String apiKey = &quot;your_openai_api_key&quot;;                String response = generateChatGPTResponse(prompt, apiKey);        System.out.println(&quot;Generated response: &quot; + response);        // 在此处将文本转换为向量，并将其存储到所选的向量数据库中        // 还可以在此处执行查询和其他向量数据库操作    &#125;    public static String generateChatGPTResponse(String prompt, String apiKey) &#123;        OkHttpClient client = new OkHttpClient();        MediaType JSON = MediaType.get(&quot;application/json; charset=utf-8&quot;);                JSONObject requestBodyJson = new JSONObject()            .put(&quot;prompt&quot;, prompt)            .put(&quot;max_tokens&quot;, 50)            .put(&quot;temperature&quot;, 0.5);        RequestBody requestBody = RequestBody.create(requestBodyJson.toString(), JSON);        Request request = new Request.Builder()            .url(&quot;https://api.openai.com/v1/engines/davinci-codex/completions&quot;)            .addHeader(&quot;Authorization&quot;, &quot;Bearer &quot; + apiKey)            .post(requestBody)            .build();        try (Response response = client.newCall(request).execute()) &#123;            JSONObject jsonResponse = new JSONObject(response.body().string());            return jsonResponse.getJSONArray(&quot;choices&quot;).getJSONObject(0).getString(&quot;text&quot;);        &#125; catch (IOException e) &#123;            e.printStackTrace();            return null;        &#125;    &#125;&#125;","categories":["DBMS"],"tags":["ChatGpt"]},{"title":"Java 和 Python 异构模块数据传输","url":"/2023/04/18/WebBackend/Java%20%E5%92%8C%20Python%20%E5%BC%82%E6%9E%84%E6%A8%A1%E5%9D%97%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93/","content":"Java运行Python脚本，把数据放在参数里传递通过第三方文件做中转站消息队列方式流量消峰 应用解耦 异步处理\n扩展阅读\n异构模块之间如何数据传输？举例java和python两种不同语言编写的模块之间数据交互的几种方式（入门消息队列RabbitMQ）_不同开发语言怎么传输文件_原来浙小商啊的博客-CSDN博客\n# RabbitMQ——第一篇：RabbitMQ介绍\n\n","categories":["WebBackend"],"tags":["Java","Python"]},{"title":"DNS记录类型","url":"/2023/05/10/server/DNS%E8%AE%B0%E5%BD%95%E7%B1%BB%E5%9E%8B/","content":"\nA 记录（Address Record）：将一个域名映射到一个IPv4地址。\n\nAAAA 记录（Quad A Record）：将一个域名映射到一个IPv6地址。与A记录类似，只是它们适用于IPv6地址而不是IPv4地址。\n\nCNAME 记录（Canonical Name Record）：将一个域名映射到另一个域名。它允许你创建别名，指向其他的DNS记录。\n\nMX 记录（Mail Exchange Record）：定义用于处理电子邮件的服务器。当你发送一封邮件到一个域名时，MX记录告诉邮件服务器应该向哪个服务器发送邮件。\n\nTXT 记录（Text Record）：提供关于域名的任何文本信息。这种类型的记录经常被用于各种目的，包括SPF记录（用于防止垃圾邮件）和域名验证（例如，Google的网站所有权验证）。\n\nSPF 记录（Sender Policy Framework Record）：用来防止垃圾邮件。它指定了哪些邮件服务器被允许发送你的域名的邮件。\n\nSRV 记录（Service Record）：定义提供特定服务的服务器。例如，SRV记录可以用来指定用于音频和视频通话的服务器。\n\nCAA 记录（Certification Authority Authorization Record）：指定哪些证书颁发机构（CA）被允许为一个域名颁发SSL&#x2F;TLS证书。\n\n\n","categories":["server"],"tags":["DNS"]},{"title":"数据库基本概念","url":"/2022/11/25/DBMS/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","content":"数据库基本概念 (SQL，索引视图，事务，日志等)\n数据库是什么\n信息、数据与数据处理\n应用程序和操作系统承上启下的作用\n数据库（DB，Data Base）\n数据库管理系统（DBMS，Data Base Management System）\n数据库系统（DBS，Data Base System）\n\n\n\n数据库与数据库实例的概念数据库：物理操作系统或其他形式文件类型的集合。在Oracle数据库是dbf、日志文件、密码文件等文件构成；在MySQL下数据库文件可以是frm、myd、myi、ibd结尾的文件。\n数据库实例：由数据库后台进程&#x2F;线程以及一个共享内存区组成。Oracle是多进程程序；MySQL数据库是单进程多线程的程序，单进程多线程的特性决定MySQL是轻量级数据库（并发连接性能受限）。\nSQL基础概念\nStructured Query Language : 结构化查询语言,是一种特殊目的的编程语言,是一种数据库查询和程序设计语言,用于存取数据以及查询、更新和管理关系数据库系统。\n\n结构化查询语言是**高级的非过程化编程语言,**允许用户在高层数据结构上工作。它不要求用户指定对数据的存放方法,也不需要用户了解具体的数据存放方式,所以具有完全不同底层结构的不同数据库系统可以使用相同的结构化查询语言作为数据输入与管理的接口。结构化查询语言语句可以嵌套,这使它具有极大的灵活性和强大的功能。\n\nSQL语言1974年由Boyce和Chamberlin提出,并首先在IBM公司研制的关系数据库系统SystemR上实现。由于它具有功能丰富、使用方便灵活、语言简洁易学等突出的优点,深受计算机工业界和计算机用户的欢迎。1980年10月,经美国国家标准局(ANSI)的数据库委员会X3H2批准,将SQL作为关系数据库语言的美国标准,同年公布了标准SQL,此后不久,国际标准化组织(ISO)也作出了同样的决定。\n\n\nSQLSQL 6大类：\n\n数据查询语言( DQL: Data Query Language) : 其语句,也称为“数据检索语句”, 用以从表中获得数据,确定数据怎样在应用程序给出。保留字SELECT是DQL (也是所有SQL )用得最多的动词,其他DQL常用的保留字有WHERE , ORDER BY , GROUP BY和HAVING。 这些DQL保留字常与其它类型的SQL语句一起使用。\n数据操作语言( DML : Data Manipulation Language ) : 其语句包括动词INSERT、UPDATE和DELETE。 它们分别用于添加、修改和删除。\n事务控制语言( TCL) : 它的语句能确保被DML语句影响的表的所有行及时得以更新。包括COMMIT (提交)命令、SAVEPOINT (保存点)命令、ROLLBACK (回滚)命令。\n数据控制语言( DCL ) :它的语句通过GRANT或REVOKE实现权限控制,确定单个用户和用户组对数据库对象的访问。某些RDBMS可用GRANT或REVOKE控制对表单个列的访问。\n数据定义语言(DDL) :其语句包括动词CREATE,ALTER和DROP。在数据库中创建新表或修改、删除表( CREATE TABLE或DROP TABLE) ; 为表加入索引等。\n指针控制语言( CCL) :它的语句,像DECLARE CURSOR , FETCH INTO和UPDATE WHERE CURRENT用于对一个或多个表单独行的操作。\n\nSQL的特点：\n\nSQL风格统一SQL可以独立完成数据库生命周期中的全部活动,包括定义关系模式、录入数据、建立数据库、查询、更新、维护、数据库重构、数据库安全性控制等一系列操作 ,这就为数据库应用系统开发提供了良好的环境,在数据库投入运行后,还可根据需要随时逐步修改模式,且不影响数据库的运行,从而使系统具有良好的可扩充性。\n\n高度非过程化非关系数据模型的数据操纵语言是面向过程的语言,用其完成用户请求时,必须指定存取路径。而用SQL进行数据操作,用户只需提出“做什么”, 而不必指明”怎么做”, 因此用户无须了解存取路径,存取路径的选择以及SQL语句的操作过程由系统自动完成。这不但大大减轻了用户负担,而且有利于提高数据独立性。\n\n面向集合的操作方式SQL采用集合操作方式,不仅查找结果可以是元组的集合,而且一次插入、删除、更新操作的对象也可以是元组的集合\n\n以同一种语法结构提供两种使用方式SQL既是自含式语言,又是嵌入式语言。作为自含式语言,它能够独立地用于联机交互的使用方式,用户可以在终端键盘上直接输入SQL命令对数据库进行操作。作为嵌入式语言, SQL语句能够嵌入到高级语言(如C、C#、 JAVA)程序中,供程序员设计程序时使用。而在两种不同的使用方式下, SQL的语法结构基本上是一致的。这种以统一的语法结构提供两种不同的操作方式,为用户提供了极大的灵活性与方便性。\n\n语言简洁,易学易用SQL功能极强,但由于设计巧妙,语言十分简洁,完成数据定义、数据操纵、数据控制的核心功能只用了9个动词:CREATE、ALTER、 DROP、SELECT、 INSERT、 UPDATE、 DELETE、 GRANT、REVOKE。 且SQL语言语法简单，接近英语口语,因此容易学习,也容易使用。\n\n\n索引\n概念索引是对数据库表中一列或多列的值进行排序的一种结构 ,使用索引可快速访问数据库表中的特定信息。\n索弓|的创建和使用举例 :如果在查询时常用类似以下的语句:SELECT * FROM mytable WHERE category_id=1;最直接的应对之道,是为category_ id建立一个简单的索引 :CREATE INDEX mytable_categoryid ON mytable (category_id);\n\n索引种类：\n\n唯一索引:UNIQUE例如在学生表中给学号字段创建唯一索引: create unique index stusno on student (sno) ;表明此索弓的每一个索引值只对应唯一的数据记录,对于单列唯一性索引,这保证单列不包含重复的值。对于多了唯一-性索引,保证多列值得组合不重复\n主键索引primary key即唯一 +非空数据库关系图中在给表定义主键将自动创建主键索引,该索弓|要求主键中的每个值都唯一且非空。\n聚集索引(又叫聚簇索引) : cluster聚簇索引并不是一种单独的索引类型,而是一种数据存储方式。在InnoDB中,表数据文件本身就是按B+Tree组织的一个索引结构,这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键,因此InnoDB表数据文件本身就是主索引。\n\n视图\n视图是指计算机数据库中的视图,是一个虚拟表,其内容由查询定义。同真实的表一样,视图包含一系列带有名称的列和行数据。但是,视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表,并且在引用视图时动态生成。\n\n创建一个简单视图V_ EMP_10 ,来显示部门10中的员工的编码、姓名和薪水: \nCREATE VIEW v_emp_10ASSELECT emono,ename,sal,deptnoFROM empWHERE deptno = 10;\n\n事物概念：在关系数据库中, 一个事务可以是一条SQL语句 , 一组SQL语句或整个程序。指访问并可能更新数据库中各的数据项的一个程序执行单元(unit)\n特性：事务是恢复和并发控制的基本单位。事务应该具有4个属性:原子性、一致性、隔离性、持久性。这四个属性通常称为ACID特性。\n\n原子性( atomicity )。一个事务是一个不可分割的工作单位,事务中包括的操作要么都做,要么都不做。\n一致性( consistency)。事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。\n隔离性( isolation)。一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔的,并发执行的各个事务之间不能互相干扰。\n持久性( durability )。持久性也称永久性( permanence) , 指一个事务一旦提交 ,它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。\n\n日志\n现在的数据库系统( Oracel、DB2、 MS SQL、MySQL等)都支持多用户,所有的数据库系统(包括Exchange ) , 都是把数据先写到日志中,等某个时机(比如:确认commit )后再写到数据库记录中,日志是数据库最重要的数据之一\n数据库都具有事务日志,用于记录所有事务以及每个事务对数据库所做的修改。事务日志是数据库的重要组件,如果系统出现故障,则可能需要使用事务日志将数据库恢复到一致状态。\n\nMySQL中有六种日志文件,分别是:\n\n重做日志(redolog)\n回滚日志(undolog)\n二进制日志( binlog )\n错误日志( errorlog )\n慢查询日志( slow query log )\n一般查询日志( general log )\n中继日志( relay log )\n\n其中重做日志和回滚日志与事务操作息息相关,二进制日志也与事务操作有一定的关系,这三种日志,对理解MySQL中的事务操作有着重要的意义。\nMySQL重做日志\n\n作用:确保事务的持久性。redo日志记录事务执行后的状态,用来恢复未写入data file的已成功事务更新的数据。防止在发生故障的时间点,尚有脏页未写入磁盘,在重启MySQL服务的时候,根据redo log进行重做,从而达到事务的持久性这一特性。\n内容:物理格式的日志,记录的是物理数据页面的修改的信息,其redo log是顺序写入redo log file的物理文件中去的。\n什么时候产生:事务开始之后就产生redo log , redo log的落盘并不是随着事务的提交才写入的,而是在事务的执行过程中,便开始写入redo log文件中。\n什么时候释放:当对应事务的脏页写入到磁盘之后, redo log的使命也就完成了,重做日志占用的空间就可以重用(被覆盖)。\n\nMySQL回滚日志\n\n作用:保证数据的原子性,保存了事务发生之前的数据的一个版本，可以用于回滚,同时可以提供多版本并发控制下的读( MVCC) , 也即非锁定读\n内容:逻辑格式的日志,在执行undo的时候,仅仅是将数据从逻辑上恢复至事务之前的状态,而不是从物理页面上操作实现的,这一点是不同于redo log的。\n什么时候产生:事务开始之前,将当前是的版本生成undo log , undo也会产生redo来保证undo log的可靠性\n什么时候释放:当事务提交之后, undo log并不能立马被删除,而是放入待清理的链表,由purge线程判断是否由其他事务在使用undo段中表的.上一个事务之前的版本信息,决定是否可以清理undo log的日志空间。\n\nMySQL二进制日志\n\n作用:用于复制,在主从复制中,从库利用主库上的binlog进行重播,实现主从同步。用于数据库的基于时间点的还原。\n内容:逻辑格式的日志,可以简单认为就是执行过的事务中的sq|语句。不光SQL语句本身,而是包括了执行的SQL语句(增删改)反向的信息,也就意味着delete对应着delete本身和其反向的insert ; update对应着update执行前后的版本的信息; insert对应着delete和insert本身的信息。\n什么时候产生:事务提交的时候, 一次性将事务中的SQL语句( 一个事物可能对应多个sql语句)按照一定的格式记录到binlog中。这里与redo log很明显的差异就是redo log并不一定是在事务提交的时候刷新到磁盘 , redo log是在事务开始之后就开始逐步写入磁盘。因此对于事务的提交,即便是较大的事务,提交( commit )都是很快的,但是在开启了binlog的情况下,对于较大事务的提交,可能会变得比较慢一些。\n什么时候释放:binlog的默认是保持时间由参数expire_ logs_days配置,也就是说对于非活动的日志文件,在生成时间超过expire_ logs_days配置的天数之后,会被自动删除。\n\n","categories":["阿里云ACA"],"tags":["DBMS"]},{"title":"Linux备忘录","url":"/2022/10/17/server/Linux%E5%A4%87%E5%BF%98%E5%BD%95/","content":"安装命令-bash: ar: command not found #Debianapt-get install binutils-aarch64-linux-gnu #Ubuntuapt-get install binutils-aarch64-linux-gnu #Arch Linuxpacman -S binutils-aarch64-linux-gnu #Kali Linuxapt-get install binutils-aarch64-linux-gnu #CentOSyum install binutils-aarch64-linux-gnu #Fedoradnf install binutils-aarch64-linux-gnu #Raspbianapt-get install binutils-aarch64-linux-gnu\n\n\nVI编辑器vi保存命令。\n\n按ESC键 跳到命令模式，然后：\n:w 保存文件但不退出vi\n:w file 将修改另外保存到file中，不退出vi\n:w! 强制保存，不推出vi\n:wq 保存文件并退出vi\n:wq! 强制保存文件，并退出vi\nq: 不保存文件，退出vi\n:q! 不保存文件，强制退出vi\n:e! 放弃所有修改，从上次保存文件开始再编辑。\n\nDocker安装：\ncurl -fsSL https://get.docker.com -o get-docker.sh  sudo sh get-docker.sh\n\n查看发行版和版本：\n\ncat /etc/os-release\ncat /etc/*-release\n\n\n查看内核版本和系统架构：\nuname -a (全部信息)\nuname -r (内核版本)\nuname -m (系统架构)\n\n\n查看系统详细信息：\nlsb_release -a (可能需安装)\n\n\n查看硬件信息：\nsudo lshw -short (可能需安装)\n\n\n\n查看正在运行的容器docker ps\n\n包括停止的：\ndocker ps -a\n\n进入容器docker exec -it 容器ID /bin/bash\n\nalpine:\ndocker exec -it 容器ID /bin/sh\n\n注：docker attach指令已经过时\n\nMysql of Dokcerdocker run -p 3306:3306 --name mysql \\-v /mydata/mysql/log:/vat/log/mysql \\-v /mydata/mysql/data:/var/lib/mysql \\-v /mydata/mysql/conf:/etc/mysql/conf.d \\-e MYSQL_ROOT_PASSWORD=root \\-d mysql:5.7\nMysql 配置文件[clinet]default-character-set=utf8  [mysql]default-character-set=utf8[mysqld]init_connect=&#x27;SET collation_connection = utf8_unicode_ci&#x27;init_connect=&#x27;SET NAMES utf8&#x27;character-set-server=utf8collation-server=utf8_unicode_ciskip-character-set-client-handshakeskip-name-resolvnet\n\n\nRedisRedis of Dockermkdir -p /mydata/redis/conf &amp;&amp; touch /mydata/redis/confredis.conf\n\ndocker run -p 6379:6379 --name redis -v /mydata/redis/data:/data \\-v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf \\-d redis redis-server /etc/redis/redis.conf","categories":["Linux"],"tags":["linux"]},{"title":"rustdesk中继服务器的docker镜像","url":"/2023/04/18/server/rustdesk%E4%B8%AD%E7%BB%A7%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84docker%E9%95%9C%E5%83%8F/","content":"1、docker 拉取镜像\ndocker image pull rustdesk/rustdesk-server\n12、运行hbbs\ndocker run --name hbbs -p 21115:21115 -p 21116:21116 -p 21116:21116/udp -p 21118:21118 -v `pwd`:/root -it --net=host --rm rustdesk/rustdesk-server hbbs -r 自己的服务器IP\n\n3、运行hbbr\ndocker run --name hbbr -p 21117:21117 -p 21119:21119 -v `pwd`:/root -it --net=host --rm rustdesk/rustdesk-server hbbr\n\n4、配置防火墙与安全组TCP(21115, 21116, 21117, 21118, 21119)UDP(21116)网页客户端（21118，21119），对应端口可以不开。\n","categories":["玩转服务器"]},{"title":"面板","url":"/2023/04/18/server/%E9%9D%A2%E6%9D%BF/","content":"portainer面板docker stop portainerdocker pull portainer/portainerdocker run -d -p 9000:9000 --name portainer --restart always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer\n\n远程连接：\n修改配置文件：\nExecStart=/usr/bin/dockerd -H fd:// -H tcp://0.0.0.0:2375 --containerd=/run/containerd/containerd.sock\n\n添加防火墙规则：\nsudo iptables -A INPUT -p tcp --dport 2375 -s 39.105.2.205 -j ACCEPTsudo iptables -A INPUT -p tcp --dport 2375 -j DROP","categories":["玩转服务器"]},{"title":"常用软件安装","url":"/2023/04/18/server/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/","content":"curlapt-get update -y &amp;&amp; apt-get install _curl_ -y\n\nDocker-sSL https://get.docker.com/ | sh\n\nvim /etc/docker/daemon.json\n\n\netc目录下，可能没有docker文件夹，需要手动创建：mkdir /etc/docker\n\n&#123;  &quot;registry-mirrors&quot;: [    &quot;https://dockerproxy.com&quot;,    &quot;https://hub-mirror.c.163.com&quot;,    &quot;https://mirror.baidubce.com&quot;,    &quot;https://ccr.ccs.tencentyun.com&quot;,  ]&#125;\n\n使配置生效 systemctl daemon-reload重启Docker systemctl restart docker\n","categories":["玩转服务器"]},{"title":"Alist美化","url":"/2022/07/31/%E5%8D%9A%E5%AE%A2/Alist%E7%BE%8E%E5%8C%96/","content":"Alist官网\n效果:\n参考以下API：aplayer、metinglive2d-widget\n代码：head：\n&lt;style&gt;    .chakra-ui-light&#123;      background-image: url(&quot;https://www.dmoe.cc/random.php&quot;) !important;      background-repeat:no-repeat;background-size:cover;background-attachment:fixed;background-position-x:center;    &#125;    .main-box &#123;      border-radius: 15px !important;    &#125;    .chakra-ui-light .main-box &#123;      background-color: #ffffff70 !important;    &#125;    .chakra-ui-light .readme-box &#123;      background-color: white !important;    &#125;    .readme-box &#123;      border-radius: 15px !important;    &#125; &lt;/style&gt; &lt;script src=&quot;https://eqcn.ajz.miesnfu.com/wp-content/plugins/wp-3d-pony/live2dw/lib/L2Dwidget.min.js&quot;&gt;&lt;/script&gt; &lt;!-- 看板娘 --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css&quot;&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js&quot;&gt;&lt;/script&gt; &lt;!--鼠标点击效果--&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@3.0.8/js/maodian.js&quot;&gt;&lt;/script&gt; &lt;!-- aplayer、meting --&gt;&lt;!-- require APlayer --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css&quot;&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js&quot;&gt;&lt;/script&gt;&lt;!-- require MetingJS --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js&quot;&gt;&lt;/script&gt; &lt;!-- nplayer --&gt;&lt;script src=&quot;https://unpkg.com/nplayer@latest/dist/index.min.js&quot;&gt;&lt;/script&gt;\n\nbody：\n&lt;meting-js auto = &quot;https://y.qq.com/n/ryqq/playlist/2970622459.html&quot;fixed = true&gt;&lt;/meting-js&gt;\n\n","categories":["博客"]},{"title":"防火墙","url":"/2023/05/10/server/%E9%98%B2%E7%81%AB%E5%A2%99/","content":"版本查看：\niptables --version\n\n安装：\nsudo apt-get updatesudo apt-get install iptables\n\n当前的规则:\nsudo iptables -L -n -v\n\n-L 选项表示 “list”（列出），-n 选项表示 “numeric”（不要解析和显示主机名、网络名和端口名），而 -v 选项表示 “verbose”（显示详细信息）\n","categories":["server"],"tags":["linux"]},{"title":"Github+hexo网站搭建","url":"/2021/11/10/%E5%8D%9A%E5%AE%A2/Github&hexo%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/","content":"&emsp;&ensp;  这个是我在网络上学习博客搭建而编写的教程，在这里我非常的感谢b站的 CoolPlayer-函博，视频搬运崽啊 和CSDN社区的大佬们。\n\n前言\n使用github pages服务搭建博客的好处有：\n\n\n全是静态文件，访问速度快；\n免费方便，免费搭建个人博客，不需要服务器不需要后台；\n可以随意绑定自己的域名；\n数据绝对安全，基于github的版本管理，可以恢复历史版本；\n博客内容可以轻松打包、转移、发布或分享到其它平台；\n.......\n\n\n准备工作\n注册 github账号\n安装node.js、npm、git\nnode -v\nnpm -v\ngit --version\n输入以上指令检查软件是否安装，如果有错误请自行百度查找原因\n本文所使用的环境：\n\nWindiws 10\nnode 16.13.0\nnpm 8.1.0\ngit 2.34.0\n\n搭建github博客\n创建仓库\n新建一个名为 你的用户名.github.io 的仓库(必须是你的用户名，其他名称无效)，建立之后你的网站访问地址就是http://你的用户名.github.io。\n每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。\n绑定域名\n如果想要你的域名更个性一点，拥有自己的域名那就看看这一步吧:\n首先注册一个域名，域名选择一定要选个大公司，在这里我推荐去godaddy ,或者国内的阿里云 。\n域名分为两种：带WWW的和不带WWW的。\n域名配置最常见的方式：\n1.记录类型分别填CNAME和A。\n2.CNAME填写域名。\n3.A记录值填写你的你的用户名.github.io的网址IP。\n\n由于不带www方式只能采用A记录，所以必须先ping一下 你的用户名.github.io 的IP，将ping出来的ip填入A记录值，这样才能保证无论是否添加www都可以访问。\n\n4.在你的github项目根目录新建一个名为CNAME的文件（无后缀），里面填写你的域名，加不加www看你自己喜好。\n\n\n如果你填写的是没有www的，比如 mygit.me，那么无论是访问 http://www.mygit.me 还是 http://mygit.me ，都会自动跳转到 http://mygit.me\n如果你填写的是带www的，比如 www.mygit.me ，那么无论是访问 http://www.mygit.me 还是 http://mygit.me ，都会自动跳转到 http://www.mygit.me\n如果你填写的是其它子域名，比如 abc.mygit.me，那么访问 http://abc.mygit.me 没问题，但是访问 http://mygit.me ，不会自动跳转到 http://abc.mygit.me\n\n\n5.绑定新域名之后，原来的你的用户名.github.io并没有失效，而是会自动跳转到你的新域名。\n配置SSH key\n提交代码需要你的github权限，直接使用用户名和密码不安全，在这里我们我们使用ssh key来解决本地和服务器的连接问题。\n用git bash执行如下命令:\n$ git config --global #user.name &quot;git用户名&quot;或邮箱地址 \n$ cd ~/.ssh #检查本机已存在的ssh密钥\n$ ls\n$ ssh-keygen -t rsa -C #&quot;邮箱地址&quot; 连续回车三次\n$ vim id_rsa.pub\n：wq\n$ ssh -T git@github.com    #查看安装成功\n查看公钥：cat id_rsa.pub 或者vim id_rsa.pub\n复制 id_rsa.pub文件内容到githubkey里add就可以了\n\n打开github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key\n将刚复制的内容粘贴到key那里，title随便填，保存。\n\n测试是否成功\n$ ssh -T git@github.com # 注意邮箱地址不用改\n如果提示 Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到：\n\nHi liuxianan! You’ve successfully authenticated, but GitHub does not provide shell access.\n\n看到这个信息说明SSH已配置成功。\n此时你还需要配置：\n$ git config --global user.name &quot;liuxianan&quot;// 你的github用户名，非昵称\n$ git config --global user.email  &quot;xxx@qq.com&quot;// 填写你的github注册邮箱\n作用是执行hexo d操作后上传源代码\n使用hexo写博客\nhexo介绍\nHexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。\n原理\ngithub pages存放的是静态文件，blog存放不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，所以hexo所做的就是将这些md文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到github。\n安装\n$ npm install -g hexo\n初始化\n在电脑建立名为name的文件夹，比如我的是 D:\\Workspaces\\blog 。\n$ cd /D/Workspaces/blog/\n$ hexo init\nhexo会自动下载一些文件到这个目录，包括node_modules\n$ hexo g # 生成\n$ hexo s # 启动服务\n执行以上命令之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github去的。\nhexo s #开启本地预览服务\n浏览器打开http://localhost:4000 即可看到篇名为 Hello World 的文章，如果浏览器一直加载不出来可能是因为端口占用的缘故。\n\n解决端口冲突问题请参考这篇文章：\nhttp://blog.liuxianan.com/windows-port-bind.html\n\n修改主题\n默认主题很丑，我们首先替换一个好看点的主题。这是官方主题 。\n我们以hexo-theme-yilia主题为例:\n首先下载这个主题：\n$ cd /f/Workspaces/hexo/\n$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia\n下载主题在 D:\\Workspaces\\blog\\themes 文件夹里。\n修改_config.yml中的theme: landscape改为theme: yilia。\n$ hexo clean #清理public文件夹\n$ hexo g #重新生成\n备份\n虽然github有版本管理，但备份一下总是好的（以防万一）\n上传到github\n配置 _config.yml 中有关deploy的部分:\n正确写法：\ndeploy:\n  type: git\n  repository: git@github.com:liuxianan/liuxianan.github.io.git\n  branch: master\n错误写法：\ndeploy:\ntype: github\nrepository: https://github.com/liuxianan/liuxianan.github.io.git\nbranch: master\n安装插件：\nnpm install hexo-deployer-git --save\n没有安装此插件会报以下错误：\nDeployer not found: github 或 Deployer not found: git\ngit bash #部署\n部署这个命令一定要用git bash，否则会提示 Permission denied (publickey). \n$ hexo d #上传\n将本次有改动的代码全部提交，没有改动的不会\n保留CNAME、README.md等文件\n提交之后网页上一看，发现以前其它代码都没了，此时不要慌，一些非md文件可以把他们放到source文件夹下，这里的所有文件都会原样复制（除了md文件）到public目录。\nhexo默认会把所有md文件都转换成html，包括README.md，所有需要每次生成之后、上传之前，手动将README.md复制到public目录，并删除README.html。\n常用hexo命令\n常见命令：\nhexo new &quot;postName&quot; #新建文章\nhexo new page &quot;pageName&quot; #新建页面\nhexo generate #生成静态页面至public目录\nhexo server #开启预览访问端口（默认端口4000，&#039;ctrl + c&#039;关闭server）\nhexo deploy #部署到GitHub\nhexo help  # 查看帮助\nhexo version  #查看Hexo的版本\n缩写：\nhexo n == hexo new\nhexo g == hexo generate\nhexo s == hexo server\nhexo d == hexo deploy\n组合命令；\nhexo s -g #生成并本地预览\nhexo d -g #生成并上传\n_config.yml\n可以在 _config.yml 中修改\n# Hexo Configuration\n## Docs: http://hexo.io/docs/configuration.html\n## Source: https://github.com/hexojs/hexo/\n# Site 站点配置\ntitle: Hexo-demo #网站标题\nsubtitle: hexo is simple and easy to study #网站副标题\ndescription: this is hexo-demo #网栈描述\nauthor: pomy #你的名字\nlanguage: zh-CN #网站使用的语言\ntimezone: Asia/Shanghai #网站时区\n# URL #可以不用配置\n## If your site is put in a subdirectory, set url as &#039;http://yoursite.com/child&#039; and root as &#039;/child/&#039;\nurl: http://yoursite.com #网址，搜索时会在搜索引擎中显示\nroot: / #网站根目录\npermalink: :year/:month/:day/:title/ #永久链接格式\npermalink_defaults: #永久链接中各部分的默认值\n# Directory 目录配置\nsource_dir: source #资源文件夹，这个文件夹用来存放内容\npublic_dir: public #公共文件夹，这个文件夹用于存放生成的站点文件\ntag_dir: tags #标签文件夹\narchive_dir: archives #归档文件夹\ncategory_dir: categories #分类文件夹\ncode_dir: downloads/code #Include code 文件夹\ni18n_dir: :lang #国际化文件夹\nskip_render: #跳过指定文件的渲染，您可使用 glob 来配置路径\n# Writing 写作配置\nnew_post_name: :title.md # 新文章的文件名称\ndefault_layout: post #默认布局\ntitlecase: false # Transform title into titlecase\nexternal_link: true # Open external links in new tab\nfilename_case: 0 #把文件名称转换为 (1) 小写或 (2) 大写\nrender_drafts: false #显示草稿\npost_asset_folder: false #是否启动资源文件夹\nrelative_link: false #把链接改为与根目录的相对位址\nfuture: true\nhighlight: #代码块的设置\nenable: true\nline_number: true\nauto_detect: true\ntab_replace:\n# Category &amp; Tag 分类 &amp; 标签\ndefault_category: uncategorized #默认分类\ncategory_map: #分类别名\ntag_map: #标签别名\n# Date / Time format 时间和日期\n## Hexo uses Moment.js to parse and display date\n## You can customize the date format as defined in\n## http://momentjs.com/docs/#/displaying/format/\ndate_format: YYYY-MM-DD\ntime_format: HH:mm:ss\n# Pagination 分页\n## Set per_page to 0 to disable pagination\nper_page: 10 #每页显示的文章量 (0 = 关闭分页功能)\npagination_dir: page #分页目录\n# Extensions 扩展\n## Plugins: http://hexo.io/plugins/ 插件\n## Themes: http://hexo.io/themes/ 主题\ntheme: landscape #当前主题名称\n# Deployment #部署到github\n## Docs: http://hexo.io/docs/deployment.html\ndeploy:\ntype:\n一般主题下有一个 languages 文件夹，用于对应 language 配置项。比如在 ejs 中有：\n&lt;%= __('tags') %&gt;\nlanguage 的配置项是 zh-CN ，则会在 languages 文件夹下找到 zh-CN.yml 文件中对应的项来解释。\n修改全局配置时，注意缩进，同时注意冒号后面要有一个空格。\n新建博客文章\nhexo new &#039;my-first-blog&#039;\nhexo会帮我们在_posts下生成相关md文件\n我们只需要打开这个文件就可以开始写博客了，默认生成如下内容：\n---\ntitle: my-first-blog\ndate: 2021-11-19 10:40:00\ntags:\n---\n也可以直接自己新建md文件，用这个命令的好处是帮我们自动生成了时间。\n一般完整格式如下：\n---\ntitle: postName #文章页面上的显示名称，一般是中文\ndate: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改\ncategories: 默认分类 #分类\ntags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格\ndescription: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面\n---\n\n以下是正文\nhexo new page &quot;my-second-blog&quot;\nhexo new page 'postName'命令和hexo new 'postName'区别:\n最终部署时生成：blog\\public\\my-second-blog\\index.html，但是它不会作为文章出现在博文目录。\n如何让博文列表不显示全部内容\n默认情况下，生成的博文目录会显示全部的文章内容，如何设置文章摘要的长度呢？\n答案：是在合适的位置加上即可，例如：\n这个是我在网络上学习的Github+hexo搭建的网站，在这里我非常的感谢b站的 [CoolPlayer-函博](https://space.bilibili.com/350090479?spm_id_from=333.788.b_765f7570696e666f.1)，[视频搬运崽啊](https://space.bilibili.com/441519471?spm_id_from=333.788.b_765f7570696e666f.2) 和CSDN社区的大佬们。\n\n&lt;!–more–&gt;\n前言使用github pages服务搭建博客的好处有：\n\n\n全是静态文件，访问速度快；\n免费方便，免费搭建个人博客，不需要服务器不需要后台；\n可以随意绑定自己的域名；\n数据绝对安全，基于github的版本管理，可以恢复历史版本；\n博客内容可以轻松打包、转移、发布或分享到其它平台；\n…….\n\n\nCustom 404页面\n在blog/source目录下创建404.html\n404.html的内容可以设置为下面的内容 _config.yml中的permalink_defaults属性不需要修改）.\n---\nlayout: default\n---\n&lt;html&gt;\n    &lt;head&gt;\n         &lt;meta charset=&quot;UTF-8&quot; /&gt;\n         &lt;title&gt;404&lt;/title&gt;                                                                                                                                        \n    &lt;/head&gt;\n    &lt;body&gt;\n         &lt;script type=&quot;text/javascript&quot; src=&quot;http://www.qq.com/404/search_children.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n简化:\n&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.qq.com/404/search_children.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;\n其他\n中文乱码\n在md 文件中写中文内容，发布出来后为乱码，原因是md的编码不对，将md文件另存为“UTF-8”编码的文件即可解决问题。","categories":["博客"],"tags":["git","github","hexo"]},{"title":"Hexo + OBSIDIAN 插件配置","url":"/2023/04/18/%E5%8D%9A%E5%AE%A2/Hexo%20and%20OBSIDIAN%20%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE/","content":"前言写了很久博客了，原来halo搭建的博客又转移到hexo了，转移原因如下：\n\n写文章不方便。每次在本地Typora写完一次笔记，都要登录网站粘贴进去， 很麻烦。\n需要定期维护网站。网站稳定点还好，但是我那个腾讯服务器经常死机，哎真麻烦\n\n插件配置本次用到的插件：\n\nImage auto upload Plugin (PicGo图床上传)\nObsidian Git (快速Git上传)\nTemplater (文件元数据模板)\nUpdate time on edit (自动更新时间)\n\nPicGo图床上传前置条件：安装并配置PicGo安装插件：Image auto upload Plugin\n\n快速Git上传安装插件：Obsidian Git\n根据喜好可以设置自动git推送 (推荐手动)\n\nCtrl + P 快捷键输入命令，如 输入git可以看到所有命令\n\n文件元数据模板安装插件：Templater\n这个是自动配置模板的，要开始使用 Templator，必须创建一个目录来存储模板的 markdown 文件，如 Templator 文件夹位置中所述。\n在我的环境中，还存放了核心插件的模板，所以目录结构如下。\nTemplates/├── Template MOC.md # 手册├── Template/ # 核心插件的模板└── Templater Plugin/ # 社区插件的模板\n\nTemplate MOC.md描述了模板文件以及如何使用它。 Templater Plugin将模板文件移动到目录后，在Template Plugin设置画面的Template Folder Location项目中输入路径。\n我的 Templater Plugin 配置如下：\n---title: &lt;% tp.file.title %&gt;categories: - &lt;% tp.file.folder(relative=true) %&gt;tags: - &#x27;&#x27;data: &lt;% tp.date.now(format=&quot;YYYY-MM-DD HH:mm:ss&quot;) %&gt;updated: &#x27;&#x27;---\n\nAlt+ E 快捷键使用模板\n详细配置可以看官方文档\n自动更新时间安装插件：Update time on edit\n\n设置钩子函数自动生成静态资源.git\\hooks 创建一个名为pre-commit的文件，内容如下：\n#!/bin/sh# pre-commitecho -e &quot;\\033[1;35mRunning pre-commit checks\\033[0m&quot;# Run your compile command herehexo clean &amp;&amp; hexo g# Add the compiled filesgit add .echo -e &quot;\\033[1;35mStatic resource to generate success\\033[0m&quot;# If all checks have passed, run git commit with the original commit messageexec git commit -m &quot;Auto commit at $(date)&quot; --no-verify\n\n\n下一步打算当然是写一个自己的博客系统了，最重要的实现和hexo博客实时同步功能，这样就可以实现一个博客编写多个博客同步了\n相关链接\nObsidian中文教程\nプラグインを導入しよう｜Obsidian.Zenn\n\n","categories":["博客"],"tags":["hexo","obsidian"]},{"title":"HelloWord","url":"/2022/07/12/%E5%8D%9A%E5%AE%A2/HelloWord/","content":"\nhelloword\n\n注在此之前的文章都是当初从github的hexo博客搬过来的，当时在学校也就写了那么几个= =\n\n来自QQ空间：Ok,我的博客又活了。首先感谢各位前辈们，新网址已加入二级域名，原网址计划建成主页导航，博客网址：bolg.wrxinyue.cn。关于本博客使用wordpress+sakura主题制作并进行修改，框架：php7.1，apache2.4.53(已放弃nginx)，MySQL 5.6.50。sakura主题使用感受:该主题不兼容PHP7.4以上版本，以后可能需要考虑手动改框架。对sakura主题进行美化，修复了hermit x播放器的问题，更新了图片API，添加了live2d并进行适配。再次感谢这些前辈们的无私奉献的开源精神\n\n原HEXO博客样式：地址：https://wrxinyue.github.io/blog/\n","categories":["博客"]},{"title":"Markdown语法","url":"/2021/11/20/%E5%8D%9A%E5%AE%A2/Markdown%E8%AF%AD%E6%B3%95/","content":"前言：在建造博客网站时我是第一次接触到关于Markdown的文本语言，Markdown经常会被用来写博客使用，Markdown学起来很简单，下面是我整理的关于Markdown语法手册，希望能帮到像我这样刚刚学会建立博客网站的萌新。\nMarkdown 标题\n= 和 - 标记语法格式如下：\n我展示的是一级标题\n=================\n\n我展示的是二级标题—————–\n使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推：\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\nMarkdown 段落\nMarkdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。\n字体\nMarkdown 可以使用以下几种字体：\n*斜体文本*\n_斜体文本_\n**粗体文本**\n__粗体文本__\n***粗斜体文本***\n___粗斜体文本___\n显示效果：\n斜体文本\n斜体文本\n粗体文本\n粗体文本\n粗斜体文本\n粗斜体文本\n分割线\n***\n* * *\n*****\n- - -\n----------\n显示效果：\n\n\n\n\n\n删除线\n~~删除线~~\n删除线\n下划线\n&lt;u&gt;下划线文本&lt;/u&gt;\n下划线文本\n脚注\n脚注是对文本的补充说明。\nMarkdown 脚注的格式如下:\n注释[^要注明的文本]\n\n显示效果：\n注释^要注明的文本\nMarkdown 列表\nMarkdown 支持有序列表和无序列表。\n无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要添加一个空格，然后再填写内容：\n* 第一项\n* 第二项\n* 第三项\n\n\n第一项\n第二项\n第三项\n\n\n第一项\n第二项\n第三项显示效果：\n\n\n第一项\n\n\n第二项\n\n\n第三项\n\n\n第一项\n\n\n第二项\n\n\n第三项\n\n\n第一项\n\n\n第二项\n\n\n第三项\n\n\n有序列表使用数字并加上 . 号来表示，如：\n1. 第一项\n\n\n第二项\n第三项显示效果：\n\n第一项\n第二项\n第三项\n\n列表嵌套\n1. 第一项：\n - 第一项嵌套的第一个元素\n - 第一项嵌套的第二个元素\n第二项：\n第二项嵌套的第一个元素\n第二项嵌套的第二个元素显示效果：\n\n第一项：\n\n第一项嵌套的第一个元素\n第一项嵌套的第二个元素\n\n第二项：\n\n第二项嵌套的第一个元素\n第二项嵌套的第二个元素\n\n\nMarkdown 区块\nMarkdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号：\n> 区块引用\n显示效果：\n\n区块引用\n\n区块是可以嵌套的：\n> 最外层\n> &gt; 第一层嵌套\n> &gt; &gt; 第二层嵌套\n显示效果：\n\n最外层\n\n第一层嵌套\n\n第二层嵌套\n\n\n\n区块中使用列表\n区块中使用列表实例如下：\n> 区块中使用列表\n> 1. 第一项\n> 2. 第二项\n> + 第一项\n> + 第二项\n> + 第三项\n显示效果：\n\n区块中使用列表\n\n第一项\n第二项\n\n\n第一项\n第二项\n第三项\n\n\n列表中使用区块\n如果要在列表项目内放进区块，那么就需要在 &gt; 前添加四个空格的缩进。\n列表中使用区块实例如下：\n* 第一项\n &gt; 嵌套的第一个元素\n &gt; 嵌套的第二个元素\n\n\n\n\n第二项\n\n第一项\n\n嵌套的第一个元素\n嵌套的第二个元素\n\n\n\n第二项\n\n\nMarkdown 代码\n如果是段落上的一个函数或片段的代码可以用反引号把它包起来（`），例如：\n`printf()` 函数\n代码区块\n代码区块使用 4 个空格或者一个制表符（Tab 键）:\n    &lt;?php #在开头前面加\n  echo &#039;blog&#039;;\n  function test() &#123;\n      echo &#039;test&#039;;\n  &#125;\n显示效果：\n","categories":["博客"]},{"title":"hugo+github+vercel导航搭建","url":"/2023/01/09/%E5%8D%9A%E5%AE%A2/hugo&github&vercel%E5%AF%BC%E8%88%AA%E6%90%AD%E5%BB%BA/","content":"安装hugo注：再此之前需要安装choco包管理器\nchoco install hugo -confirm\n\n\n\n使用Hugo创建博客# 创建名为navigation的博客hugo new site navigation\n\n\n\n下载博客主题\n进入themes文件夹，并打开cmd\n\n输入git clone https://github.com/shenweiyan/WebStack-Hugo.git\n\nthemes&#x2F;WebStack-Hugo&#x2F;exampleSite 目录下的所有文件复制到 hugo 站点根目录\ncopy WebStack-Hugo/exampleSite/* .. -force &amp;&amp; cd..\n\n\n此时我们回到根目录发现，我们的文件已经复制成功。（ps：个人还是比较习惯用命令端）\n\n删除.git文件夹(如果有)\n注：如果git的主题有.git和.github文件夹，我们就需要手动删除，否则在推送的时候主题就会出现问题\n\n# 删除 .git 和 .github 文件,注意！这里我用的是powershell，cmd命令：# rd /s /q .git &amp;&amp; rd /s /q .githubRemove-Item -Recurse -Force .git &amp;&amp; Remove-Item -Recurse -Force .github\n\n\n\n启动Hugo预览服务器hugo.exe server\n\n\n点击并进入 http://localhost:1313/ ，进入之后就可以看到我们的站点创建成功了！\n\n具体步骤# 创建名为navigation的博客hugo new site navigationcd navigation\\themes# 下载博客主题git clone https://github.com/shenweiyan/WebStack-Hugo.gitcd WebStack-Hugo/# 复制文件到根目录copy exampleSite/* ..\\.. -force# 删除 .git 和 .github 文件# rd /s /q .git &amp;&amp; rd /s /q .githubRemove-Item -Recurse -Force .git &amp;&amp; Remove-Item -Recurse -Force .githubcd ..\\..# 启动Hugo预览服务器hugo.exe server\n\n使用说明官方文档：WebStack-Hugo | 一个静态响应式网址导航主题 (yuque.com)\n详细说明我就不写了，官方文档都有，我们来简单配置一下，在根目录data创建一个webstack.yml的文件配置如下:\n- taxonomy: 科研办公  icon: fas fa-flask fa-lg  list:    - term: 生物信息      links:        - title: NCBI          logo: ncbi.jpg          url: https://www.ncbi.nlm.nih.gov/          description: National Center for Biotechnology Information.        - title: Bioconda          logo: bioconda.jpg          url: https://anaconda.org/bioconda/          description: &quot;Bioconda :: Anaconda.org.&quot;    - term: 云服务器      links:        - title: 阿里云          logo: 阿里云.jpg          url: https://www.aliyun.com/          description: 上云就上阿里云。        - title: 腾讯云          logo: 腾讯云.jpg          url: https://cloud.tencent.com/          description: 产业智变，云启未来。\n\ngithub+vercel网页托管创建仓库正常创建仓库即可，这里我可见选择的是Private\n\n提交仓库创建成功之后，我们把仓库地址复制一些，然后回到我们的shell窗口把项目提交到仓库\n\n具体命令如下：\ngit initgit add .git commit -m &quot;first commit&quot;git checkout -b maingit remote add origin https://github.com/WRXinYue/navigation.gitgit push -u origin main\n\n\n\nvercel关于注册我就不详细说了网上教程一大堆，我们直接快速进入；\n\n点击Add New…,进入页面之后登录GitHub账号进行导入\n\n\n找到我们仓库的项目，然后点击Import导入\n\n\nFramework Preset选择Hugo，然后点击Deploy进行部署\n\n\n部署成功!是不是很easy呢，之后可以根据自己的喜爱进行修改域名以及样式\n\n\n","categories":["博客搭建"],"tags":["git","github","hugo"]},{"title":".mo、po、.pot文件和wordpress汉化","url":"/2022/08/07/%E5%8D%9A%E5%AE%A2/mo%E3%80%81po%E3%80%81pot%E6%96%87%E4%BB%B6%E5%92%8Cwordpress%E6%B1%89%E5%8C%96/","content":".mo、po、和.pot文件介绍\nMO文件：MO，即机器对象，是一个二进制数据文件，包含了程序所引用的对象数据。它通常被用来翻译程序代码，并可以被加载或导入GNU gettext程序中。\nPO文件：PO文件是包含实际翻译的文件。每种语言都会有自己的PO文件，例如，中文会有zh_CN文件，法语会有fr.po文件，德语会有de.po，美式英语可能有en_US.po。\nPOT文件：POT文件是PO文件的模板文件。它们会把所有的翻译字符串留空。一个POT文件本质上是一个没有翻译的空PO文件，只有原始字符串。\n\n\nwordpress的汉化机制\n在php文件中，需要汉化的地方使用__()或_e()函数进行标识；\n​\t_()函数返回翻译后的字符串，而__e()函数打印出翻译后的字符串。其实__e()就相当于echo __()。\n\n\n创建.po文件，进行翻译；\n\n将.po文件编译成.mo文件；\n\n向主题中加载.mo文件。\n\n\npoedit的使用方法：打开我们的zh_CN.po文件，然后点击翻译-从源代码更新，就可以获取到我们要翻译的单词\n\n保存之后替换即可\n翻译之前：\n\n翻译之后：\n\n后语：什么是GNU gettext？GNU gettext 是使用最广泛的自由软件国际化工具之一\nGNU gettext 工具（msgfmt、xgettext 等）的 Windows 构建，由 Poedit 开发人员维护。\n该函数通常具有 _() 别名，以使代码更简单易读。\n此外，它提供了 pgettext() 调用，可用于为翻译者提供更多的上下文；还提供了 ngettext()，可以处理目标语言定义的复数类型。\n作为广泛传播的工具，它具有很多封装，使其使用相当简单，你也许会想尝试其中之一，例如 intltool，而非下面描述的对 gettext 的手动调用。\n关于Poedit\nPoedit是一个免费增值软件及跨平台的gettext类国际化翻译编辑器，也是同类型软件中最广泛使用的一个。现时它不论在Unix+GTK 或 Windows平台 配合wxWidgets 均有相关版本。\n\n参考：https://wordpress.stackexchange.com/questions/227822/what-is-the-difference-between-the-po-mo-and-pot-localization-files\nhttps://www.daimajiaoliu.com/daima/6cc27ed6f166400\n","categories":["博客"],"tags":["wordpress"]},{"title":"像素教程 84P","url":"/2022/07/31/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E5%83%8F%E7%B4%A0%E6%95%99%E7%A8%8B/","content":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["其他"]},{"title":"使用PicGo+Github+jsDelivr搭建图床（扩展Typora）","url":"/2022/07/17/%E5%8D%9A%E5%AE%A2/%E4%BD%BF%E7%94%A8PicGo&Github&jsDelivr%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A%EF%BC%88%E6%89%A9%E5%B1%95Typora%EF%BC%89/","content":"前言\n本文内容包括：\n\n\n创建一个 github 仓库\n使用 jsDelivr 免费 CDN 加速图片访问速度\n创建 Token\n使用 PicGo 配置 github 图床\n\n\n众所周知网站图片是会影响云服务器性能，在我们这些小博客网站流量是非常有限的，为了避免网站性能降低我们除了压缩媒体文件还可以通过远程调用的方法，也就是用一个单独的云服务器存放媒体，如用一个专门的图床网站或者阿里云OSS对象存储之类的作为网站图床。\n什么是图床：\n\n图床一般是指储存图片的服务器，有国内和国外之分。国外的图床由于有空间距离等因素决定访问速度很慢影响图片显示速度。国内也分为单线空间、多线空间和cdn加速三种。\n图床就是专门用来存放图片，同时允许你把图片对外连接的网上空间，不少图床都是免费的。\n\n\n使用PicGo+GitHub+jsDelivr搭建图床\n配置Github\n\n登陆github账号创建新的仓库\n\n\n\n填写仓库属性\n\n\n\n\n点击头像-Settings-Developer settings-Personal access tokens-Generate new token\n\n\n\n填写内容\n\n\n\n复制token\n\n\n\n配置PicGo\nPicGo官方下载链接\n\n\n仓库名即为你的github账号/图片仓库名\n分支名我在这里使用master\nToken 就填写刚才我们生成的 Token\n存储路径如果需要指定子目录可以填写例如 img/  如果没有填，就会上传到图片仓库的根目录。\n自定义域名就填写 jsDelivr 的域名，即图片访问地址，不包括图片路径的前半部分，\nhttps://cdn.jsdelivr.net/gh/用户名/仓库名\n最后设为默认图床，下次在 typora 上传图片就会自动上传到 github 图床了。\n\n扩展\n图片粘贴到Typora后，自动把图片上传到配置好的图床上\n配置Typora\n文件-偏好设置-图像\n","categories":["博客搭建"],"tags":["github","博客","jsdelivr"]},{"title":"WSL","url":"/2023/04/19/%E5%85%B6%E5%AE%83/WSL/","content":"常用WSL命令ssh连接WSL2重装SSH：\nsudo apt-get remove openssh-serversudo apt-get install openssh-server\n\n编辑 shd_config\nsudo vi /etc/ssh/sshd_config\n\n添加：\nPort 22PermitRootLogin yesPasswordAuthentication yes\n\n编辑sudo vim &#x2F;etc&#x2F;hosts.allow\nsudo vim /etc/hosts.allow\n\n添加：\nsshd: ALL\n\n重启ssh服务：\nsudo service ssh --full-restart\n\n查看wsl IP地址\nifconfig\n\npowershell输入命令将端口转发到WSL2：\nnetsh interface portproxy add v4tov4 listenaddress=0.0.0.0 listenport=22 connectaddress=xxx.xxx.xxx.xxx connectport=22\n此处xxx.xxx.xxx.xxx替换成wsl的IP地址，如172.18.195.3\n然后就可以通过127.0.0.1或者localhost连接到wsl2\nWSL2设置代理单次配置HTTP协议：\nexport hostip=$(cat /etc/resolv.conf |grep -oP &#x27;(?&lt;=nameserver\\ ).*&#x27;)export https_proxy=&quot;http://$&#123;hostip&#125;:10811&quot;;export http_proxy=&quot;http://$&#123;hostip&#125;:10811&quot;;\n\nsocket5协议：\nexport http_proxy=&quot;socks5://$&#123;hostip&#125;:10810&quot;export https_proxy=&quot;socks5://$&#123;hostip&#125;:10810&quot;\n\n其他和验证：\n端口相同可以合并一段话\nexport all_proxy=&quot;socks5://$&#123;hostip&#125;:7890&quot;\n\n使用curl即可验证代理是否成功，如果有返回值则说明代理成功：\ncurl www.google.com\n\n\n扩展阅读\n为 WSL2 一键设置代理\nWSL2配置代理 - Leaos - 博客园\n使用 WSL 在 Windows 上安装 Linux\n如何用笔记本ssh连接局域网内其他电脑上的wsl2 ubuntu\n在 适用于 Linux 的 Windows 子系统 上运行 Linux GUI 应用\nWindow10 建置Ubuntu(WSL2)與GUI桌面配置筆記\n\n","categories":["其它"]},{"title":"代理设置","url":"/2023/04/18/%E5%85%B6%E5%AE%83/%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE/","content":"gitgit config --global https.proxy  http://127.0.0.1:10809git config --global http.proxy  http://127.0.0.1:10809\n\n\nsocks5 代理git config --global http.proxy &#x27;socks5://127.0.0.1:10808&#x27;git config --global https.proxy &#x27;socks5://127.0.0.1:10808&#x27;\n\n查看代理git config --global  --get http.proxygit config --global  --get https.proxy\n\n如果没有设置代理，上述命令将什么也不会打印。\n清除代理git config --global --unset http.proxygit config --global --unset https.proxy\n\nYarn设置命令yarn config set https-proxy http://127.0.0.1:1087yarn config set proxy http://127.0.0.1:1087\n\n查看命令yarn config list\n\n取消命令yarn config delete proxyyarn config delete https-proxy\n\nnpm设置命令：npm config set proxy  http://127.0.0.1:1087npm config set https-proxy http://127.0.0.1:1087\n\n查看命令npm config list\n\n取消命令：npm config delete proxynpm config delete https-proxy\n\nPowerShell$env:HTTP_PROXY=&quot;http://127.0.0.1:10809&quot;","categories":["其它"]},{"title":"关于 GIt、GitHub和GitLab","url":"/2021/11/22/%E5%85%B6%E5%AE%83/%E5%85%B3%E4%BA%8E%20GIt%E3%80%81GitHub%E5%92%8CGitLab/","content":"这是我用GitHub仓库搭建主页和博客网站而学的git，git可以干很多事情，但是这里我只写关于github+git相关的事情，因为git可以干的事情实在太多了。\nGit 是一个版本控制系统。\n版本控制是一种用于记录一个或多个文件内容变化，方便我们查阅特定版本修订情况的系统。\n以前在没有使用版本控制的时候，我们通常在我们的项目根目录下这样命名项目：\nproject_v1、project_v1.1、project_v2等等，通过这种方式记录我们项目的不同版本的修改，\n有的时候我们还会在不同版本的文件中写一个说明，记录此版本项目新增、修改，删除等操作。\n这样的操作是很繁杂的，有的时候还可能因为一些非人为因素导致文件丢失这样的事故。\n有了版本控制系统，我们就不用再手动进行一些繁杂的操作，并且对于文件丢失这种事故我们也不\n用再担心，你可以随便回到历史记录的某个时刻。\n版本控制系统\n早期出现的版本控制系统有：SVN、CVS等，它们是集中式版本控制系统，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同合作的开发人员都通过客户端连接到这台服务器，取出最新的文件或者提交更新。\n而我们的主角 Git 是分布式版本控制系统。Git 已经成为越来越多开发者的青睐，因为分布式的优势是很显著的。\n集中式和分布式版本控制系统的区别\n集中式版本控制系统，版本库是集中存放在中央服务器的，工作的时候，用的是自己的电脑，所以，我们首先需要从中央服务器上拉取最新的版本，然后开始工作，等工作完了，再把自己的工作提交到中央服务器。在这里借用廖雪峰老师的一个比喻，中央服务器好比是一个图书馆，你要改其中的一本书，必须先要从图书馆里把书借出来，然后更改，改完之后，再放回图书馆。\n集中式版本控制系统的一个最大毛病就是必须联网才能工作，所以对于网络环境比较差的情况使用集中式版本控制系统是一件比较让人头疼的事情。\n分布式版本控制系统没有中央服务器的概念，我们使用相关的客户端提取的不只是最新的文件，而是把代码仓库完整地镜像下来，相当于每个人的电脑都是一个完整的版本库，这样的话，任何一处协同工作的服务器出现故障，都可以\n用任何一个镜像出来的本地仓库恢复。并且，即便在网络环境比较差的情况下也不用担心，因为版本库就在本地电脑上。\nGitHub和GitLab区别\n3.GitHub 和  GitLab 都是基于 web 的 Git 仓库，使用起来二者差不多，它们都提供了分享开源项目的平台，\n为开发团队提供了存储、分享、发布和合作开发项目的中心化云存储的场所。\nGitHub 作为开源代码库，拥有超过 900 万的开发者用户，目前仍然是最火的开源项目托管平台，GitHub 同时提供公共仓库和私有仓库，但如果使用私有仓库，是需要付费的。\nGitLab 解决了这个问题，你可以在上面创建私人的免费仓库。\nGitLab 让开发团队对他们的代码仓库拥有更多的控制，相比较 GitHub , 它有不少特色：\n(1) 允许免费设置仓库权限；\n(2) 允许用户选择分享一个 project 的部分代码；\n(3) 允许用户设置 project 的获取权限，进一步提升安全性；\n(4) 可以设置获取到团队整体的改进进度；\n(5) 通过 innersourcing 让不在权限范围内的人访问不到该资源；\n所以，从代码的私有性上来看，GitLab 是一个更好的选择。但是对于开源项目而言，GitHub 依然是代码托管的首选。\n常用的git指令\n初始化git\ngit init #文件中会多出一个.git 文件夹（可能会隐藏）\n\ngit add README.md\ngit commit -m &quot;first commit&quot; #版本的说明\ngit remote add [命名] [仓库地址] #添加远程仓库\ngit push -u [命名] master #本地的master分支推送到(命名)主机\n版本备份\n运行git add . 命令 #上传本地所有文件\n\ngit commit -m &quot;first commit&quot; #版本的说明\n部署到GitHub仓库/推送分支\ngit push #上传到github仓库\n查看&amp;备份版本\ngit log #查看备份版本\n\ngit status #查看修改文件\ngit reset –hard 版本序列号 #恢复某个版本的文件\n删除远程分支\ngit push origin :master #删除master分支\n\ngit push origin –delete master 删除master分支(前后两者意义相同)\n下载GitHub仓库源码/拉取分支\ngit pull [命名] [仓库地址]:[本地分支] #获取GitHub源码并和本地源码合并\n链接\ngui-指南 ","categories":["WebFrontend"],"tags":["git","github","gitlab"]},{"url":"/2023/04/18/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E5%A4%87%E5%BF%98%E5%BD%95/","content":"我好像一直在等你，又好像一直在忘记你参考：(43条消息) time、deltaTime、fixedTime、fixedDeltatime的区别_qq_39887964的博客-CSDN博客_deltatime和fixeddeltatime\ndeltaTlme代表两帧之间的间隔时间\n应该是fixedDeltaTime\n资源网站推荐一些不错的Unity游戏开发素材资源 - 知乎 (zhihu.com)\n收藏必看！Unity游戏开发素材资源合集 - 知乎 (zhihu.com)\nUnity里一般用Shader来做，常用的有ShaderGraph和AES\nTime.timeScale &#x3D; 0f;\t&#x2F;&#x2F;游戏暂停函数\n快捷键V 网格吸附\n选中main camera按下 ctrl+shfit+f 变成当前场景的角度坐标\n编程方法using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.Events;[System.Serializable]public class EventVector3 : UnityEvent&lt;Vector3&gt;&#123; &#125;public class MouseManager : MonoBehaviour&#123;    public EventVector3 OnMouseClicked;&#125;\n\n得到了用序列化存储的解决办法，在类前写上 [System.Serializable]就解决了问题，下面介绍一下 序列化的作用。\n序列化是指将对象实例的状态存储到存储媒体的过程。在此过程中，先将对象的公共字段和私有字段以及类的名称（包括类所在的程序集）转换为字节流，然后再把字节流写入数据流。在随后对对象进行反序列化时，将创建出与原对象完全相同的副本。\n跳跃代码3Dif (Input.GetKeyDown(KeyCode.Space))        &#123;            GetComponent&lt;Rigidbody&gt;().AddForce(Vector3.up * 5, ForceMode.VelocityChange);        &#125;\n\nUpdate中检查按键和输入 然后在FixedUpdate中施加力量\n是否启用组件disColl.enabled = false;\n\n获得layercoll.IsTouchingLayers(ground))\n\n\n\n\n\n命名规则术语Z-Fighting（深度缓冲）模型太近冲突\nAsyncOperation异步操作\n*** Prefabs 预制件 **\n预制游戏的对象 \n编辑器*编辑器有很多类：编辑器类。例如：EditorGUI（编辑器界面）,*EditorGUILayout（编辑器界面布局）,**EditorGUIUtility（编辑器界面工具）等等这些，都是编辑器对界面进行编辑。****\nInspector面板\n变量MoveToTarget 移动到目标\nMonoBehaviour 单体行为\nProject 项目Assets Pack包文件夹（用来存放游戏资源）\nMaterials（材料）\nPrefabs(预制体)\nScripts (存放脚本文件)\n\ncursor 光标\n\nPhysic Material(物理材料)\nEnvironment场景文件夹-Hierarchy\n— Character — 不成为他的子集\nPlugins&amp;Addons 存放package插件类型\nMaterials 存放材质文件夹\nManager 代理mouse manager 鼠标管理器\nCharacters 控制器\npalyer controller人物的控制器\n\nenemy  controller 敌人的控制器\n\n\n名称FloorTile(地板)\nUnity项目目录架构和命名规则文件夹命名规则参考Special folder names和Special Folders and Script Compilation Order\nAssets主文件夹，包含所有工程需要用到的资源。\nEditor所有在Editor和它的子文件夹的脚本，都不会作为运行期脚本被编译，而是作为动态添加Unity编译器功能的脚本来编译。在该文件夹和其子文件夹的脚本不能被添加到GameObject上。Editor文件夹可以被放置在Standard Assets Pro Standard Assets Plugins的任意一个子文件夹下。\nEditor default resources必须作为Assets的子文件夹，作为Editor脚本的资源使用，使用方式是通过函数EditorGUIUtility.Load来使用。\nGizmos场景面板中的图标图片资源，使用Gizmos.DrawIcon函数在场景面板新建图标，图标的图片资源必须位于这个文件夹内。(比如Unity的各种插件)\nPlugins所有的插件资源，包括用C&#x2F;C++编写的Dll库。\nResources一般用来存放需要通过代码初始化&#x2F;使用的资源，可以放在工程中的任意文件夹中，在Resources文件夹中的文件可以通过Resources.Load来读取，像下面这样。\nrend.material.mainTexture = Resources.Load(&quot;glass&quot;) as Texture;GameObject instance = Instantiate(Resources.Load(&quot;enemy&quot;, typeof(GameObject))) as GameObject;\n\nStandard Assets导入标准材质包时新建的，拥有自己的编译顺序。\nStreamingAssets通过Application.streamingAssetsPath获取目录路径，该目录中的文件将会原封不动的被拷贝到不同的平台上，每个平台对应的目录不一致，但是都可以通过上述方法获得。一般用来存放视频等资源文件。\nWebPlayerTemplates存放网页相关文件。\n隐藏文件一般用来存放README以及一些操作系统生成的临时文件，这些文件&#x2F;文件夹一般以. ~ 或者名为cvs或者扩展名是tmp。\n文件夹编译顺序在Assents中的脚本会按照以下顺序编译。\n\nStandard Assets Pro Standard Assets Plugins中的运行期脚本(包括MonoBehaviour和ScriptableObject等)。\n工程目录中的各种Editor文件夹中的Editor脚本。\nEditor文件夹之外的其他脚本(非运行期脚本)。\nEditor文件夹之内的其他脚本(非Editor脚本)。\n\n\n编译顺序在后面的脚本不可以被编译顺序在前面的脚本引用。\n\n工程文件目录架构可以如下图设置文件目录\n其中GameAssets为美术人员维护，美术人员使用Unity新建简单的空白工程，里面只有GameAssets的资源文件夹，这样每次制作完都可以Export UnityPockage，将其打包成UnityPackage给开发人员导入，好处是可以单独工程编辑，每次需要导入新的资源只要Import美术给的UnityPackage。\n\n"},{"title":"刷步日志","url":"/2022/04/21/%E5%85%B6%E5%AE%83/%E5%88%B7%E6%AD%A5%E6%97%A5%E5%BF%97/","content":"关于这篇文章...说来话长，我在学校刷跑步然后被老师抓到了，不是数据不准确是我每天在学校跑不跑步老师看的出来，老师让我写这玩意进行反思..，文章也就是随便写写的= =\n废弃方案\n废弃方案原因：此方法不适用悦跑圈，悦跑圈有后台运动记录，是不可以进行数据修改进行同步（因运动软件同步漏洞，悦跑圈关闭了所有软件同步功能）的方法修改步数的！！！\n1.   用刷步网站进行刷步（所有客户端通用）\n操作方法： \n刷步数网站：\n免费在线刷步数 - 支持QQ、微信、支付宝、钉钉运动,轻松上榜改 (nanjin1937.com)\n\n蚂蚁宝盒(vip.dmohe.com) - 在线刷步数（乐心健康刷步）\n【运动助手】 免费在线刷步数 (shuabu.net)\n刷步数-QQ运动、微信运动刷步神器-无需越狱root插件-爱刷步官网 (ishuabu.com)\nQQ微信支付宝刷步数 - Macro's Blog (ncii.cn)\n打开在线刷步数的网站，输入你的手机号码与刚才你设置的登陆密码。\n登陆成功之后，点击最下面的提交步数，就可以正常提交了。\n原理：\n微信、支付宝和QQ运动步数的来源有两种，要么是来自你手机自带的步数统计数据，要么来自于第三方的运动手环跑步的数据。\n因此，我们刷步数的原理就是利用手环数据上传的漏洞，来虚假上传数据，从而达到刷步数的目的。\n\n\n2.   接口工具修改微信/支付宝运动步数（仅支持windows）\n准备工作：\n1.手机下载小米运动APP\n2.电脑安装修改运动步数软件（仅支持windows）\n电脑修改运动步数软件下载：\nWechat_mi.exe：https://wwi.lanzoui.com/i1Smzskikja\n\n3.   运动软件同步数据刷步\n通过乐心健康APP，我们是可以对包括微信、支付宝、QQ等在内的运动数据进行同步修改，只需进行一些简单的设置，就可以随意的修改这些平台中运动步数。\n原理：\n微信、支付宝、QQ这些产品的步数数据可以来自于第三方跑步计数类的软件。因此，我们的方法就是，将我们的数据上传给第三方的APP，再由第三方APP将数据传给微信、支付宝或者QQ。\n操作方法：\n1、 使用浏览器打开链接：https://vip.dmohe.com/login.php\n2、 输入你乐心健康APP登录的手机号码和验证码(验证码需要打开乐心健康APP&gt; 退出登录&gt; 重新登录&gt; 获取验证码。三分钟内获得的验证码可以多次重复使用。)\n3、 绑定成功之后，就可以操作改步数了。\n使用的方案（经过测试）\n使用虚拟GPS定位刷步\n因为悦跑圈有运动记录，所以不能通过如上等方式进行数据修改，这个困难困扰了我一整天，但功夫不负有心人，在苦想之下，我又研究了如下几种方法。\n4.   使用vmware虚拟机（安卓）\n原理：\n运动软件检测运动靠的是手机的GPS定位模块，只要模拟出GPS运动就能到达修改步数的目的，但由于控制GPS定位模块属于超级用户权限，一般用户无法更改，更改只能通过root刷机取得权限，Android版本7.1及以下使用SuperSU来ROOT手机，Android版本8.0及以上使用Magisk来ROOT手机，但是现在系统普遍高于10版本以上，为了版本兼容性和手机的安全性推荐使用vmware虚拟机进行刷步。 \n专业术语讲解：\n什么是root：ROOT手机是指通过人为操作，通常是将zip文件卡刷进手机系统底层，来获取手机唯一最高的ROOT权限。ROOT手机成功后，可以使用ROOT权限更改硬件、卸载厂商预装软件、进行手机系统操作。缺点是厂商不保修，干扰手机系统正常运行。\n什么是GPS： GPS模块是一种集成在主板上的无线射频芯片模块，可以和美国的全球卫星定位系统（GPS）进行通信，可以在不消耗流量的情况下进行定位和导航，GPS芯片的制造商已经向GPS系统的运营商签订了协议，所有搭载GPS模块的设备都可以在任何时段、任何地区、免费地GPS同步卫星进行通讯。\nGPS模块本身只是提供定位和追踪的功能，说白了，GPS模块本身只是提供一个坐标，也就是经度和纬度，当你拿着内置GPS模块的设备移动时，这个坐标也会跟着变化。\n软件下载：\n健康运动app_懒人秘籍之悦跑圈篇 (lanzouq.com)  密码：wrxinyue\n悦跑圈app下载安卓-悦跑圈app下载安卓最新版-地图窝下载 (onegreen.net)\n\n操作方法：\n悦跑圈/自动跑步教程（Android版）全跑步软件通用_哔哩哔哩_bilibili \n\n\n5.   使用Android**模拟器（PC）**\n什么是Android模拟器：\nAndroid模拟器是一种软件，它可以使一个计算机设备像Android手机一样工作。Android模拟器可以在Windows或在Mac上安装并支持移动应用程序，而Android中的应用程序则内置在仿真器中。\n原理：\nAndroid模拟器和vmware虚拟机没什么区别，甚至电脑也可以通过VMware软件安装Androi镜像系统进行root，但是这个完全是非常麻烦的一个过程，所以我使用Android模拟器内置的虚拟GPS定位模块进行跑步作弊。\n方法：\n首先下载一个Android模拟器这里我推荐逍遥安卓模拟器，经过测试逍遥模拟器和悦跑圈软件有很好的兼容性。\n前置下载（链接）：\n【逍遥安卓模拟器】逍遥安卓模拟器下载官网 (xyaz.cn)\n悦跑圈app下载安卓-悦跑圈app下载安卓最新版-地图窝下载 (onegreen.net)\n按键精灵 (myanjian.com)\n教程：\n悦跑圈/自动跑步教程（PC版）全跑步软件通用_哔哩哔哩_bilibili","categories":["玩机"]},{"title":"快捷键大全","url":"/2023/04/19/%E5%85%B6%E5%AE%83/%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%A7%E5%85%A8/","content":"Ctrl+N打开新窗口。Ctrl+T打开新标签页。Ctrl+Shift+N在隐身模式下打开新窗口。按&nbsp;Ctrl+O，然后选择文件。在谷歌浏览器中打开计算机中的文件。按住&nbsp;Ctrl&nbsp;键的同时点击链接。或用鼠标中键（或鼠标滚轮）点击链接。从后台在新标签页中打开链接。按住&nbsp;Ctrl+Shift&nbsp;的同时点击链接。或按住Shift&nbsp;键的同时用鼠标中键（或鼠标滚轮）点击链接。在新标签页中打开链接并切换到刚打开的标签页。按住&nbsp;Shift&nbsp;键的同时点击链接。在新窗口中打开链接。Ctrl+Shift+T重新打开上次关闭的标签页。谷歌浏览器可记住最近关闭的 10 个标签页。将链接拖到标签页中。在标签页中打开链接。将链接拖到标签栏的空白区域。在新标签页中打开链接。将标签页拖出标签栏。在新窗口中打开标签页。将标签页从标签栏拖到现有窗口中。在现有窗口中打开标签页。拖动标签页时按&nbsp;Esc&nbsp;键。将标签页恢复到原先的位置。Ctrl+1&nbsp;到&nbsp;Ctrl+8切换到标签栏中指定位置编号所对应的标签页。Ctrl+9切换到最后一个标签页。Ctrl+Tab&nbsp;或&nbsp;Ctrl+PgDown切换到下一个标签页。Ctrl+Shift+Tab&nbsp;或&nbsp;Ctrl+PgUp切换到上一个标签页。Alt+F4关闭当前窗口。Ctrl+W&nbsp;或&nbsp;Ctrl+F4关闭当前标签页或弹出窗口。用鼠标中键（或鼠标滚轮）点击标签页。关闭所点击的标签页。右键点击或者点击并按住浏览器工具栏中的“后退”或“前进”箭头。在新标签页中显示浏览历史记录。按&nbsp;Backspace&nbsp;键，或同时按&nbsp;Alt&nbsp;和向左箭头键。转到当前标签页的上一页浏览历史记录。按&nbsp;Shift+Backspace，或同时按&nbsp;Alt&nbsp;和向右箭头键。转到当前标签页的下一页浏览历史记录。按住&nbsp;Ctrl&nbsp;键的同时点击工具栏中的后退箭头、前进箭头或转到按钮。或用鼠标中键（或鼠标滚轮）点击任一按钮。从后台在新标签页中打开按钮所对应的目标网页。双击标签栏的空白区域。最大化或最小化窗口。Alt+Home在当前窗口打开主页。 \nalt Shift+Alt &nbsp;输入用户名和密码来回切换 \n \n谷歌浏览器功能快捷键 \n \nAlt+F打开“工具”菜单，用该菜单可自定义和控制谷歌浏览器中的设置。Ctrl+Shift+B打开和关闭书签栏。Ctrl+H打开“历史记录”页面。Ctrl+J打开“下载内容”页面。Shift+Esc打开任务管理器。&nbsp;&nbsp;Ctrl+Shift+J打开开发人员工具。Ctrl+Shift+Delete打开“清除浏览数据”对话框。&nbsp;&nbsp; \n \n地址栏快捷键 \n在地址栏中可使用以下快捷键： \n首先键入搜索引擎网址，然后在系统提示时按Tab&nbsp;键，键入搜索字词，再按&nbsp;Enter&nbsp;键。使用与网址相关联的搜索引擎进行搜索。Ctrl+Enter在地址栏的输入内容前后分别加上&nbsp;www.&nbsp;和.com，并打开得到的网址。键入网址，然后按&nbsp;Alt+Enter。在新标签页中打开网址。F6&nbsp;或&nbsp;Ctrl+L&nbsp;或&nbsp;Alt+D突出显示网址。Ctrl+K&nbsp;或&nbsp;Ctrl+E将“?”中输入“?”。在问号后键入搜索字词可用默认搜索引擎执行搜索。同时按&nbsp;Ctrl&nbsp;和向左箭头键。在地址栏中将光标移到上一个关键字词同时按&nbsp;Ctrl&nbsp;和向右箭头键。在地址栏中将光标移到下一个关键字词Ctrl+Backspace在地址栏中删除光标前的字词用键盘上的方向键从地址栏下拉菜单中选择一个条目，然后按&nbsp;Shift+Delete。从浏览历史记录中删除所选条目（如果可以）。用鼠标中键（或鼠标滚轮）点击地址栏下拉菜单中的一个条目。从后台在新标签页中打开该条目。显示地址栏下拉菜单时按&nbsp;Page Up&nbsp;或&nbsp;Page Down。选中下拉菜单中的第一个或最后一个条目。 \n \n网页快捷键 \n \nCtrl+P打印当前网页。Ctrl+S保存当前网页。F5&nbsp;或&nbsp;Ctrl+R重新载入当前网页。Esc停止载入当前网页。Ctrl+F打开查找栏。Ctrl+G&nbsp;或&nbsp;F3在查找栏中查找下一条与输入内容相匹配的内容。Ctrl+Shift+G、Shift+F3&nbsp;或&nbsp;Shift+Enter在查找栏中查找上一条与输入内容相匹配的内容。点击鼠标中键（或鼠标滚轮）。激活自动滚动模式。当您移动鼠标时，网页会根据鼠标的移动方向自动滚动。Ctrl+F5&nbsp;或&nbsp;Shift+F5重新载入当前网页，忽略缓存的内容。按住&nbsp;Alt&nbsp;键，然后点击链接。下载链接目标。Ctrl+U打开当前网页的源代码。将链接拖到书签栏中将链接保存为书签。Ctrl+D将当前网页保存为书签。Ctrl+Shift+D将所有打开的网页以书签的形式保存在新文件夹中。F11在全屏模式下打开网页。再按一次&nbsp;F11&nbsp;可退出全屏模式。Ctrl++，或者按住&nbsp;Ctrl&nbsp;键并且向上滚动鼠标滚轮。放大网页上的所有内容。Ctrl+-，或者按住&nbsp;Ctrl&nbsp;键并且向下滚动鼠标滚轮。缩小网页上的所有内容。Ctrl+0将网页上的所有内容都恢复到正常大小。空格键向下滚动网页。Home转至网页顶部。End转至网页底部。按住&nbsp;Shift&nbsp;键的同时滚动鼠标滚轮。在网页上横向滚动。 \n文本快捷键 \n \nCtrl+C将突出显示的内容复制到剪贴板中。Ctrl+V&nbsp;或&nbsp;Shift+Insert从剪贴板中粘贴内容。Ctrl+Shift+V从剪贴板中粘贴内容（不带格式）。Ctrl+X&nbsp;或&nbsp;Shift+Delete删除突出显示的内容并将其复制到剪贴板中。\n                \n        \n    ","categories":["其它"]},{"title":"时间管理","url":"/2023/04/18/%E5%85%B6%E5%AE%83/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/","content":"1.时间管理原则:\n\n赶时间，而非等时间: 时间利用最大化\n遵守对时间的承诺: 尊重自己，尊重他人\n时间碎片: 零存整取\n时间保护: 任务管理与日程安排，以时间块高效处理分类事务\n时间黑洞: 全身心投入，专注\n\n2.纪录时间，完成记事:\n\n实时纪录而非事后补录，提升时间的感知能力\n发觉失去的时间，用以分析与调整\n\n3.GTD (Getting Things Done)时间管理法:\n\n收集: 工具用于纪录，大脑用思考\n处理: 分类，避免信息碎片化的累积，可用“重要─紧急”四象限法处理\n管理: 睡前设定三件事，起床后执行\n执行: 坚决专注，一心移用，番茄钟工作法\n回顾: 哪里做不好，调整计划使其更有效率地被执行\n可一月回顾一次\n\nReferences比爾蓋茨 7個 時間管理 方法，找回失去的時間！以秒计算時間！- YouTube\n","categories":["其它"]},{"title":"时间空间复杂度分析","url":"/2022/11/23/%E7%AE%97%E6%B3%95&%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/","content":"时间复杂度「时间复杂度」(Time complexity)定性描述该算法的运行时间\n\n大O符号表示法(BigO))：\n\nT(n) &#x3D; O(f(n))表示一个算法的渐进时间复杂度，f(n)表示代码次数之和，O表示正比例关系\nfor (int i = 1; i &lt;= i;i++) &#123;    x++;&#125;\n\n因为循环次数为n，时间为n单位，所以算法的「时间复杂度」可以表示为：T (n) &#x3D; O(n)。\nO(n²)i总共需要n层循环，在每一次内层循环中，j 也会循环n次\nfor (int i = 1; i &lt;= n; i++) &#123;    for (int j = 1; j &lt;= n; j++) &#123;        x++;    &#125;&#125;\n\n\n\nO(n + n²)上面两个算法并和：\nfor (int i = 1; i &lt;= n; i++) &#123;    x++;&#125;for (int i = 1; i &lt;= n; i++) &#123;    for (int j = 1; j &lt;= n; j++) &#123;        x++;    &#125;&#125;\n\n整个算法复杂度就变为 O(n + n²)，在n无限大的情况下，可以简化为 O(n²)。\n常见的时间复杂度量级\n常数阶O(1)int x = 0;int y = 1;int temp = x;x = y;y = temp;\n\n对数阶O(logN)int i = 1;while(i &lt; n) &#123;    i = i * 2;&#125;\n\n线性阶O(n)for (int i = 1; i &lt;= n; i++) &#123;    x++;&#125;\n\n对数阶O(logN)int i = 1;while(i &lt; n) &#123;    i = i * 2;&#125;\n\n线性对数阶O(nlogN)for(int i = 0; i &lt;= n: i++) &#123;    int x = 1;    while(x &lt; n) &#123;        x = x * 2;    &#125;&#125;\n\n平方阶O(n²)for (int i = 1; i &lt;= n; i++) &#123;    for (int j = 1; j &lt;= n; j++) &#123;        x++;    &#125;&#125;\n\n立方阶O(n³)for(int i = 1; i &lt;= n; i++) &#123;    for (int j = 1; j &lt;= n; j++)&#123;        for(int k = 1; k &lt;= n; k++)&#123;            s++;        &#125;    &#125;&#125;\n\nK次方阶O(n^k)\nk次方阶就相当于在有k层for循环\n\n指数阶O(2^n)public int aFunc(int n) &#123;       if (n &lt;= 1) &#123;               return 1;   &#125; else &#123;               return aFunc(n - 1) + aFunc(n - 2);   &#125;&#125;\n\n阶乘O(n!)void nFacRuntimeFunc(int n) &#123;  for(int i=0; i&lt;n; i++) &#123;    nFacRuntimeFunc(n-1);  &#125;&#125;\n\n\n\n其他还有「平均时间复杂度」、「均摊时间复杂度」、「最坏时间复杂度」、「最好时间复杂度]……\n空间复杂度「空间复杂度」(Computational problem)表示一个算法完全执行所需要的存储空间大小\n常用的空间复杂度O(1)空间复杂度int x = 0;int y = 0;x++;y++;\n\n代码中的 i、j、m 所分配的空间都不随着处理数据量变化，因此它的空间复杂度 S(n) &#x3D; O(1)\n空间复杂度 O(n)int[] m = new int[n]for(i=1; i&lt;=n; ++i)&#123;   j = i;   j++;&#125;\n\n这段代码的空间复杂度主要看第一行即可，即 S(n) &#x3D; O(n)\n","categories":["算法"],"tags":["java","算法"]},{"title":"HRACK攻击原理解析","url":"/2022/08/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/HRACK%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/","content":"HRACK攻击(WPA1&#x2F;WP2)KRACKs（Key Reinstallation AttaCKs）是一系列WPA2 (Wi-Fi  Protected Access 2 )协定漏洞的总称\n四向交握(4-WAY HANDSHAKE)\n第一步(Msg1)，AP会发送一组初始化向量（ANonce）到客户端装置（STA）。\n第二步(Msg2)，STA接到ANonce，会产生一组PTK（Pairwise Transient  Key）和另一个初始化向量（SNonce）发送给AP，并且使用了名为MIC（Message Integrity Code）的验证码。\n第三步(Msg3)，AP收到SNonce后，也会导出一组PTK，并发送密钥GRK给STA。\n第四步(Msg4)，STA在安装本身PTK和GRK之后回复讯息（Ack）给AP。\n\n\n\n利用Wi-Fi握手协议漏洞，在四向交握中客户端没有收到AP的 讯息时，会要求讯息重传。\n当客户端收到AP发来的讯息(Msg3)后将会安装PTK和GTK，用 于加密正常的封包。但因为Msg3可能丢失或者被丢弃，AP没有 收到回应(Msg4)的话，AP将会重新传输Msg3。\n客户端每次收到Msg3都会重新安装加密key，从而重置nonce和 replay counters 。而攻击者可以收集和重新发送四向交握中的 Msg3强制重置nonce，从而成功攻击加密协议，解密客户端发 送的封包，截获敏感信息。\n\n\n防御方法\n总而言之，提供一个临时解决方案，更改路由器的默认用户名、密码和SSID，打开防火墙，关闭SSID广播，为自己的用户设置单独的SSID，彻底关闭DHCP。\n项目地址：\nhttps://github.com/vanhoefm/krackattacks-scripts\n","categories":["网络安全"],"tags":["hacker","hrack"]},{"title":"研究cgi-bin","url":"/2023/01/11/%E5%85%B6%E5%AE%83/%E7%A0%94%E7%A9%B6cgi-bin/","content":"What is CGI\nCGI虽然已经被业界主流淘汰，但是通过学习它可以加深WebServer通信、Http协议的深成认识，了解CGI之后就可以学习Servlet，我打算深入学习并打固基础。\n\n通用网关接口 (Common Gateway Interface，CGI), 是在1990年代早期创建的一个用来在Web服务器和应用程序之间传递信息的标准。\nCommonCGI是一种用于在Web服务器和其它应用程序之间传递信息的标准，具有较高的通用性。\nCGI程序可以是任意的可执行程序，例如Java、Perl、Python、Ruby和C&#x2F;C++等。理论上来说，所有支持标准输入和输出、支持获取环境变量的编程语言都能用来编写CGI程序。\nServlet、WSGI（Web Server Gateway Interface，Web 服务器网关接口）等都可以实现类似CGI的功能。\nCGI的通用性是一个显著特性，它可以用于各种编程语言，并且可以用来实现各种功能。\nGatewayCGI可以看作是一个软件网关或者协议翻译机，它负责在Web服务器和应用程序之间通信。通常情况下，Web服务器和应用程序使用的协议是不同的，因此CGI程序负责将Web服务器使用的HTTP协议翻译成应用程序能理解的协议，或者将应用程序使用的协议翻译成HTTP协议。\n\n（如上是来自于果冻虾仁大佬的图，图画的不错&#x2F;&#x2F;&#x2F;）\nCGI程序是一种在Web服务器上执行的可执行程序，它可以通过Web服务器处理用户的请求并返回动态生成的内容。Web服务器通常部署在后台服务器上，用于提供Web内容和服务，而后台服务器则是运行在后台的服务器，通常负责处理后台业务逻辑和数据处理。\n有一点要注意，就是CGI程序可以获得输入并返回输出，但是它们是通过特定的接口进行交互的，而不是直接从Web服务器中获得输入。关于CGI程序如何从Web服务器中获得输入的细节，可以在下一节中进一步了解。\nInterfaceCGI是一种接口协议，它定义了Web服务器和CGI程序之间的通信方式。CGI程序通常部署到Web服务器上，Web服务器会调用CGI程序来处理用户的请求并返回动态生成的内容。CGI协议描述了CGI程序是如何获取用户的输入，如何将输出返回给Web服务器，以及如何处理错误和异常情况。CGI协议并不直接描述报文内容的详细语义，而是描述了CGI程序与Web服务器之间的交互方式。\n网页请求与响应在进行网页浏览时，通常会通过URL（Uniform Resource Locator，统一资源定位器）是一种用于描述网络位置的字符串，包括了资源协议、主机名、端口号以及路径等信息。浏览器会根据URL中描述的信息向服务器发出HTTP请求，要求服务器返回网页文件。\n服务器收到请求后，会根据请求的URL和响应的规则，返回对应的网页文件。这个网页文件可能是一个静态的HTML文件，也可能是一个动态生成的文件，例如通过CGI程序生成的文件。\n在服务器返回网页文件后，浏览器会接收到服务器返回的网页文件，并根据文件内容来渲染显示网页。如果这个网页文件包含了图片、视频、音频等多媒体资源，浏览器还会根据文件内容，向服务器发出多个请求来获取这些资源。\n当浏览器接受到所有资源之后，将会网页渲染完成，并显示在屏幕上，用户就可以在浏览器中浏览这些网页。\n简单来说，在浏览网页时，浏览器通过URL请求网页文件，服务器返回网页文件，浏览器根据文件内容渲染显示页面，这就是浏览网页的一般流程。\nReferences\nRFC 3875: The Common Gateway Interface (CGI) Version 1.1\nThe Magic of cgi-bin\n万法归宗——CGI\n\n"},{"title":"wifi安全渗透","url":"/2022/08/28/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/wifi%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F/","content":"序章最近流量没了，穷的吃土，研究了一下WIFI无线安全写出相关文章希望大家能对认识网络安全提供帮助\n（文章仅用于学习交流，请勿违法！)\n\n破解方式wifi的破解方式很多，在上面的文章说了如果无线路由器开启了WPS就可以使用pin码进行破解，除了pin码破解还有社会工程学抓包跑字典等方式\npin码破解难度：⭐⭐\n时长：0~2小时，平均一小时\n条件：路由器WPS功能是否开启，路由器信号强度，路由器是否防PIN\n原理：WPS的pin码并没有加密。Reaver会暴力破解pin码，找到pin码也就找到了密码。\n环境要求：\n\n网卡支持数据包注入\n要求无线信号强\n\n注意事项：\n\n如果发送pin码过快，有可能造成路由器崩溃；就类似对服务器的DDOS攻击。\n此过程不能联网，虚拟器需要断开网络连接\nReaver有很多其他选项，查看帮助：reaver ?\n\n查看网卡\nairmon-ng\n\n\n上面命令列出了支持监控模式的无线网卡。一般是带wlan开头的，自带的网卡如eth0是不支持的，市面上90%笔记本网卡是不支持渗透测试的。\n开启监听模式\nairmon-ng start wlan0\n\n\n执行成功之后网卡接口变为wlan0mon；可以使用ifconfig命令查看。\n查询开启WPS功能的无线路由器\nwash -i wlan0mon -C\n\n如果什么也没有表示周围没有开启WPS的无线路由器。记住要破解wifi的BSSID。\n开始破解密码\nreaver -i wlan0mon -b C8:3A:35:30:3E:C8 -vv -a\n\n最后，不要忘了结束无线网卡的监控模式：\nairmon-ng stop wlan0mon\n\nCD Linux配合minidwep-gtk工具跑PIN破解WiFi和上一个pin码原理一样，只是这个CD Linux集成的工具跑起来更简单方便\n难度：⭐\n1.挂载网卡首先打开CD Linux并且将网卡挂载到CD Linux具体的操作步骤是：VM ware虚拟机-可移动设备-Realtek RTL8187 Wireless-连接（与主机断开连接）会弹出提示,探后点确定\n2.使用水滴2.1打开水滴CD Linux给我们提供了许多好用的软件，本次只使用水滴用作演示，感兴趣的可以自行了解。双击打开水滴（minidwep-gtk）\n请仔细阅读弹出对话框中的内容，然后点OK\n2.2扫描点完OK就进入到主界面，然后点击扫描\n程序会自动扫描附近的wifi，等个几十秒，所有扫描结果就展示出来了。\n2.3扫描结果\n这里面的wifi信号强度绝对值小的信号强，比如-50比-60信号强往下找，发现有带WPS的wifi\n2.4跑PIN选中一个带有WPS的wifi，点击Reaver，如果你不知道各个参数代表啥，直接在弹出的对话框中点击OK。\n这里有一篇关于Reaver参数设置的文章\nreaver使用相关\n在此期间程序会一个一个地尝试每一个PIN码，这个过程叫做“跑PIN”\n理想速率是5 seconds&#x2F;pin\n2.5结果功夫不负有心人，在尝试到15389664时，成功了！获取到了wifi的PIN码以及密码\n使用Aircrack破解wifi密码(wpa&#x2F;wpa2)难度：⭐⭐⭐\n这个方法同样不能联网，这种方式的原理是通过抓包，然后跑字典达到破解密码的目的，步骤相对繁琐，我有更方便的方式用airgeddon工具进行破解，有兴趣的小伙伴可以看一看，好了让我们继续\n查看网卡\nairmon-ng\n\n\n上面命令列出了支持监控模式的无线网卡。一般是带wlan开头的，自带的网卡如eth0是不支持的，市面上90%笔记本网卡是不支持渗透测试的。\n开启监听模式\nairmon-ng start wlan0\n\n\n执行成功之后网卡接口变为wlan0mon；可以使用ifconfig命令查看。\n查看wifi网络\nairodump-ng wlan0mon\n\n\n上面列出了周围的wifi和它们的详细信息，包括信号强度、加密类型、频道等。要记住要破解wifi的频道号和BSSID。\n按Ctrl-C结束。\n抓取握手包\n使用网卡的监听模式抓取周围的无线网络数据包。其中，对我们最重要的数据包是：包含密码的包－也叫握手包。当有新用户或断开用户自动连接wifi时，会发送握手包。\n开始抓包：\nairodump-ng -c 6 --bssid C8:3A:35:30:3E:C8 -w ~/ wlan0mon\n\n参数解释：\n-c指定频道号\n-bssid指定路由器bssid\n-w指定抓取的数据包保存位置\n\n强制连接到wifi的设备重新连接路由器\n现在我们只要等用户连接&#x2F;重连接wifi了，运气不好也许要很长时间。\n但是我们是不会等的，这不是耐心黑客该干的事。有一个叫aireplay-ng的工具，它可以强制用户断开wifi连接；原理是，给连接到wifi的一个设备发送一个deauth（反认证）包，让那个设备断开wifi，随后它自然会再次连接wifi。\naireplay-ng的生效前提是，wifi网络中至少有一个连接的设备。从上图可以看到哪些设备连接到了wifi，STATION就是连接设备的MAC地址，记住一个。\naircrack-ng官网\n打开新终端执行：\naireplay-ng -0 2 -a C8:3A:35:30:3E:C8 -c B8:E8:56:09:CC:9C wlan0mon\n\n参数解释：\n-0表示发起deauthentication攻击\n-a指定无线路由器BSSID\n-c指定强制断开的设备\n\n如果成功：\n\n按Ctrl-C结束抓包。\n我们已经得到了想要的握手包了，可以结束无线网卡的监控模式了：\nairmon-ng stop wlan0mon\n\n\n开始破解密码\naircrack-ng -a2 -b C8:3A:35:30:3E:C8 -w /usr/share/wordlists/rockyou.txt ~/*.cap\n\n参数解释：\n-a2代表WPA的握手包\n-b指定要破解的wifi BSSID。\n-w指定字典文件\n最后是抓取的包\n\n可选）使用显卡的运算能力\n如果你有一个强大的GPU，为什么不使用GPU跑字典呢？\nHashcat可以借助GPU的运算力破解各种不同算法的hash值。\n下载时要注意选择正确的显卡类型（AMD、NVidia）。Kali Linux自带这个工具。\n在破解cap文件之前，要把它转换为hccap文件：\n# aircrack-ng file.cap -J out.hccap\n使用GPU破解hash：\n# hashcat -m 2500 out.hccap 字典文件\n破解隐藏网络(隐藏SSID)难度：⭐\n\n查看方法：\nairodump-ng -c 6 --bssid C8:3A:35:30:3E:C8 wlan0monaireplay-ng -0 30 -a C8:3A:35:30:3E:C8 -c B8:E8:56:09:CC:9C wlan0mon\n\n参考无线网络的加密方式：WEP、WPA和WPA2\n使用Reaver破解开启了WPS功能的wifi密码(wpa&#x2F;wpa2)\n无线安全专题_破解篇02–kali破解pin\n无线局域网安全（一）———WEP加密\n从黑客角度来谈如何保护路由器-WPS破解方式（一）\n网络安全–跑PIN破解WiFi(详细教程)\nWPA3—SAE原理介绍\n什么是WPA3\n","categories":["网络安全"]},{"title":"路由器的加密算法","url":"/2022/08/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/","content":"路由器的加密算法目前路由器的加破解途径主要有三种，WEP破解、WPA&#x2F;WPA2、WPS\n\n有线等效加密WEP（pre-RSNA）WEP（Wired Equivalent Privacy）加密是最早在无线加密中使用的技术。\n因为WEP出现了非常严重的漏洞，所以Wi-Fi协会于2004年宣布WEP正式退役。\nWi-Fi保护设置WPA(TKIP)WPA采用TKIP协议（temporal key integrity protocol）作为加密协议。\nTKIP 是 WPA 的核心组件，设计初衷是全为对现有 WEP 设备进行固件升级。因此， WPA 必须重复利用 WEP 系统中的某些元素，最终也被黑客利用。\nWi-Fi保护设置ⅡWPA2(CCMP-AES)Wi-Fi Protected Access II (WPA2)。WPA 标准于2006年正式被 WPA2 取代。 WPA 和 WPA2 之间最显着的变化之一是强制使用 AES 算法和引入 CCMP （计数器模式密码块链消息完整码协议）替代 TKIP 。\n\nKRACK攻击（Key Reinstallation Attacks，密钥重装攻击）：WPA2在2017年被发现存在安全漏洞，采用WPA2进行加密的Wi-Fi网络可能会遭受KRACK攻击，攻击者利用这个漏洞诱导用户重新安装已使用过的密钥，并通过一系列手段破解用户密钥，从而实现用户网络的完全访问。\n离线字典或暴力破解攻击：WPA2采用的密钥复杂度和被破解的难度呈正相关，尤其是个人或者家庭Wi-Fi网络经常采用一个比较简单的密钥，这样的Wi-Fi网络很容遭受离线字典（根据用户自定义词典中可能的密码逐一尝试）或者暴力破解攻击（又称穷举法，逐一尝试所有可能组合的密码）轻松破解。\nWi-Fi 保护设置（ WPS ）的攻击向量。攻击带有WPS的WPA&#x2F;WPA2网络，现代计算机需要花费1至2小时持续攻击。防御方法：禁用 WPS。\n\nWi-Fi保护设置ⅢWPA3WPA3（Wi-Fi Protected Access 3，第三代Wi-Fi访问保护）是Wi-Fi联盟组织于2018年发布的新一代Wi-Fi（WiFi）加密协议，它对WPA2进行了改进，增加了许多新的功能，为用户和Wi-Fi网络之间的数据传输提供更加强大的加密保护\n2017年10月份，有安全研究者公布了WPA2协议的一个弱点，会遭受到KRACK（ Key Reinstallation AttaCK）攻击；攻击者可以获取STA和AP之间传输的数据，许多厂家已经发布相关补丁修复此漏洞；但是WPA2的形象和名声还是受到损害，因而WIFI联盟迅速推出了WPA3\n无线局域网鉴别和保密基础结构（WAPI）WAPI （WLAN Authentication and Privacy Infrastructure）。是国内自主研发的无线网络WLAN安全标准.\nWPA-PSK&#x2F;WPA2-PSK WPA和WPA2衍生出来的两种加密方式WPA-PSK和WPA2-PSK，他们之间的区别在于使用的加密算法。WPA-PSK和WPA2-PSK既可以使用TKIP加密算法也可以使用AES加密算法。\nWPA3对于个人和企业网络提供不同模式\n\nWPA3-SAE 个人网络\nWPA3-Enterprise 企业网络\n\nWPA3优势：\n\n加密一致性：通过强制执行同时使用“先进加密标准（Advanced Encryption Standard，简称AES）”和传统协议（例如“临时密钥完整性协议（Temporal Key Integrity Protocol，简称TKIP）”）的政策，降低了网络遭受攻击的可能性；\n网络弹性：通过启用受保护的管理帧（Protected Management Frames，简称PMF）机制，防止窃听和假冒管理帧的行为，提供了可靠的保护。一致地使用这类保护措施可提高关键任务型网络的弹性。\n\nWi-Fi保护设置（WPS）WPS（Wi-Fi Protected Setup）。旨在让家庭用户使用无线网络时简化加密步骤。此标准由Wi-Fi联盟（Wi-Fi Alliance）于2006年制定。\n作用：WPS的目的是简化用户输入密码的步骤；在某个设备连接wifi，需要输入密码时，只要按一下无线路由器上的wps按钮就可以了。\n漏洞：在2011年12月28日安全专家Stefan Viehbock报出此标准的一个重大安全漏洞，此漏洞允许远程攻击者使用暴力攻击在几小时内就能获取WPS的PIN码和WPA&#x2F;WPA2的PSK码。一些新出产的无线路默认启动WPS功能，所以现在建议用户关闭无线路由器上的WPS一键加密功能，有些无线器上无法关闭此功能。\n破解原理：当路由器开了WPS功能，支持PIN码进行连接的时候，它的PIN码在机器里面是用的一组序列号保存的，写在router里面，一般从一般可以从router的标签上可以看到，它是”external registrar”的验证模式，仅需路由器的PIN，此模式的设计存在问题允许对PIN进行暴力猜测攻击。\n无线网标准IEEE802.11标准\n\nIEEE802.11a，速率最高可达54Mbps\nIEEE802.11b，速率最高可达11Mbps\nIEEE802.11g，速率最高可达54Mbps\nIEEE802.11n，速率最高可达108Mbps\nIEEE802.11ac，速率最高可达600Mbps\n\n","categories":["网络安全"]},{"title":"MVC设计模式","url":"/2022/11/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F&%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/MVC%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","content":"MVC介绍MVC(Model-View-Controller)是一种软件开发架构模式，包含：Observer(观察者模式),Composite(组合模式)和Strategy(策略模式) \nMVC 模式的基本思想是数据，显示和处理相分离。模型(Model)负责数据管理，视图(View)负责数据显示，控制器(Controller)负责业务逻辑和响应策略。\n\n模型： 代表应用的业务层。   它是一个携带数据的对象，如果数据发生变化，它还可以包含更新控制器的逻辑。 \n视图： 它代表应用程序的表示层。   它用于可视化模型包含的数据。 \n控制器： 它适用于模型和视图。   它用于管理应用程序流，即模型对象中的数据流，并在数据更改时更新视图。\n\n在 Java 编程中，模型包含简单的 Java 类 ，用于显示数据的视图和包含 servlet的控制器。   由于这种分离，用户请求的处理如下： \n\n\n客户端（浏览器）向服务器端的控制器发送页面请求。 \n\n然后控制器调用模型。  它收集请求的数据。 \n\n然后控制器将检索到的数据传输到视图层。 \n\n现在结果由视图发送回浏览器（客户端）\n\n\n\nMVC架构把数据处理，程序输入输出控制及数据显示分离开来，并且描述了不同部件的对象间的通信方式。使得软件可维护性，可扩展性，灵活性以及封装性大大提高；\n视图表示数据在屏幕上的显示。控制器提供处理过程控制，它在模型和视图之间起连接作用。控制器本身不输出任何信息和做任何处理，它只负责把用户的请求转成针对Model的操作，和调用相应的视图来显示Model处理后的数据。\n为什么要在Web应用中使用MVC架构提高代码重用率提高程序的可维护性有利于团队开发Java简单实现MVC\nEmployee Class —— model\n\n//表示模型的类public class Employee &#123;    //声明变量    private String employeeName;    private String employeeId;    private String employeeDepartment;        //定义get和set方法    public String getEmployeeName() &#123;        return employeeName;    &#125;    public void setEmployeeName(String employeeName) &#123;        this.employeeName = employeeName;    &#125;    public String getEmployeeId() &#123;        return employeeId;    &#125;    public void setEmployeeId(String employeeId) &#123;        this.employeeId = employeeId;    &#125;    public String getEmployeeDepartment() &#123;        return employeeDepartment;    &#125;    public void setEmployeeDepartment(String employeeDepartment) &#123;        this.employeeDepartment = employeeDepartment;    &#125;&#125;\n\n\nEmployeeView Class —— view\n\n//表示视图的类 public class EmployeeView &#123;      //显示员工详细信息的方法    public void printEmployeeDetails(String employeeName,String employeeId,String employeeDepartment) &#123;        System.out.println(&quot;Employee Details：&quot;);        System.out.println(&quot;Name：&quot; + employeeName);        System.out.println(&quot;Employee ID：&quot; + employeeId);        System.out.println(&quot;Employee Department：&quot; + employeeDepartment);    &#125;&#125;\n\n\nEmployeeContoller Class —— controller\n\n//代表控制器的类public class EmployeeController &#123;    // 声明变量模型和视图      private Employee model;    private EmployeeView view;        // 要初始化的构造函数    public EmployeeController(Employee model,EmployeeView view) &#123;        this.model = model;        this.view = view;    &#125;        // getter 和 setter 方法    public void setEmployeeName(String name) &#123;        model.setEmployeeName(name);    &#125;        public String getEmployeeName() &#123;        return model.getEmployeeName();    &#125;        public void setEmployeeId(String id) &#123;        model.setEmployeeId(id);    &#125;        public String getEmployeeId() &#123;        return model.getEmployeeId();    &#125;        public void setEmployeeDepartment(String department) &#123;        model.setEmployeeDepartment(department);    &#125;        public String getEmployeeDepartment() &#123;        return model.getEmployeeDepartment();    &#125;        // 更新视图的方法    public void updateView() &#123;        view.printEmployeeDetails(getEmployeeName(), getEmployeeId(), getEmployeeDepartment());    &#125;&#125;\n\n\nMain方法\n\npublic class MVCMain &#123;    public static void main(String[] args) &#123;        // 根据 employee_id 从数据库中获取员工记录        Employee model = retriveEmployeeFromDatabase();        // 创建一个视图以在控制台上写入员工详细信息        EmployeeView view = new EmployeeView();        EmployeeController controller = new EmployeeController(model, view);        controller.updateView();                //更新模型数据        controller.setEmployeeName(&quot;XinYue&quot;);        System.out.println(&quot;\\n&quot; + &quot;Employee Details after updating: &quot;);        controller.updateView();    &#125;        private static Employee retriveEmployeeFromDatabase() &#123;        Employee employee = new Employee();        employee.setEmployeeName(&quot;NaiYaZi&quot;);        employee.setEmployeeId(&quot;7&quot;);        employee.setEmployeeDepartment(&quot;Salesforce&quot;);        return employee;    &#125;&#125;\n\n\n输出：\n\nEmployee Details：Name：NaiYaZiEmployee ID：7Employee Department：SalesforceEmployee Details after updating: Employee Details：Name：XinYueEmployee ID：7Employee Department：Salesforce\n\n","categories":["其他"],"tags":["java","架构模式"]},{"title":"C#学前入门","url":"/2022/07/22/WebBackend/C#/1.C#%E5%AD%A6%E5%89%8D%E5%85%A5%E9%97%A8/","content":"2. C#编程概述一个简单的C#程序，这段程序会输出“Hi there！”\n//告诉编译器这个程序使用了System命名空间的类型using System;//声明一个新命名空间，名称为Simplenamespace Simple&#123;    class Program&#123;        static void Main()&#123;            Console.WriteLine(&quot;Hi there!&quot;)        &#125;    &#125;&#125;Copy\n\n在C#中，WirteLine相当于java中的println，Write相当于java中的print\nConsole.WriteLine(&quot;Three integers are &#123;1&#125;, &#123;0&#125; and &#123;1&#125;.&quot;, 3, 6);Copy\n\n以上语句将在屏幕上显示：Three integers are 6, 3 and 6.\n类型存储和变量命名空间是一种把相关的类型声明分组并命名的方法。既然程序是一组相关的类型声明，那么通常会把程序声明在你创建的命名空间内部。\n预定义类型C#提供了16种预定义类型，包括13种简单类型和3种非简单类型\n简单类型：| 名称 | 含义 || ———– | ———– || int | 32位有符号整数 || uint | 32位无符号整数 || long | 64位有符号整数 || ulong | 62位无符号整数 || short | 16位有符号整数 || ushort | 16位无符号整数 || byte | 8位有符号整数 || sbyte | 8位无符号整数 || float | 单精度浮点数 || double | 双精度浮点数 ||decimal|高精度小数类型|| bool | 布尔型 || char | Unicode字符串 |\n非简单类型：\n\nobject：所有其他类的基类\nstring：多个Unicode字符组成的序列\ndynamic：在使用动态语言编写的程序集时使用\n\nC#语言是静态的，但基于.NET的一些其他语言却是动态的，也就是说变量的类型直到运行时才会被解析。由于它们是.NET语言，所以C#程序需要使用这些语言编写的程序集。问题是程序集中的类型直到运行时才会被解析，而C#又要引用这样的类型并且需要在编译的时候解析类型。为了解决这个问题，有了dynamic关键字。\n在编译时，编译器不会对dynamic类型的变量进行类型检查。相反，它将与该变量及该变量的操作有关的所有信息打包。在运行时会对这些信息进行检查，以确保它与变量所代表的实际类型保持一致性，否则将在运行时抛出异常。\n用户定义类型C#中有6种用户自定义类型\n\n类类型class\n结构类型struct\n数组类型array\n枚举类型enum\n委托类型delegate\n接口类型interface\n\n3. 方法类型推断和var关键字var关键字不是特定类型变量的符号，它是从等号右边推断出的实际类型的速记。\n//在下面的第一个声明中，var是int的速记//第二个声明中，var是MyExcellentClass的速记static void Main()&#123;    var total = 15;      var mec = new MyExcellentClass();&#125;Copy\n\n使用var关键字有一些重要的条件：\n\n只能用于本地变量，不能用于字段\n只能在变量声明中包含初始化的时候使用\n一旦编译器推断出变量的类型，它就是固定且不能更改的\n\n本地常量用const修饰符来修饰（类似于java中的final）\n常量和变量的语法除了以下两点外都相同：\n\n常量在类型之前增加关键字const\n常量必须有初始化语句，也就是说初始值不能在编译期确定。因此，它不能是某个对象的引用（但可以是null的引用），因为对象的引用是在运行时决定的。\n\n参数首先区分下形参和实参的概念：\n//以下函数的参数声明中，x和y均为形参public void PrintSum(int x, float y)&#123;&#125;Copy//以下函数的调用中，5和someInt均为实参,实参的值用于初始化形参PrintSum(5, someInt)&#123;&#125;Copy\n\n1.值参数Java中的参数传递类型（值传递），即：值参数是把实参的值复制给形参，二者在栈中的不同位置。\n\n在方法被调用前，用作实参的变量a2已经在栈中了\n在方法开始时，系统在栈中为形参分配空间，并从实参复制值\n因为a1是引用类型，所以a1的值（即指向对象的地址）被复制，形参和实参都指向堆中的同一个对象\n因为a2是值类型的，所以值被复制，产生了一个独立的数据项\n\n\n在方法中，f2和对象f1的字段都被加上了5\n方法结束后，形参从栈中弹出\n\n\n值参数\n2.引用参数对于引用参数，系统不会在栈中为形参分配新的空间，形参的参数名将作为实参的别名，指向相同的内存位置\n\n使用引用参数时，必须在方法的声明和调用中都使用ref修饰符\n实参必须是变量，在用作实参前必须被赋值\n\n//方法声明中要使用ref修饰符void MyMethod(ref int val)&#123;&#125;int y = 1;MyMethod(ref y)   //使用y前必须赋值MyMethod(ref 3 + 5)   //会报错，因为引用参数作为实参必须是变量，不能是表达式Copy\n\n\n在方法调用前，将要被用作实参的变量a1和a2已经在栈里了\n在方法的开始，形参名被设置为实参的别名。引用相同的内存位置\n在方法结束后，f2和f1的对象的字段都被加上了5\n\n\n引用参数\n对比将引用类型对象作为值参数和引用参数传递的两种情况：\n\n将引用类型对象作为值参数传递：如果在方法内创建一个对象并赋值给形参，将切断形参和实参之间的关联，并且在方法调用结束后，新对象将不复存在\n将引用类型对象作为引用参数传递：如果在方法内创建一个新对象并赋值给形参，会让实参也引用该新对象，并且在方法结束后该对象仍然存在。\n\n3.输出参数输出参数用于从方法体内把数据传出到调用代码，修饰符为out。和引用参数非常类似\n和引用参数一样，输出参数的形参担当实参的别名，方法内对形参的任何改变在方法完成后通过实参变量都是可见的。\n唯一和引用参数不同的是：方法内的代码在读取输出参数之前必须先对其写入\npublic void Add(out int outValue)&#123;    //以下这句会报错，因为输出参数outValue在方法中被读取前没有被赋值    int var1 = outValue + 2;&#125;Copy\n\n4.参数数组参数数组允许0个或多个实参对应一个特殊的形参,修饰符为params\n//形参inVals可以代表0个或多个实参void ListInts(params int[] inVals)&#123;&#125;Copy\n\n\n在参数列表中只能有一个参数数组，并且是列表中的最后一个\n由参数数组表示的所有参数必须具有相同的类型\n\n参数数组在方法声明中需要params修饰符，而在调用时不需要（不同于引用参数和输出参数，它们在以上两个地方都需要修饰符）\n可以有如下两种方式为参数数组提供实参：\n\n用一个逗号分隔的该数据类型元素的列表,使用这种方法时，编译器做如下的事：\n\n接收实参列表，用它们在堆中创建并初始化一个数组\n\n把数组的引用作为形参保存在栈中\nListInts(10, 20, 30)Copy\n\n\n用数组作为实参\n在这种情况下，编译器会直接使用传入的数组，也就是说栈中的形参指向内存中intArray的位置\nint[] intArray = &#123;1, 2, 3&#125;;ListInts(intArray);Copy\n\n5.命名参数在使用命名参数时，需要在方法调用中包含参数名。而方法的声明无需任何改变\nclass MyClass&#123;    //方法中的参数声明一如平常    public int Calc(int a, int b, int c)&#123;        return a + b + c;    &#125;    static void Main()&#123;        MyClass mc = new MyClass();        int result = mc.Calc(c: 2, a: 4, b: 3);    &#125;&#125;Copy\n\n6.可选参数所谓可选参数就是在调用方法的时候可以包含这个参数，也可以忽略它。\nclass MyClass&#123;    //b为可选参数，默认值为3    public int Calc(int a, int b = 3)&#123;        return a + b;    &#125;    static void Main()&#123;        MyClass mc = new MyClass();        int ro = mc.Calc(5, 6);        int r1 = mc.Calc(5);        Console.WriteLine(&quot;&#123;0&#125;, &#123;1&#125;&quot;, ro, r1);    &#125;&#125;Copy\n\n上述代码会输出11，8\n\n\n只要值类型的默认值在编译的时候可以确定，就可以使用值参数作为可选参数。而只有在默认值为null的时候，引用参数才可以作为可选参数。\n总结下来，一个方法的声明中，参数要按照必填参数、可选参数、params参数的先后顺序声明。\n可以忽略最后一个可选参数，或者最后n个可选参数，但是不可以随机选择省略任意的可选参数，省略必须从最后开始。\n参数类型总结：\n\n\n\n参数类型\n修饰符\n是否在声明时使用\n是否在调用是使用\n执行\n\n\n\n值参数\n无\n\n\n系统把实参的值复制给形参，二者在栈中位置不同\n\n\n引用参数\nref\n是\n是\n形参是实参的别名，二者在栈中位置相同\n\n\n输出参数\nout\n是\n是\n在读取输出参数前必须对其写入，除此之外和引用参数类似\n\n\n参数数组\nparams\n是\n否\n允许传递可变数目的实参到方法\n\n\n栈帧在调用方法的时候，内存从栈的顶部开始分配，保存和方法关联的一些数据项。这块内存叫做方法的栈帧\n栈帧保存如下的内容：\n\n返回地址\n\n为参数分配的内存\n\n各种和方法调用相关的其他管理数据项\n在方法调用的时候，整个栈帧都会压入栈。在方法退出的时候，整个栈帧都会从栈上弹出。\n\n\n\n栈帧\n4.类类成员包括数据成员（保存数据）和函数成员（执行代码）其中数据成员包括：\n\n字段\n常量（用const修饰，包括本地常量和成员常量，本地常量声明在方法内，成员常量声明在类中）\n\n常量成员常量表现的和静态量相似，但唯一不同的是，成员常量没有自己的存储位置，而是在编译时被编译器替换。此外，不能将成员常量声明为static。与const有着相同作用的是readonly，不同的是，const字段只能在字段的声明语句中初始化，而readonly也可以在构造函数中初始化。因此const字段的值必须在编译时确定，而randonly字段的值可以在运行时决定。\n函数成员包括：\n\n方法\n属性\n构造函数、析构函数\n运算符\n索引\n事件\n\n数据基本运算\n算数运算符 ： 对数字做算数运算\nint n1 =29，n2 = 2;int r1 = n1 / n2; //5 /2 ==&gt; 2.5 截断删除 2int r2 = n1 %n2；//取模（余数）\n\n比较运算符 &gt;     &lt;     &gt;&#x3D;     &lt;&#x3D;     等于&#x3D;&#x3D;     不等于!&#x3D;\n\n逻辑运算符 &amp;&amp;      ||     ！\n\n快捷运算符 +&#x3D;     *&#x3D; \n\n一元运算符      ++     –\nint number03 = 1;Console.WriteLine(number03++) //结果：自增以前int number04 = 1；Console.WriteLine(++number04); //结果，自增以后的\n\n三元   数据类型 变量名 &#x3D; 条件 ？ 结果：结果\nstring 1&gt;2?&quot;ok&quot;:&quot;no&quot;float r11 = 1 == 1? 1.2f :1.5f;\n\n优先级\nint r12 = 1 + 2 * 4;int r12 = (1 + 2) * 4;\n\n\n\n数据类型转换\nint number = 18;string str = number.ToString();\n\n属性属性是一组称为访问器的方法（set访问器为属性赋值，get访问器从属性中获取值）。它是类中的函数成员，因此不需为属性分配内存。\n写入和读取属性的代码和访问字段一样。属性会根据是写入还是读取，来隐式地调用适当的访问器\n属性通常和字段关联，一种常见的方式是在类中将字段声明为private以封装字段，并声明一个public属性用get和set访问器来控制对该字段的访问。和属性关联的字段成为后备字段\nclass C1&#123;    private int TheRealValue = 10;   //后备字段：分配内存    public int MyValue&#123;              //属性：不分配内存        set&#123;            TheRealValue = value;    //设置字段的值        &#125;         get&#123;            return TheRealValue;     //获取字段的值        &#125;    &#125;&#125;class Program&#123;    static void Main()&#123;        //对属性的读和写如同对字段的读和写        C1 c = new C1();        Console.WriteLine(&quot;MyValue: &#123;0&#125;&quot;, c.MyValue);        c.MyValue = 20;        Console.WriteLine(&quot;MyValue: &#123;0&#125;&quot;, c.MyValue);    &#125;&#125;Copy\n\n此外，属性也可以只有get访问器（只读属性），或者只有set访问器（只写属性）\nclass RightTriangle&#123;    public double A = 3;    public double B = 4;    //只读属性，计算直角三角形的第三边    public double Hypotenuse&#123;        get&#123;            return Math.Sqrt((A * A) + (B * B));        &#125;    &#125;&#125;class Program&#123;    static void Main()&#123;        RightTriangle c = new RightTriangle();        Console.WriteLine(&quot;Hypotenuse: &#123;0&#125;&quot;, c.Hypotenuse);    &#125;&#125;上述代码将输出5Copy\n\n索引器可以认为索引器是为类的多个数据成员提供get和set访问器的属性。\nclass Class1&#123;    private int Temp0;    private int Temp1;    //和属性不同的是，索引器有参数（索引参数），并且使用this而不是名称    //索引器声明    public int this [int index]&#123;            get&#123;            return (index == 0) ? Temp0 : Temp1;        &#125;        set&#123;            if(index == 0)                Temp0 = value;   //value为set访问器的隐式变量            else                Temp1 = value;        &#125;    &#125;&#125;class Example&#123;    static void Main()&#123;        Class1 a = new Class1();        //使用索引参数0或1读取数据成员        Console.WriteLine(&quot;T0: &#123;0&#125;, T1 : &#123;1&#125;&quot;, a[0], a[1]);        //使用索引参数0或1对数据成员进行写入        a[0] = 15;        a[1] = 20;        Console.WriteLine(&quot;T0: &#123;0&#125;, T1 : &#123;1&#125;&quot;, a[0], a[1]);    &#125;&#125;以上代码会输出：T0: 0, T1: 0T0: 15, T1: 20Copy\n\n5.继承如果类OtherClass继承自SomeClass，则应按如下表示\nclass OtherClass : SomeClass&#123;&#125;Copy\n\n一个类只能继承自一个基类，所有的类都是Object类的派生类\n屏蔽基类的成员虽然派生类不能删除它继承的任何成员，但可以用与基类成员名称相同的成员来屏蔽基类成员（如果是函数成员，则要求签名相同，签名指名称和参数列表，不包括返回类型）。此外还要使用new修饰符来告诉编译器我正在故意屏蔽继承的成员。\n另外，即使派生类屏蔽了基类的成员，也可以使用基类访问表达式访问隐藏的继承成员。\nclass SomeClass&#123;    //基类    public string Field1 = &quot;Field1--In the base class&quot;;&#125;class OtherClass : SomeClass&#123;    //派生类    //使用new修饰符隐藏基类中的Field1字段    new public string Field1 = &quot;Field1--In the derived class&quot;;    public void PrintField1()&#123;        //访问派生类中的Field1，会输出&quot;Field1--In the derived class&quot;        Console.WriteLine(Field1);           //使用基类访问来访问基类中的Field1，会输出&quot;Field1--In the base class&quot;         Console.WriteLine(base.Field1);     &#125;&#125;Copy\n\n使用基类的引用MyDerivedClass derived = new MyDerivedClass();   //创建一个派生类对象MyBaseClass mybc = (MyBaseClass)derived;        //让基类引用指向派生类对象Copy\n\n对于如上代码，派生类的引用derived可以看到完整的MyDerivedClass对象，而基类引用mybc只能看到对象的MyBaseClass部分（只能看到基类成员）\n使用基类的引用\n另外，也可以使用基类引用调用派生类的方法，但要满足如下条件：\n\n派生类的方法和基类方法有着相同的签名和返回类型\n基类的方法用virtual标注\n派生类的方法用override标注在这种情况下，当使用基类引用（mybc）调用方法时，方法会被传递到派生类执行\n\n注意：\n\n覆写（override）和被覆写的方法应该有相同的访问性\n不能覆写static方法和非虚（virtual）方法\n\n当使用对象的基类引用调用一个覆写的方法时，方法的调用被沿着派生层次上溯执行，一直到标记为override的方法的最高派生版本。如果在更高派生级别有该方法的其他声明，但没有被标记为override，那么它们不会被调用。\n构造函数构造函数初始化语句两种形式：\n\n关键字base：指明使用哪一个基类的构造函数\n关键字this：指明使用哪一个当前类的构造函数以下构造函数使用了构造函数初始化语句，构造函数初始化语句指明了要使用第一个参数是string，第二个参数是int型的那个基类构造函数\n\n当声明一个不带构造函数初始化语句的构造函数时，它实际上是使用了无参数的基类构造函数。\npublic MyDerivedClass(int x, string s) : base(s, x)&#123;&#125;Copy\n\n如下代码中的MyClass类包含一个有一个int型参数的构造函数，这个构造函数使用了同一个类中具有两个参数的构造函数，并为第二个参数提供了一个默认值\npublic MyClass(int x) : this(x, &quot;Using Default String&quot;)&#123;&#125;Copy\n\n如果一个类有好几个构造函数，并且它们都需要在构造对象的过程中执行一些公共代码。这时可以把公共代码提取出来作为一个构造函数，被其他所有的构造函数作为构造函数初始化语句使用。\n访问级别类有两种访问级别：\n\npublic：可以被任何程序集中的代码访问\ninternal：默认的访问级别，仅可以被自己所在的程序集中的类看到\n\n类中的成员有5种访问级别：\n\n私有的（private）：只能被自己类中的成员访问，不能被其他的类访问，即使是继承自它的类也不行\n公有的（public）：所有的类都可以自由访问\n受保护的（protected）：和private类似，唯一不同的是，它允许该类的派生类来访问\n内部的（internal）：对程序集内部的所有类可见，对程序集外部的所有类不可见\n受保护内部的（protected internal）：相当于internal与protected的并集，即对程序集内部的类可见，也对继承自该类的类可见。\n\n抽象成员类似于Java中的抽象方法。它使用abstract标记，并且必须是函数成员（方法、属性、事件、索引）。不能有实现代码块，抽象成员的实现用分号表示。即每一个抽象成员的声明后都要带一个分号\n如：以下声明了两个抽象成员，一个名为PrintStuff的抽象方法和一个名为MyProperty的抽象属性\nabstract public void PrintStuff(string s);abstract public int MyProperty&#123;    get;    //分号代替实现    set;&#125;Copy\n\n\n抽象类：只能被继承，不能用来创建实例，用abstract修饰符标注\n密封类：与抽象类相反，只能被用来创建实例，不能被继承。用sealed修饰符标注\n\n语句操作符重载如果面对一个用户自定义的类或结构，运算符就会不知道如何取处理它。运算符重载允许用户自己定义C#运算符来操作自定义类型的操作数。\n\n为类或结构重载一个运算符x，可以声明一个名称为operator x的方法并实现它的行为（如operator +和operator -等）。一元运算符的重载方法带有一个单独的class或struct类型的参数，二元运算符重载的方法带有两个参数，其中至少有一个是class或struct类型。\n声明必须同时使用static和public的修饰符\n运算符必须要是要操作的类或结构的成员\n\n如下代码声明了LimitedInt类的两个重载的运算符：一个是加运算符，另一个是取负运算符\nclass LimitedInt Return&#123;    public static LimitedInt operator + (LimitedInt x, double y)&#123;        LimitedInt li = new LimitedInt();        li.TheValue = x.TheValue + (int)y;        return li;    &#125;    public static LimitedInt operator - (LimitedInt x)&#123;        LimitedInt li = new LimitedInt();        li.TheValue = 0;        return li;    &#125;&#125;Copy\n\n标签语句标签语句由一个标识符后面跟着一个冒号再跟着一条语句组成，它有如下的形式：Identifier: Statement。这条语句在执行时与只有Statement的语句相同，加一个标签的目的只是为了允许程序从其他位置跳转到这个标签所在的位置。\n\n因为标签有自己的声明空间，所以标签语句中的标识符可以是任意有效的标识符（可以与本地变量名相同）。\n标签的作用域仅在块内部\n\ngoto语句可以跳到它本身所在的块中的任何标签语句，或跳出到任何它被嵌套的块内的标签语句。goto Indentifier\n数组一维数组和矩形数组int[] intArr1 = new int[15];   //声明一维数组int[,] intArr2 = new int[5, 10];  //声明二维数组int var2 = intArr[2, 3];      //从二维数组中读值int[] intArr = new int[]&#123;10, 20, 30, 40&#125;;   //初始化一维数组int[,] intArr2 = new int[,]&#123;&#123;0, 1, 2&#125;, &#123;10, 11, 12&#125;&#125;; //初始化二维数组Copy\n\n交错数组交错数组是数组的数组，与矩阵数组不同，交错数组的子数组的元素个数可以不同\n//实例化顶层数组，不能在声明语句中初始化顶层数组之外的数组长度int[][] Arr = new int[3][];  //实例化子数组Arr[0] = new int[]&#123;1,2,3&#125;;Arr[1] = new int[]&#123;4,5,6&#125;;Arr[2] = new int[]&#123;7,8,9&#125;;Copy\n\nforeach语句注意：迭代变量item是只读的，不能修改。\nint[] arr1 = new int[]&#123;1,2,3&#125;;foreach(int item in arr1)    Console.WriteLine(&quot;Item Value: &#123;0&#125;, item&quot;);","categories":["Unity开发日志"],"tags":["c#","./net"]},{"title":"3.C#编程概述","url":"/2022/07/23/WebBackend/C#/3.C#%E7%BC%96%E7%A8%8B%E6%A6%82%E8%BF%B0/","content":"一个简单的C#程序windows按下W+R，在运行窗口输入devenv调出VS，然后新建一个项目\n\n选择C#-Windows-控制台应用模板，名称改为SimpleProgram\n\n右键项目文件夹我们在新建一个SimpleProgram的C#脚本\n\n输入代码如下：\nusing System;\t//诉编译器这个应用程序使用System命名空间的类型namespace Simple  //声明一个新命名空间，名称为Simple&#123;    class Program   //声明一个新的类类型，名称为Program    &#123;        static void Main()\t//声明一个名称为Main的方法作为类Program的成员        &#123;            Console.WriteLine(&quot;Hello World&quot;);\t//只包含一条单独的、简单的语句，这一行组成了Main的方法体        &#125;    &#125;&#125;\n\n标识符标识符是一种字符串，用来命名变量、方法、参数和许多后面将要闸述的其他程序结构。\n实例：\n//语法上有效，但非常混乱int totalCycleCount;int TotalCycleCount;int TotalcycleCount;\n\n命名字符规则：\n\n\n字母和下划线可以用在任何位置\n数字不能放在首位\n@字符只能放在标识符首位，但不推荐使用\n\n\n命名规则最好为驼峰式命名法或者下划线命名法，在团队合作中一个命名是很重要的！！！\n什么是驼峰命名法？\n\n驼峰命名法有大驼峰和小驼峰，函数、变量一般用小驼峰法，除第一个单词外，其他单词首字母大写，大驼峰法（即帕斯卡命名法），全部单词首字母大写。常用于类名，属性，命名空间等，实例如下：\n\npublic class DataBaseUser;\t//大驼峰，类名，属性，命名空间等int myStudentCount;\t\t//小驼峰，函数、变量\n\n关键字\n关键字不能被用作变量名或者其他形式的标识符，除非以@字符开始。\n所有C#关键字全部都是小写\n\n\n上下文关键字是仅在特定的语言结构中充当关键字的标识符。\n关键字和上下文关键字的区别：\n\n关键字不能被用作标识符，而上下位关键字可以在代码的其他部分被用作标识符\n\n\nMain函数：程序的起始点每个C#程序都必须有一个类带有Main方法（函数）。在先前所示的SimpleRrogram程序中，它被声明在Program类中。\n最简单的Main方法：\nstatic void Main()&#123;    更多语句&#125;\n\n空白程序中的空白指的是没有可视化输出的字符。空白字符包括：\n\n\n空格（Space）；\n制表符（Tab）；\n换行符：\n回车符。\n\n\n例如，下面代码段虽然看起来不一样，但是在编译器的眼里都是一样的…\n//我心目中的完美的格式（强迫症福音）Main()&#123;    Console.WriteLine(&quot;Hello Word&quot;);&#125;//老程序员的代码段，这看起来好难受:(Main()&#123;    Console.WriteLine(&quot;Hello Word&quot;);&#125;//没有空格回车的代码段Main()&#123;Console.WriteLine(&quot;Hello Word&quot;);&#125;\n\n语句语句是描述一个类型或告诉程序去执行某个动作的一条源代码指令，语句有简单语句（simple statement）和复杂语句（compound statement）\n\n简单语句（simple statement\n指定(赋值)\n\n调用\n\n回传\n\ngoto\n\n断言\n\n\n复合语句（compound statement）\nblock\nif语句\nSwitch语句\nWhile循环\nDo-while循环\nFor循环\n\n\n实例：\nint combatRating = 5; //定义一个初始指为5，ombatRating的整数型变量System.Console.WriteLine(&quot;This is a scum with a combatRating of &#123;0&#125;&quot;,ombatRating);\n\n代码块：\n\n块可以是一个由成对大括号包围的0条或者N条语句的序列，它在语法相当于一条语句。\n\n&#123;    int combatRating = 5; //定义一个初始指为5，ombatRating的整数型变量\tSystem.Console.WriteLine(&quot;This is a scum with a combatRating of &#123;0&#125;&quot;,ombatRating);&#125;\n\n关于代码块一些重要的内容：\n\n\n语法上只需要一条语句，而你需要执行的动作无法用一条简单的语句表达的情况下，考虑使用代码快。\n有些特定的程序结构只能使用块。在这些结构中，不能使用简单语句替换块。\n虽然简单语句以分号结束，但块后面不跟分号。\n\n\n从程序中输出文本BLC提供一个名为Console的类（在System命名空间中），该类包含了将数据输入和输出到控制台窗口的方法。\nWriteWrite是Console类的成员，它把一个文本字符串发送到程序的控制台窗口\n实列：\nConsole.Write(&quot;This is trivial text&quot;);\n\nWriteLineWriteLine是Console的另一个成员，它和Write实现相同的功能，但是在每个输出字符串的结尾添加一个换行字符。\n格式字符串Write语句和WriteLine语句的常规形式中可以由一个以上的参数。\n\n如果不止一个参数，参数间用逗号分隔。\n第一个参数必须是字符串，称为格式字符串。格式字符串可以包含替代标记。\n替代标记在格式字符串中标出位置，在输出字符串中该位置将用一个值来替代。\n替代标记由一个整数及括住它的一对大括号组成，其中整数就是替换值的数字位置。跟着格式字符串的参数称为替换值，这些替换值从0开始编号\n\n\n\n语法：\nConsole.WriteLine(格式字符串 (含替代标记) ，替换值0，替换值1， 替换值2，......);\n\n实例：\nConsole.WriteLine(&quot;Two saple integers are &#123;0&#125; and &#123;1&#125;.&quot; 3，6)；\n\nC# 6.0引入了更简单易懂的的方式表述参数化字符串的语法，称为字符串插值，他是通过直接在替代标记内插入变量名实现的。实际上，替代标记告诉编辑器这个变量名将被视作为一个变量，而不是字符串字面量——前提是在字符串前面加上了$符号。\nint var1 = 3;int var2 = 6;Console.WriteLine($&quot;Two sample integers are &#123;var1&#125; and &#123;var2&#125;.&quot;)\n\n多重标记和值在C#中，可以使用任意数量的替代标记和任意数量的值。\n\n值可以以任何顺序使用\n值可以在格式字符串中替换任意次\n\n例如，下面的语句使用了3个标记但只有两个值。注意：值1被用在了值0之前，而且被用了两次。\nConsole.WriteLine(&quot;Three integers are &#123;1&#125;, &#123;0&#125; and &#123;1&#125;.&quot;,3,6)\n\n格式化数字字符串Console.WriteLine(&quot;The value: &#123;0&#125;.&quot; , 500);\t\t//输出数字Console.WriteLine(&quot;The value: &#123;0:C&#125;.&quot; , 500);\t//格式化为货币\n\n\n\n对齐说明符\n对齐说明符表示字段中字符的最小宽度。对齐说明符有以下特性：\n\n对齐说明符是可选的，而且使用逗号来和索引号分离。\n符号表示右对齐或左对齐。正数表示右对齐，负数表示左对齐。\n\n\n格式字段\n格式字段表示指定了数字应该以哪种形式表示。例如：应该表示为货币、十进制数字、十六进制数字还是定点符号？\n\n冒号后必须紧跟着格式说明符，中间不能有空格。\n\n格式说明符是一个字母字符，是9个内置字符格式之一。某些字符形式不分大小写\n\n精度说明符是可选的，由1~2位数字组成。它的实际意义取决于格式说明符。实例：\nConsole.WriteLine(&quot;&#123;0:F4&#125;, 12.345678&quot;);//F4：格式组件——4位小数的定点数\n\n\n标准数字格式说明符  \n\n\n注释\n不能嵌套带有分隔符的注释\n注释类型的范围如下：\n对于单行注释&#x2F;&#x2F;，一直到行结束都有效。\n对于带分隔符的注释，直至遇到第一个结束分隔符都有效。\n\n\n\n\t带分割符的注释由两个字符的开始标记（/*）和两个字符的结束标记（*/）/*\t注释的文本不会被编译器执行\t带分隔符的注释可以跨任意多行*/\n\n文档注释文档注释只包含XML文本，可以用于产生程序文档，实例：\n///&lt;summary&gt;///This class does...///&lt;/summary&gt;class Program&#123;    ......\n\n","categories":["C#/.NET"],"tags":["c#"]},{"title":"1.C#与.NET框架","url":"/2022/07/22/WebBackend/C#/1C#%E4%B8%8ENET%E6%A1%86%E6%9E%B6/","content":"由于某种原因又重新从.NET开始学，加强记忆，并重新整理优化笔记\n概念：.Net与C\n\n.net（dotnet）:一般指.Net Framework框架.一种平台，一种技术\nC#（sharp）：一种编程语言，可以开发基于.net平台的应用。\n(*）Java既是一种平台又是一种编程语言\n\n\n.Net FrameWork框架是包含.Net平台,.Net FrameWork框架是.NET平台中不可缺少的一部分，它提供了一个稳定的运行环境来保证我们基于.NET平台开发的各种应用能够正常的运转\n\n.NET dotnet\n\n\nMicrosoft 新一代多语言的开发平台，用于构建和运行应用程序。\n\n\nC# （C Sharp）\n\nMicrosoft 专为.NET推出的高级编程语言。\n从语言技术、风格、严谨性等特点上来说，C#可称为诸多编程语言中最为优秀的一款，甚至由它引发出计算机界中的多种新规范和新特征。\n\nMono\n\nNovell公司支持在其他操作系统下开发.NET程序的框架。\nUnity借助Mono实现跨平台，核心是.NET Framework 框架。\n\n\n\n.NET框架（.Net FrameWork）由两部分组成：\n\n\n\nCLR（Common Language Runtime，公共语言运行库）：在运行时管理程序的执行，包括内存管理和垃圾收集、代码安全验证、代码执行线程管理及异常处理等\nBCL（Base Class Library，基类库）：包括通用基础类（文件操作、字符串操作等相关的类）、集合类（列表、字典、散列表）、线程和同步类、XML类。\n\n面向对象的开发环境\nCLR、BCL和C#完全是面向对象的，并形成了良好的集成环境。\n系统为本地程序和分布式系统都提供了一致的、面向对象的编程模型。为桌面应用程式、移动应用程序和Web开发提供了软件开发接口，涉及的目标范围很广，从桌面服务器到手机。\n.Net都能干什么:\n\n桌面应用程序\nInternet应用程序 ASP.NET\n手机开发 Wp8\nUnity3D游戏开发或者虚拟现实\n\n.Net两种交互模式:\n\nC/S：客户机（Client）/服务器模式（Server）如：QQ\nB/S：浏览器（Browser）/服务器模式（Server）\n\n自动垃圾收集\nCLR有一项服务叫GC（garbage collector，垃圾收集器），他能自动管理内存。GC自动从内存中删除程序不在访问的对象。\n互操作性\n.NET框架专门考虑了不同的.NET语言、操作系统或WIn32 DLL 和COM之间的互操作性。\n不需要COM\n.NET框架使程序员摆脱了COM的束缚\n简化的部署\n.NET程序不需要使用注册表注册\n.NET提供一种称为并行执行的特性，允许一个DLL的不同版本在同一台机械上存在。\n类型安全性\nCLR检查并确保参数及其他数据对象的类型安全，不同编程语言编写的组件之间也没有问题。\n基类库\n.NET框架提供了一个庞大的基础类库，很自然地，它被称为基类库（Base Class Library，BCL）或框架类库（Framework Class Librart，FCL）再写程序时可以使用其中的类：\n\n通用基础类     这些类提供了一组极为强大的工具，可以应用到许多编程任务中，比如文件操作、字符串操作、安全和加密。\n集合类   这类实现列表、字典、散列表以及位数据。\n线程和同步类    这些类用于创建多线程应用程序\nXML类  这些类用于创建、读取以及操作XML文档\n\n编译成CIL\n.NET语言的编译器接受源代码文件，并生成名为程序集的输出文件\n\n\n程序集要么是可执行的，要么是DLL\n\n\n程序集里的代码并不是本机代码，而是一种名为CIL（Common Intermediate Language，公共中间语言）的中间语言\n\n\n程序集包含的信息中，包含下列项目：\n\n\n\n程序的CIL；\n程序中使用的类型元数据；\n对其他程序引用的元数据\n\n\n编译成本机代码并执行\n程序的CIL直到被调用运行时才会被编译成本机代码。在运行时，CLR执行下面的步骤\n\n无论原始源文件的语言是什么，都执行同样的编译和执行的过程\n以下图片说明了3个用不同语言编写的程序的完整编译时和运行的过程\n\n什么是CLI\nCLI（Common Language Infrastructure，公共语言基础结构），它发.NET框架的所有组件链接成一个内聚的、一致的系统。它展示了系统的感念和架构，并详细说明了所有软件都必须遵守的规则和约定。CLI和C#被Ecmna International批准为开放的国际标准规范。\n\nCLI的重要组成部分\n\n\n公共类型系统（Common Type System,CTS）\n\n\nCTS定义了一组丰富的内置类型，以及每种类型固有的、独特的特性\n.NET兼容编程语言提供的类型通常映射到CTS中已定义的内置类型集的某一个特殊子集\nCTS最重要的特征之一是所有类型都继承自公共的基类-object\n使用CTS可以确保系统类型和用户定义类型能够被任何.NET兼容的语言所使用\n\n\n\n\n公共语言规范（Common Language Specification，CLS）\n\n详细说明了一个.NET兼容编程语言的规则、属性和行为，其主题包括数据类型、类结构和参数传递\n\n\n\n什么是CLR\n.NET框架的核心组件时CLR，它在操作系统的顶层，负责管理和程序的执行，CLR还提供下列服务：\n\n自动垃圾收集；\n安全和认证；\n通过访问BCL得到广泛的编程功能，包括如Web服务和数据服务之类的功能。\n\n\n各种缩写\n\nC#的演化\n","categories":["Unity开发日志"],"tags":["c#","./net"]},{"title":"4.类型、存储量和变量","url":"/2022/07/24/WebBackend/C#/4.%E7%B1%BB%E5%9E%8B%E3%80%81%E5%AD%98%E5%82%A8%E9%87%8F%E5%92%8C%E5%8F%98%E9%87%8F/","content":"C#程序是一组类型声明C程序可以说是一组函数和数据类型，C++程序是一组函数和类，而C#程序是一组类型声明。\n\nC#程序或DLL的源代码是一组类型声明。\n对于可执行程序，类型声明中必须有一个包含Main方法的类\n命名空间是一种将相关的类型声明分组并命名的方法。因为程序是一组相关的类型声明，所以通常在你创建的命名空间内部声明程序类型。\n\nnamespace MyProgram\t\t//创建新的命名空间&#123;    DeclarationOfTypeA\t\t//声明类型    DeclarationOfTypeB            class C\t\t\t\t//声明类型    &#123;        static void Mian()        &#123;            ...        &#125;    &#125;&#125;\n\n类型（数据类型）是一种模板既然C#程序是一组类型声明，那么学习C#就是学习如何创建和使用类型。\n类型由下面的元素定义：\n\n名称；\n用于保存数据成员的数据结构；\n一些行为及约束条件。\n\n\n实例化类型从某个类型模板创建实际的对象，称为实例化该类型。\n\n通过实例化类型而创建的对象被称为类型的对象或者类型的实例\n在C#程序中，每个数据项都是某种类型的实例。这些类型可以是语言自带的，可以是BCL或者其他库提供的，也可以是程序与定义的。\n\n\n数据成员和函数成员像short、int和long这样的类型称为简单类型。这种类型只能存储一个数据项。\n其他的类型可以存储多个数据项。比如数组(array)类型就可以存储多个同类型的数据项。这些数据项称为数组元素。可以通过数字来引用这些元素，这些数字被称为索引。\n成员的类别包含多个不同的数据类型的数据项，这些类型中的数据项个体称为成员，和数组不同，这些成员有独特的名称：\n\n数据成员\t保存了这个类的对象或整个类相关的数据。\n函数成员    执行代码。函数成员定义类型的行为。\n\n\n预定义类型C#提供了16种预定义类型，其中包括13种简单类型和3种非简单类型。\n简单类型：\n\n\n11种数值类型（数据类型属于数值类型的超类）\n不同长度的有符号和无符号整数类型。\n浮点数类型float和double。\ndecimal高精度小数类型，常用于货币计算。\n\n\nUnicode字符类型char。\n布尔类型bool。\n\n\n非简单类型：\n\n\nstring，Unicode字符数组。\nobject，其他类型的基类。\ndynamic，使用动态语言编写的程序集时使用。\n\n\n\n预定类型的补充所有预定类型都直接映射到底层的.NET类型。C#类型名称就是.NET类型的别名，所以使用.NET的类型名称也符合C#语法。\n\n\n用户定义类型有6种类型可以由用户自己创建：\n\n\n类类型（calss）；\n结构类型（struct）；\n数组类型（array）；\n枚举类型（enum）；\n委托类型（delegate）；\n接口类型（interface）；\n\n\n类型通过类型声明创建，类型声明包含以下信息：\n\n\n要创建的类型的种类；\n新类型的名称；\n对类型中每个成员的声明（名称和规格），array和delegate类型除外，它们不含有命名成员。\n\n\n\n栈和堆程序运行时，它的数据必须存储在内存中。一个数据项需要多大的内存、存储在什么地方，以及如何存储都依赖于该数据项的类型。\n运行中的程序使用两个内存区域来存储数据：栈和堆\n栈栈是一个内存数组，是一个LIFO（Last-In First-Out，后进先出）的数据结构。栈存储几种类型的数据：\n\n\n某些类型变量的值；\n程序当前的执行环境；\n传递给方法的参数。\n\n\n栈的特性：\n\n\n数据只能从栈的顶端插入和删除。\n把数据放到栈顶称为入栈（push）。\n从栈顶删除数据称为出栈（pop）。\n\n\n\n堆堆是一块内存区域，在堆里可以分配大块的内存用于存储某种类型的数据对象。与栈不同，堆的内存能够以任意顺序存入和移除。\n\n堆里面的数据不能显式删除。CLR的自动垃圾收集器在判断出程序的代码将不会再访问某数据项时，会自动清除无主的堆对象。\n\n值类型和引用类型数据项的类型定义了存储数据需要的内存大小及组成该类型的数据成员。类型还决定了对象在内存中的存储位置——栈或堆。\n类型被分为两种：值类型和引用类型，这两种类型在内存中的存储方式不同：\n\n\n值类型只需要一段单独的内存，用于存储实际的数据。\n引用类型需要两端内存。\n第一段存储实际的数据，它总是位于堆中。\n第二段是引用，指向数据在堆中的存放位置。\n\n\n\n\n\n存储引用类型对象的成员\nC#类型的分类\n变量变量是一个名称，表示程序执行时存储在内存中的数据\n\n变量声明变量使用前必须声明：\n\n\n给变量命名，并为它关联一种类型；\n让编译器为它分配一块内存。\n\n\n实例：\nint var1;//int为数据类型，var2为类型的值\n\n4个变量的声明以及它们在栈中的位置\n\n1.变量初始化语句\n除声明变量的名称和类型以外，声明还能把它的内存初始化为一个明确的值。\n变量初始化语句（variablie initializer）由一个等号后面跟一个初始值组成，如：\nint var2 = 17;\n\n有些程序变量不初始化赋值会报错\n\n2.自动初始化\n有些程序会自动初始化，没有自动初始化为默认值的变量在程序为它赋值之前包含未定义值。\n\n\n多变量声明可以在单个声明语句中声明多个变量：\n\n\n多变量声明中的变量必须类型相同。\n变量名必须用逗号分隔，可以在变量名后包含初始化语句。\n\n\n实例：\n//声明一些变量，有的被初始化，优点未被初始化int var3 = 7, var4, var5 = 3;double var6, var7 = 6.53;int var8, float var9;\t//错误！多变量声明的变量类型必须相同\n\n使用变量的值变量名代表该变量保存的值，可以通过使用变量名来使用值。例如：\nConsole.WriteLine(&quot;&#123;0&#125;&quot;, var2);Console.WriteLine(&quot;&#123;var2&#125;&quot;);\n\n静态类型和dynamic关键字每一个变量都包括变量类型。这样编译器在运行时可以确定需要的内存总量以及那些部分应该存在栈上，哪些部分应该在堆上。变量的类型在编译运行的时候不能被修改。这叫做静态类型。\n不是所有的语言都是静态类型的，诸如InronPython和IronRuby之类的脚本语言时动态类型的。也就是说，变量的类型直到运行时才会被解析。由于它们是.NET语言，所以C#程序需要能够使用这些语言编写的程序集。问题是，程序集中的类型到运行时才会被解析，而C#又要引用这样的类型并且需要在编译的时候解析类型。\n针对这个问题，C#语言设计者增加了dynamic关键字，代表一个特定的C#类型，它知道如何在运行时解析自身。\n在编译时，编译器不会对dynamic类型的变量做类型检查。相反，他将与该变量及该变量的操作有关的所有信息打包。在运行时，会对这些信息进行检查，以确保它与变量所代表的实际类型一致。否则，将在运行时抛出异常。\n可空类型在某些情况下，特别是使用数据库的时候，你希望表示变量目前为保存有效的值。对于引用类型把变量设置为null即可。但定义值类型的变量时，不管它的内容是否含有有效的意义，其内存都会进行分配。\n可空类型允许创建可以标记为有效或无效的值类型变量，这样就可以在使用它之前确定值的有效性。普通的值类型称作非可空类型。\n","categories":["C#/.NET"],"tags":["c#","./net"]},{"title":"MySQL笔记(office)","url":"/2022/09/25/DBMS/MySql/MySQL%E7%AC%94%E8%AE%B0(office)/","content":"数据库基本知识数据库介绍数据库概念\n数据库（Database）是按照数据结构来组织、存储和管理数据的仓库\n\n数据库的发展史\n最早期以穿孔卡片的方式，按照一定的排列方式记录数据\n\n数据库管理系统DBMS\n是一种操作和管理数据库的大型软件，用于建立，使用和维护数据库，简称DBSN\n它对数据库进行统一的管理和控制，以保证数据库的安全性和完整性\n数据库管理系统是数据库的核心，是管理数据库的软件\n我们一般说的数据库，就是DBMS，数据库管理系统\n\n常见的数据库\n\nOracle ：运行稳定，可移植性高，功能齐全，性能超群，适用于大型企业领域\nDB2：速度快，可靠性好，适用于海量数据，恢复性极强，适用于大中型企业领域\nMysql：开源，体积小，速度快，适用于中小型企业领域\nSQL Server：全面，效率高，界面友好，操作容易，但是不跨平台，适用于中小型企业领域\n\n专业术语表：具有固定的列数和任意的行数\n\n\n\nSno\nSNAME\nSgender\nSheight\n\n\n\n1\n小红\n18\n165\n\n\n2\n小兰\n19\n170\n\n\n3\n刘德华\n25\n179\n\n\n4\n刘能\n20\n173\n\n\n5\n赵四\n30\n166\n\n\n6\n谢大脚\n27\n171\n\n\n7\n王祖贤\n22\n169\n\n\n8\n郭靖\n24\n181\n\n\n9\n黄蓉\n23\n161\n\n\n10\n黄老师\n43\n175\n\n\n\n列\n一个数据项Field字段\n\n\n行\n一条记录row\n\n\n数据库\n数据库是一些关联表的集合\n\n\n主键\n主键是唯一的，一个数据表只能包含一个主键，可以使用主键来查询数据\n\n\n外键\n外键用于关联两个表\n\n\n索引\n使用索引可快速访问数据库表中的特定信息，索引是对数据库表中的一列或多列的值进行排序的一种结构，类似于书籍的目录。\n\n\n\nMySql数据库20229.22#查询班级中所有学生SELECT * FROM students;#查询班级中所有男生SELECT * FROM students WHERE stu_sex=&#x27;男&#x27;;#建表的语句CREATE TABLE teachers(\tt_id INT(255) NOT NULL PRIMARY KEY,\tt_name VARCHAR(255) NOT NULL,\tt_age INT(255) NOT NULL,\tt_sex VARCHAR(255) NOT NULL,\tt_height DOUBLE(255,2));#添加一条教师信息INSERT INTO teachers(t_id,t_name,t_sex,t_age,t_height)VALUE(202201,&quot;孔子&quot;,&quot;男&quot;,80,1.88);INSERT INTO teachers(t_id,t_name,t_sex,t_age)VALUE(202202,&quot;墨子&quot;,&quot;男&quot;,70);INSERT INTO teachers(t_id,t_name,t_sex,t_age,t_height)VALUE(202203,&quot;孟子&quot;,&quot;男&quot;,60,NULL);INSERT INTO teachers VALUE(202204,&quot;韩非子&quot;,77,&quot;男&quot;,NULL);#插入一条老师信息，姓名诸葛亮，男，34岁,1.89,教师编号202201 INSERT INTO teachers(t_name,t_sex,t_age,t_height,t_id)VALUE(&quot;诸葛亮&quot;,&quot;男&quot;,34,1.89,202205);#插入一条老师信息，教师编号202202，庞统，男，33岁，身高不详 INSERT INTO teachers(t_id,t_name,t_sex,t_age)VALUE(202206,&quot;庞统&quot;,&quot;男&quot;,33);#添加三条学生记录 刘备，35，男，身高1.78，体重不详，编号202211#编号202212，关羽，34，男，身高2.1，体重100kg#编号202213，张飞，33，男，身高1.8，体重90kgINSERT INTO students VALUES(202211,&quot;刘备&quot;,35,&quot;男&quot;,1.78,NULL),(202212,&quot;关羽&quot;,34,&quot;男&quot;,2.1,100),(202213,&quot;张飞&quot;,33,&quot;男&quot;,1.8,90);\n\n9.23CREATE TABLE staff(\tsta_id INT(255) NOT NULL PRIMARY KEY,\tsta_name VARCHAR(255) NOT NULL,\tsta_department VARCHAR(255),\tsta_sex VARCHAR(255) NOT NULL,\tsta_age INT(255) NOT NULL,\tsta_salary DOUBLE(255,2) NOT NULL,\tsta_phone VARCHAR(255) NOT NULL,\tsta_marital VARCHAR(255));#一次性录入三条员工信息：#开发部的王建国，男，29岁，员工号201904，工资10k，18866667777，已婚；#人事部的魏淑芬，女，29岁，至今未婚，员工号201702，13366669999，工资7.5k；#测试部的夏雨荷，女，23岁，员工号202207，工资4k，15922223333，婚姻状况未知；INSERT INTO staff(sta_name,sta_sex,sta_age,sta_id,sta_salary,sta_phone,sta_marital,sta_department) VALUES(&quot;王建国&quot;,&quot;男&quot;,29,201904,10000,&quot;18866667777&quot;,&quot;已婚&quot;,&quot;开发部&quot;),(&quot;魏淑芬&quot;,&quot;女&quot;,29,201702,7500,&quot;13366669999&quot;,&quot;至今未婚&quot;,&quot;人事部&quot;),(&quot;夏雨荷&quot;,&quot;女&quot;,23,202207,4000,&quot;13366669999&quot;,&quot;未知&quot;,&quot;测试部&quot;);#录入一条员工信息：#开发部吴邪，年龄22岁，男，员工号202220，工资2k，联系方式13155551111，未婚；INSERT INTO staff(sta_name,sta_sex,sta_age,sta_id,sta_salary,sta_phone,sta_marital,sta_department) VALUE(&quot;吴邪&quot;,&quot;男&quot;,22,202220,2000,&quot;13155551111&quot;,&quot;未婚&quot;,&quot;开发部&quot;);#把李四的身高更新为1.75UPDATE students SET stu_height = 1.75 WHERE stu_name = &quot;李四&quot;;#把班级中所有学生的年龄加1岁UPDATE studentsSET stu_age = stu_age + 1;#把李四年龄改为20，身高加2里面UPDATE students SET stu_age = &quot;20&quot;,stu_height = stu_height + 0.02 WHERE stu_name = &quot;李四&quot;;#删除小红的全部信息DELETE FROM students WHERE stu_name = &quot;小红&quot;;#查询出班级中年龄20岁以下，身高1.65以上的女生姓名，年龄，身高SELECT stu_name,stu_age,stu_height FROM students WHERE stu_age&lt;20 AND stu_height&gt;1.65;#查询出班级中身高不低于1.7，体重不大于65kg的所有男生信息SELECT stu_name,stu_age,stu_height FROM students WHERE stu_height&gt;1.7 AND stu_weight&lt;65;#把学号202204,202206,202208三名学生的年龄加一岁UPDATE students SET stu_age = stu_age + 1 WHERE stu_id = 202204 OR stu_id = 202206 OR stu_id = 202208;#找出班级中1.6以下和1.8以上的所有男生SELECT * FROM studentsWHERE stu_height &lt; 1.6 OR stu_height &gt; 1.8;#找出班级中身高1.62以上的女生和1.75以上的男生全部信息 SELECT *FROM studentsWHERE stu_height &gt; 1.62 AND stu_sex = &quot;女&quot; OR stu_height &gt; 1.75 AND stu_sex = &quot;男&quot;;\n\n9.26# 查询出班级中所有姓张的学生信息SELECT * FROM students WHERE stu_name LIKE &quot;张%&quot;;#查询出班级中名字由三个字组成的学生信息SELECT * FROM students WHERE stu_name LIKE &quot;___&quot;;#查询出班级中第二个字为&quot;杰&quot;的学生SELECT * FROM students WHERE stu_name LIKE &quot;_杰%&quot;;#查询出班级中名字带有&quot;杰&quot;的学生信息SELECT * FROM students WHERE stu_name LIKE &quot;%杰%&quot;;#查询出班级中1.6以上的女生全部信息，按照身高升排序SELECT * FROM students WHERE stu_height &gt; 1.6 AND stu_sex = &quot;女&quot; ORDER BY stu_height ASC;#查询出班级中的年龄不大于22的男生姓名，性别和年龄，按照年龄降序SELECT stu_name AS 学生姓名, stu_sex AS 学生性别, stu_age AS 学生年龄FROM\tstudentsWHERE\tstu_age &lt; 22AND\tstu_sex = &quot;男&quot;ORDER BY\tstu_age DESC;#查询出班级中男生的数量SELECT COUNT(*) AS 男生数量FROM\tstudentsWHERE\tstu_sex = &quot;男&quot;;\t#查询出班级中最大年龄和最小年龄SELECT\tMAX(stu_age) AS 最大年龄,\tMIN(stu_age) AS 最小年龄FROM\tstudents;\t#查询班级总年龄，平均年龄SELECT\tSUM(stu_age) AS 总年龄,\tAVG(stu_age) AS 平均年龄FROM\tstudents;\t#查询出身高不低于1.63的名字两个字的学生学号，姓名，身高。按照身高降序排序SELECT stu_id AS 学号, stu_name AS 姓名, stu_height AS 身高FROM\tstudentsORDER BY\tstu_heightDESC;#查询出周姓学生的平均年龄，平均身高，平均体重;SELECT AVG(stu_age) AS 平均年龄, AVG(stu_height) AS 平均身高, AVG(stu_weight) AS 平均体重FROM\tstudentsWHERE\tstu_name LIKE &quot;周%&quot;;#查询出班级中姓张，姓王，姓李且年龄不小于21的学生信息，按照年龄升序显示，同龄者按照身高降序；SELECT  *FROM\tstudentsWHERE\tstu_name LIKE &quot;张%&quot; OR\tstu_name LIKE &quot;王%&quot; OR\tstu_name LIKE &quot;李%&quot; AND\tstu_age &gt; 21ORDER BY\tstu_age,\tstu_height DESC;\t# 查询出班级中低于男生平均身高的男生数量SELECT\tCOUNT(*) AS 低于平均身高男生数量FROM\tstudentsWHERE\tstu_height &lt; (\t\tSELECT AVG(stu_height)\t\tFROM students\t\tWHERE stu_sex = &quot;男&quot;\t);\t#查询出班级中年龄最小的学生全部信息SELECT\t*FROM\tstudentsWHERE\tstu_age = (\t\tSELECT MIN(stu_age)\t\tFROM students\t);\t#查询出班级中年龄低于班级平均年龄，身高不低于1.62的女生姓名，年龄和身高。按照年龄升序SELECT\tstu_name AS 姓名,\tstu_age AS 年龄,\tstu_height AS 身高FROM\tstudentsWHERE\tstu_age &lt; (\t\tSELECT AVG(stu_age)\t\tFROM students\t\tWHERE stu_height &gt; 1.62 AND stu_sex = &quot;女&quot;\t)ORDER BY stu_age DESC;#查询出班级中姓张和姓刘的学生中年龄最大者的全部信息SELECT * FROM students WHERE stu_age=(SELECT MAX(stu_age) FROM students WHERE stu_name LIKE &#x27;张%&#x27; OR  stu_name LIKE &#x27;刘%&#x27;)AND (stu_name LIKE &#x27;张%&#x27; OR  stu_name LIKE &#x27;刘%&#x27;);\t#统计出班级中体重信息缺失的学生个数SELECT\tCOUNT(*)FROM\tstudentsWHERE\tstu_weight IS NULL;\t#查询出比202203这个学生高的全部男学生信息SELECT\t*FROM\tstudentsWHERE\tstu_height &gt; (\t\tSELECT stu_height\t\tFROM students\t\tWHERE stu_id = 202203\t)\tAND stu_sex = &quot;男&quot;\t;\n\n9.27#查询出班级中比李四年龄大的学生姓名和年龄，按照年龄降序显示SELECT stu_name,stu_age FROM students WHERE stu_age&gt;(SELECT stu_age FROM students WHERE stu_name=&#x27;李四&#x27;) ORDER BY stu_age DESC;#查询出班级中有多少名女生的身高高于女生平均身高；SELECT COUNT(*) FROM students WHERE stu_sex=&#x27;女&#x27; AND stu_height&gt;(SELECT AVG(stu_height) FROM students WHERE stu_sex=&#x27;女&#x27;)#查询出最小年龄的男生全部信息SELECT * FROM students WHERE stu_sex=&#x27;男&#x27; AND stu_age=(SELECT MIN(stu_age) FROM students WHERE stu_sex=&#x27;男&#x27;); INSERT INTO scores VALUES(202215,&#x27;语文&#x27;,100),(202215,&#x27;数学&#x27;,NULL),(202215,&#x27;英语&#x27;,77);#查询出缺考和挂科的学生学号和姓名；SELECT stu_id,stu_name FROM studentsWHERE stu_id in(SELECT sc_id FROM scores WHERE IFNULL(sc_score,0)&lt;60);#查询出学号202205这个学生的总成绩；SELECT SUM(sc_score) FROM scores WHERE sc_id=202205#查询出语文成绩大于85分的男生学号，姓名和性别；SELECT stu_id,stu_name,stu_sex FROM students WHERE stu_id in (SELECT sc_id FROM scores WHERE sc_sub=&#x27;语文&#x27; AND sc_score&gt;85) AND stu_sex=&#x27;男&#x27;;#查询英语最高分的学生学号，姓名，性别，年龄；SELECT stu_id,stu_name,stu_sex,stu_age FROM students WHEREstu_id in (SELECT sc_id FROM scores WHERE sc_sub=&#x27;英语&#x27; and sc_score=(SELECT MAX(sc_score) FROM scores WHERE sc_sub=&#x27;英语&#x27;));#查询出数学及格的学生数量；SELECT COUNT(*) FROM scores WHERE sc_sub=&#x27;数学&#x27; AND sc_score&gt;=60;#查询出班级中男生女生分别多少人SELECT stu_sex AS 性别,COUNT(*) AS 人数 FROM students GROUP BY stu_sex;#查询班级中分组后男女的名字SELECT  stu_sex,GROUP_CONCAT(stu_name) FROM students GROUP BY stu_sex;#查询出每个人的学号和总成绩SELECT sc_id,SUM(sc_score) FROM scores GROUP BY sc_id#查询出张三，李四，王五分别的总成绩，按照总成绩降序显示SELECT sc_id,SUM(sc_score) FROM scores WHERE sc_id in (SELECT stu_id FROM students WHERE stu_name in (&#x27;张三&#x27;,&#x27;李四&#x27;,&#x27;王五&#x27;)) GROUP BY sc_id ORDER BY SUM(sc_score) DESC;#查询出班级中平均分大于75的学生学号和姓名SELECT stu_id,stu_name FROM students WHERE stu_id in (SELECT sc_id FROM scores GROUP BY sc_id HAVING AVG(IFNULL(sc_score,0))&gt;75);\n\n9.28#查询出班级中每名女生的学号，姓名，性别，总成绩及平均分#查询出本轮考试中各科挂科及缺考的总人数#查询出低于班级整体平均分的学生全部信息#查询出比202205总成绩高的学生学号，姓名及总成绩#查询各科成绩的第一名的学生学号，姓名和对应科目及成绩\n\n9.29#查询出班级中每名女生的学号，姓名，性别，总成绩及平均分SELECT stu_id,stu_name,stu_sex,SUM(sc_score),AVG(IFNULL(sc_score,0))FROM students,scoresWHERE stu_id=sc_id AND stu_sex=&#x27;女&#x27;GROUP BY sc_id;#查询出本轮考试中各科挂科及缺考的总人数SELECT sc_sub,COUNT(*) FROM scoresWHERE IFNULL(sc_score,0)&lt;60 GROUP BY sc_sub;#查询出低于班级整体平均分的学生全部信息SELECT * FROM students,scoresWHERE stu_id=sc_id AND stu_id in (SELECT sc_id FROM scores GROUP BY sc_idHAVING AVG(IFNULL(sc_score,0))&lt;(SELECT AVG(IFNULL(sc_score,0)) FROM scores));#查询出比202205总成绩高的学生学号，姓名及总成绩SELECT stu_id,stu_name,SUM(sc_score) FROM students,scoresWHERE stu_id=sc_id GROUP BY sc_idHAVING SUM(sc_score)&gt;(SELECT SUM(sc_score) FROM scores WHERE sc_id=202205);#查询各科成绩的第一名的学生学号，姓名和对应科目及成绩SELECT stu_id,stu_name,sc_sub,sc_scoreFROM students,scores,(SELECT sc_sub AS sc_subject,MAX(sc_score) as sc_max FROM scores GROUP BY sc_sub) AS aWHERE stu_id=sc_id AND scores.sc_sub=a.sc_subject AND scores.sc_score=a.sc_max;\n\n9.30SELECT stu_id AS 学号,stu_name AS 姓名,stu_sex AS 性别,sc_sub AS 科目,sc_score AS 分数,sc_idsc.score AS 总成绩FROM students,scores,(SELECT sc_id AS id,sum(sc_score) AS score FROM scores GROUP BY sc_id) AS sc_idsc,(SELECT stu_sex AS gender,MAX(sum1.sc_sum) AS num_max FROM students,(SELECT sc_id AS sum_id,SUM(sc_score) AS sc_sum FROM scores,students WHERE stu_id=sc_id GROUP BY sc_id) AS sum1 WHERE stu_id=sum1.sum_idGROUP BY stu_sex) AS gender_maxWHERE stu_id=sc_id AND sc_id=sc_idsc.id AND stu_sex=gender AND num_max=sc_idsc.score; \n\nSELECT stu_id,stu_name,stu_sex,GROUP_CONCAT(sc_score),SUM(sc_score) FROM students,scores, (SELECT sc_id AS sc_ida FROM scores,students WHEREstu_id=sc_id AND stu_sex=&#x27;男&#x27; GROUP BY sc_id ORDER BY SUM(sc_score) DESC LIMIT 0,1) AS a,(SELECT sc_id AS sc_idb FROM scores,students WHEREstu_id=sc_id AND stu_sex=&#x27;女&#x27; GROUP BY sc_id ORDER BY SUM(sc_score) DESC LIMIT 0,1) AS bWHERE sc_id=stu_id AND (scores.sc_id=a.sc_ida OR scores.sc_id=b.sc_idb) GROUP BY sc_id ORDER BY SUM(sc_score) DESC;\n\nSELECT stu_id,stu_name,students.stu_sex,sc_sub,sc_score,b.fen FROM students,scores,(SELECT stu_sex,stu_id AS stuid,a.sumscore as fen FROM (SELECT sc_id AS scid,SUM(sc_score) AS sumscore FROM scores GROUP BY sc_id ORDER BY sumscore DESC) AS a,studentsWHERE a.scid=stu_id GROUP BY stu_sex) AS bWHERE stu_id=sc_id AND students.stu_id=b.stuid\n\n10.8#建表students#学号主键，姓名（不为空），性别（不为空），生日（date类型），班级CREATE TABLE students(stu_id INT(255) PRIMARY KEY,stu_name VARCHAR(255) NOT NULL,stu_sex VARCHAR(255) NOT NULL,stu_birth date,stu_class VARCHAR(255));#删除指定列ALTER TABLE students DROP COLUMN stu_birth;#添加一列ALTER TABLE students ADD COLUMN stu_birth date AFTER stu_sex;#插入insert into students values(105,&#x27;匡明&#x27;,&#x27;男&#x27;,&#x27;1975-10-02&#x27;,&#x27;95031&#x27;);insert into students values(107,&#x27;王丽&#x27;,&#x27;女&#x27;,&#x27;1976-01-23&#x27;,&#x27;95033&#x27;);insert into students values(101,&#x27;李军&#x27;,&#x27;男&#x27;,&#x27;1976-02-20&#x27;,&#x27;95033&#x27;);insert into students values(109,&#x27;王芳&#x27;,&#x27;女&#x27;,&#x27;1975-02-10&#x27;,&#x27;95031&#x27;);insert into students values(108,&#x27;曾华&#x27;,&#x27;男&#x27;,&#x27;1977-09-01&#x27;,&#x27;95033&#x27;);insert into students values(103,&#x27;陆君&#x27;,&#x27;男&#x27;,&#x27;1974-06-03&#x27;,&#x27;95031&#x27;);#把曾华性别改为女UPDATE students SET stu_sex=&#x27;女&#x27; WHERE stu_name=&#x27;曾华&#x27;;#建表teachers#教师编号（主键），姓名（不为空），性别（不为空），#生日（t_birth），职称(t_prof)，系别(t_depart)CREATE TABLE teachers(t_id INT(255) PRIMARY KEY,t_name VARCHAR(255) NOT NULL,t_sex VARCHAR(255) NOT NULL,t_birth date,t_prof VARCHAR(255),t_depart VARCHAR(255));insert into teachers values(804,&#x27;李诚&#x27;,&#x27;男&#x27;,&#x27;1985-12-02&#x27;,&#x27;副教授&#x27;,&#x27;计算机系&#x27;);insert into teachers values(856,&#x27;张旭&#x27;,&#x27;男&#x27;,&#x27;1969-03-12&#x27;,&#x27;讲师&#x27;,&#x27;电子工程系&#x27;);insert into teachers values(825,&#x27;王萍&#x27;,&#x27;女&#x27;,&#x27;1972-05-05&#x27;,&#x27;助教&#x27;,&#x27;计算机系&#x27;);insert into teachers values(831,&#x27;刘冰&#x27;,&#x27;女&#x27;,&#x27;1977-08-14&#x27;,&#x27;助教&#x27;,&#x27;电子工程系&#x27;);#建表course#课程号（c_id，主键，vachar类型） 课程名（c_name varchar）,任课教师（c_tid  int）#任课教师字段设置外键，参考教师表的t_id字段insert into course values(&#x27;3-105&#x27;,&#x27;计算机导论&#x27;,825);insert into course values(&#x27;3-245&#x27;,&#x27;操作系统&#x27;,856);insert into course values(&#x27;6-166&#x27;,&#x27;数字电路&#x27;,856);insert into course values(&#x27;9-888&#x27;,&#x27;高等数学&#x27;,831);#建表scores#sc_stuid(外键，参考学生id，不为空)#sc_cid(外键，参考课程号，不为空)#sc_score(可以为空，分数保留1位小数)#sc_stuid和sc_cid联合主键insert into scores values(103,&#x27;3-245&#x27;,86);insert into scores values(105,&#x27;3-245&#x27;,75);insert into scores values(109,&#x27;3-245&#x27;,68);insert into scores values(103,&#x27;3-105&#x27;,92);insert into scores values(105,&#x27;3-105&#x27;,88);insert into scores values(101,&#x27;3-105&#x27;,64);insert into scores values(107,&#x27;3-105&#x27;,91);insert into scores values(108,&#x27;3-105&#x27;,78);insert into scores values(101,&#x27;6-166&#x27;,85);insert into scores values(107,&#x27;6-166&#x27;,79);insert into scores values(108,&#x27;6-166&#x27;,81);insert into scores values(109,&#x27;3-105&#x27;,50);#1.查询老师名和该老师带的课程名SELECT t_name,c_name FROM teachers,course WHERE t_id=c_tid;#2.查询修了“计算机导论”的所有学生的信息SELECT * FROM students,course,scores WHERE stu_id=sc_stuidAND sc_cid=c_id AND c_name=&#x27;计算机导论&#x27;;#3.查询95033班级的学生所选课程的平均分SELECT c_name,AVG(sc_score) FROM students,course,scores WHERE sc_stuid=stu_id AND c_id=sc_cidAND stu_class=&#x27;95033&#x27; GROUP BY c_name;#4.查询男生和女生分别的平均分SELECT stu_sex,AVG(IFNULL(sc_score,0)) FROM students,scoresWHERE stu_id=sc_stuid GROUP BY stu_sex;#5.求出总成绩最高的学生姓名SELECT stu_name,SUM(sc_score) FROM students,scores WHERE stu_id=sc_stuidGROUP BY stu_id ORDER BY SUM(sc_score) DESC LIMIT 0,1;#6.查询每个老师带了多少个学生 SELECT t_name,COUNT(*) FROM course,teachers,scores WHERE c_tid=t_idAND sc_cid=c_id GROUP BY t_name;#7.查询“曾华”选修的所有课程名SELECT c_name FROM students,scores,course WHERE stu_id=sc_stuidAND c_id=sc_cid AND stu_name=&#x27;曾华&#x27;;#8.查询李军有哪些课程没有选SELECT c_name FROM course WHERE c_name NOT in (SELECT c_name FROM students,course,scores WHERE sc_stuid=stu_idAND sc_cid=c_id AND stu_name=&#x27;李军&#x27;);#9.查询每个科目成绩最高的学生学号和姓名SELECT stu_id,stu_name,c_name FROM scores,students,course,(SELECT sc_cid AS sc_sub,MAX(sc_score) AS sc_max FROM scoresGROUP BY sc_cid) AS aWHERE stu_id=sc_stuid AND scores.sc_cid=a.sc_sub AND scores.sc_score=a.sc_maxAND sc_cid=c_id;#10.查询哪个学科最受女生喜欢SELECT c_name from students,scores,course WHEREc_id=sc_cid AND sc_stuid=stu_id AND stu_sex=&#x27;女&#x27; GROUP BY c_nameORDER BY COUNT(stu_id) DESC LIMIT 0,1;#11.查询讲师代课班级里成绩最低的是哪个班级SELECT stu_class FROM students,course,scores WHERE stu_id=sc_stuidAND c_id=sc_cid AND c_tid in (SELECT t_id FROM teachers WHERE t_prof=&#x27;讲师&#x27;) GROUP BY stu_class ORDER BY SUM(sc_score) LIMIT 0,1;#12.查询“1975年以后”出生的学生都选修的课程号和课程名SELECT c_id,c_name FROM course,students,scoresWHERE c_id=sc_cid AND stu_id=sc_stuid AND YEAR(stu_birth)&gt;1975GROUP BY c_id;\n\n","categories":["WEBbackend"],"tags":["office","mysql"]},{"title":"5.类的基本概念","url":"/2022/07/25/WebBackend/C#/5.%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","content":"类的概述类是一种活动的数据结构程序的数据和功能被组织为逻辑上相关的数据项和函数的封装集合，并成为类。\n类是一个能存储数据并执行代码的数据结构。它包含数据成员和函数成员：\n\n\n数据成员\t它存储与类或类的实例相关的数据。\n函数成员    代码执行\n\n\n\n声明类类型int、double和char由C#定义。但像Dealer和Player这样的类不是由语言定义，如果使用它们就必须通过编写类的声明来定义它们：\n\n\n类的名称；\n类的成员；\n类的特征。\n\n\n实例：\n关键字\t类名&#123;    成员声明&#125;class MyExcellentClss&#123;    ...&#125;\n\n类成员字段和方式是最重要的类成员类型。字段是数据成员，方法是函数成员。\nC#在类型的外部不能声明全局变量（也就是变量或字段）。所有的字段都属于类型，而且必须在类型声明内部声明。\n字段字段是隶属于类的变量：\n\n\n它可以是任意类型，无论是预定义类型还是用户定义类型。\n和所有变量一样，字段用来保存数据，并具有如下特征：\n可以被写入；\n可以被读取。\n\n\n\n\n实例：\n类型\t字段名称;Type  Identifier;//例如，下面的类包含字段MyField的声明，它可以保存int值：class MyClass&#123;    int MyField;//类型  字段名称&#125;\n\n\n显式和隐式字段初始化\n因为字段是一种变量所以和变量初始化语句相同：\n\n\n字段初始化语句是字段声明的一部分，由一个等号后面跟着一个求值表达式构成。\n\n初始化值必须是编译时可确定的：\nclass MyClass&#123;    int F1 = 17;//类型  字段名称  字段初始化值&#125;\n\n如果没有初始化语句，字段的值会被编译器设为默认值，默认值由字段的类型决定。如int初始化值为0，bool为false，string为null。\n\n\n\n\n声明多个字段\n方法与前一章相同，实例：\nint F1,F3 = 25;string F2,F4 = &quot;abcd&quot;;\n\n方法方法是具有名称的可执行代码块，可以从程序的很多不同地方执行，甚至从其他程序执行。\n当方法被调用（call&#x2F;invoke）时，它执行自己所含的代码，然后返回到调用它的代码并继续执行调用代码。有些方法返回一个值到它们被调用的位置。方法相当于C++中的成员函数。\nC#没有全局函数（方法）声明在类型声明的外部。C#方法没有默认的返回类型，所有方法必须包含返回类型或void\n声明方法最简语法包括以下组成部分。\n\n\n返回类型\t方法返回值的类型，如果方法不返回值，那么返回类型被指定void\n名称\t方法的名称\n参数列表\t至少有一对空的圆括号组成\n方法体\t由一对大括号组成，大括号包含执行的代码\n\n\n例如：\nclass SimpleClass&#123;    //返回类型\t方法名称  参数列表    void PrintNums()    &#123;        Console.WriteLine(&quot;1&quot;);        Console.WriteLine(&quot;2&quot;);    &#125;&#125;\n\n创建变量和类的实例一旦类被声明，就可以创建类的实例：\n\n\n类是引用类型\n数据的引用保存在一个类类型的变量中\n\n\n\n为数据分配内存声明类类型的变量所分配的内存是用来保存引用的，而不是用来保存类对象实际数据的。需要使用new运算符为实际数据分配内存：\n\n\nnew运算符为任意指定类型的实例分配并初始化内存。他依据类型的不同从栈或堆里分配。\n\n使用new运算符组成一个对象创建表达式，他的组成如下：\n\n关键字 new；\n\n需要分配的内存实例的类型名称；\n\n成对的圆括号，可以是空值\n\n\n\n\n如果将内存分配一个引用类型（变量），则对象创建表达式返回一个引用，指向在堆中被分配并初始化的对象实例。\n\n\n\n实例：\nDealer theDealer;\t//声明引用对象theDealer = new Dealer();\t//为类对象分配内存并赋值给变量//合并Dealer theDealer = new Dealer();\t//声明并初始化\n\n\n实例成员类声明相当于蓝图，通过这个蓝图创建多少个类的实例都可以。\n\n\n实例成员\t类的每个实例都是不同的实体，它们有自己的一组数据成员，因为这些数据成员都和类的实例相关，所以被称为实例成员。\n静态成员\t实例成员是默认类型，但也可以声明与类而不是实例相关的成员，称为静态成员。\n\n\n实例：\nclass Dealer &#123; ... &#125;\t//声明类class Player\t\t\t//声明类&#123;    string Name;\t\t//字段    ...&#125;class Program&#123;    static void Main()    &#123;        Dealer theDealer = new Dealer();        Player player1 = new Player();        Player player2 = new Player();        Player player3 = new Player();        ...    &#125;&#125;\n\n\n访问修饰符从类的内部，任何函数成员都可以使用成员的名称访问类中任意的其他成员。\n访问修饰符成员声明的可选部分。下面是字段和方法声明的语法：\n字段    访问修饰符 类型 标识符;方法    访问修饰符 返回类型 方法名()&#123;    ...&#125;\n\n5种成员访问控制如下：\n\n\n私有的（private）\n公有的（public）\n受保护的（protected）\n内部的（internal）\n受保护内部的（protected internal）\n\n\n私有访问和公有访问私有成员只能从声明它的类的内部访问，其他的类看不见或者无法访问它们。\n\n\n私有访问是默认访问级别\n\n可以将private访问修饰符显式地将一个成员声明为私有。例如：\n\t   int MyInt1;\t\t//隐式声明为私有private int MyInt2;\t\t//显式声明为私有\n\n\n\n公有访问和私有访问图示\n\n\n成员访问示例\nclass C1&#123;    int   F1;\t\t\t\t//隐式私有字段    private int F2;\t\t\t//显式私有字段    public int F3;\t\t\t//公有字段        void DoCalc()\t\t\t//隐式私有方法    &#123;        ...    &#125;    public int GetVal()\t\t//公有方法    &#123;        ...    &#125;&#125;\n\n\n\n从类的内部访问成员即使字段和两个方法被声明为private，类的所有成员还是可以被类的任何方法（或任何函数成员）访问。\nclass DaysTemp&#123;    //字段    private int High = 75;    private int Low = 45;        //方法    private int GetHigh()    &#123;        return High;\t\t//访问私有字段    &#125;    private int GetLow()    &#123;        return Low;    &#125;    public float Average()    &#123;        returm(GetHigh() + GetLow()) /2;   //访问自由方法    &#125;&#125;\n\n从类的外部访问成员要从类的外部访问实例成员，必须包括变量名称和成员名称，中间用句点（.）分隔。这称为点运算符（dot-syntax notation）。实例：\nDaysTemp myDt = new DaysTemp();\t\t//创建类的对象float fValue = myDt.Average();\t\t//从外部访问,myDt变量名称，Average成员名称class DaysTemp\t\t//声明类DaysTemp&#123;    public int High = 75;    public int Low = 45;&#125;class Program\t\t//声明类Program&#123;    static void Main()    &#123;        DaysTemp temp = new DaysTemp();\t\t//创建对象        temp.High = 85;\t\t\t//tmp.high字段名称和字段，字段赋值        temp.Low = 60;                Console.WriteLine(&quot;High &#123;0&#125;&quot;,temp.High);\t\t//读取字段值        Console.WriteLine($&quot;Low: &#123;temp.Low&#125;&quot;);    &#125;&#125;\n\n综合应用class DaysTemp\t//声明类&#123;    public int High, Low;\t//声明实例字段    public int Average()    &#123;        returm (High + Low) / 2;    &#125;        class Program    &#123;        static void Main()        &#123;            //创建两个DaysTemp实例            DaysTemp t1 = new DaysTemp();            DaysTemp t2 = new DaysTemp();                      \t//给字段赋值            t1.High = 76;\tt1.Low = 57;            t2.High = 75;\tt2.Low = 53;                        //读取字段值            //调用实例方法            Console.WriteLine(&quot;t1: &#123;0&#125; &#123;1&#125; &#123;2&#125;&quot;, t1.High, t1.Low, t1.Average() );            console.WriteLine(&quot;t2: &#123;0&#125; &#123;1&#125; &#123;2&#125;&quot;, t2.High, t2.Low, t2.Average() );        &#125;    &#125;&#125;\n\n\n","categories":["C#/.NET"],"tags":["c#"]},{"title":"C#","url":"/2022/07/13/WebBackend/C#/C#/","content":"1 .NET框架\n.NET框架由三部分组成：\n\n编程工具：包括Visual Studio集成开发环境，调试器，.NET兼容的编译器等\nCLR（Common Language Runtime，公共语言运行库）：在运行时管理程序的执行，包括内存管理和垃圾收集、代码安全验证、代码执行线程管理及异常处理等\nBCL（Base Class Library，基类库）：包括通用基础类（文件操作、字符串操作等相关的类）、集合类（列表、字典、散列表）、线程和同步类、XML类。\n\n以下图片说明了3个用不同语言编写的程序的完整编译时和运行的过程\n\nNET框架\n2. C#编程概述\n一个简单的C#程序，这段程序会输出“Hi there！”\n//告诉编译器这个程序使用了System命名空间的类型\nusing System;\n//声明一个新命名空间，名称为Simple\nnamespace Simple&#123;\n    class Program&#123;\n        static void Main()&#123;\n            Console.WriteLine(&quot;Hi there!&quot;)\n        &#125;\n    &#125;\n&#125;\nCopy\n在C#中，WirteLine相当于java中的println，Write相当于java中的print\nConsole.WriteLine(&quot;Three integers are &#123;1&#125;, &#123;0&#125; and &#123;1&#125;.&quot;, 3, 6);\nCopy\n以上语句将在屏幕上显示：\nThree integers are 6, 3 and 6.\n类型存储和变量\n命名空间是一种把相关的类型声明分组并命名的方法。既然程序是一组相关的类型声明，那么通常会把程序声明在你创建的命名空间内部。\n预定义类型\nC#提供了16种预定义类型，包括13种简单类型和3种非简单类型\n简单类型：\n| 名称 | 含义 |\n| ———– | ———– |\n| int | 32位有符号整数 |\n| uint | 32位无符号整数 |\n| long | 64位有符号整数 |\n| ulong | 62位无符号整数 |\n| short | 16位有符号整数 |\n| ushort | 16位无符号整数 |\n| byte | 8位有符号整数 |\n| sbyte | 8位无符号整数 |\n| float | 单精度浮点数 |\n| double | 双精度浮点数 |\n|decimal|高精度小数类型|\n| bool | 布尔型 |\n| char | Unicode字符串 |\n非简单类型：\n\nobject：所有其他类的基类\nstring：多个Unicode字符组成的序列\ndynamic：在使用动态语言编写的程序集时使用\n\nC#语言是静态的，但基于.NET的一些其他语言却是动态的，也就是说变量的类型直到运行时才会被解析。由于它们是.NET语言，所以C#程序需要使用这些语言编写的程序集。问题是程序集中的类型直到运行时才会被解析，而C#又要引用这样的类型并且需要在编译的时候解析类型。为了解决这个问题，有了dynamic关键字。\n在编译时，编译器不会对dynamic类型的变量进行类型检查。相反，它将与该变量及该变量的操作有关的所有信息打包。在运行时会对这些信息进行检查，以确保它与变量所代表的实际类型保持一致性，否则将在运行时抛出异常。\n用户定义类型\nC#中有6种用户自定义类型\n\n类类型class\n结构类型struct\n数组类型array\n枚举类型enum\n委托类型delegate\n接口类型interface\n\n3. 方法\n类型推断和var关键字\nvar关键字不是特定类型变量的符号，它是从等号右边推断出的实际类型的速记。\n//在下面的第一个声明中，var是int的速记\n//第二个声明中，var是MyExcellentClass的速记\nstatic void Main()&#123;\n    var total = 15;  \n    var mec = new MyExcellentClass();\n&#125;\nCopy\n使用var关键字有一些重要的条件：\n\n只能用于本地变量，不能用于字段\n只能在变量声明中包含初始化的时候使用\n一旦编译器推断出变量的类型，它就是固定且不能更改的\n\n本地常量\n用const修饰符来修饰（类似于java中的final）\n常量和变量的语法除了以下两点外都相同：\n\n常量在类型之前增加关键字const\n常量必须有初始化语句，也就是说初始值不能在编译期确定。因此，它不能是某个对象的引用（但可以是null的引用），因为对象的引用是在运行时决定的。\n\n参数\n首先区分下形参和实参的概念：\n//以下函数的参数声明中，x和y均为形参\npublic void PrintSum(int x, float y)&#123;\n\n&#125;Copy&#x2F;&#x2F;以下函数的调用中，5和someInt均为实参,实参的值用于初始化形参PrintSum(5, someInt)&#123;\n&#125;Copy\n1.值参数\nJava中的参数传递类型（值传递），即：值参数是把实参的值复制给形参，二者在栈中的不同位置。\n\n在方法被调用前，用作实参的变量a2已经在栈中了\n在方法开始时，系统在栈中为形参分配空间，并从实参复制值\n\n因为a1是引用类型，所以a1的值（即指向对象的地址）被复制，形参和实参都指向堆中的同一个对象\n因为a2是值类型的，所以值被复制，产生了一个独立的数据项\n\n在方法中，f2和对象f1的字段都被加上了5\n方法结束后，形参从栈中弹出\n\n\n值参数\n2.引用参数\n对于引用参数，系统不会在栈中为形参分配新的空间，形参的参数名将作为实参的别名，指向相同的内存位置\n\n使用引用参数时，必须在方法的声明和调用中都使用ref修饰符\n实参必须是变量，在用作实参前必须被赋值\n\n//方法声明中要使用ref修饰符\nvoid MyMethod(ref int val)&#123;\n\n&#125;\nint y &#x3D; 1;MyMethod(ref y)   &#x2F;&#x2F;使用y前必须赋值MyMethod(ref 3 + 5)   &#x2F;&#x2F;会报错，因为引用参数作为实参必须是变量，不能是表达式Copy\n\n在方法调用前，将要被用作实参的变量a1和a2已经在栈里了\n在方法的开始，形参名被设置为实参的别名。引用相同的内存位置\n在方法结束后，f2和f1的对象的字段都被加上了5\n\n\n引用参数\n对比将引用类型对象作为值参数和引用参数传递的两种情况：\n\n将引用类型对象作为值参数传递：如果在方法内创建一个对象并赋值给形参，将切断形参和实参之间的关联，并且在方法调用结束后，新对象将不复存在\n将引用类型对象作为引用参数传递：如果在方法内创建一个新对象并赋值给形参，会让实参也引用该新对象，并且在方法结束后该对象仍然存在。\n\n3.输出参数\n输出参数用于从方法体内把数据传出到调用代码，修饰符为out。和引用参数非常类似\n和引用参数一样，输出参数的形参担当实参的别名，方法内对形参的任何改变在方法完成后通过实参变量都是可见的。\n唯一和引用参数不同的是：方法内的代码在读取输出参数之前必须先对其写入\npublic void Add(out int outValue)&#123;\n    //以下这句会报错，因为输出参数outValue在方法中被读取前没有被赋值\n    int var1 = outValue + 2;\n&#125;\nCopy\n4.参数数组\n参数数组允许0个或多个实参对应一个特殊的形参,修饰符为params\n//形参inVals可以代表0个或多个实参\nvoid ListInts(params int[] inVals)&#123;\n\n&#125;Copy\n\n在参数列表中只能有一个参数数组，并且是列表中的最后一个\n由参数数组表示的所有参数必须具有相同的类型\n\n参数数组在方法声明中需要params修饰符，而在调用时不需要（不同于引用参数和输出参数，它们在以上两个地方都需要修饰符）\n可以有如下两种方式为参数数组提供实参：\n\n\n用一个逗号分隔的该数据类型元素的列表,使用这种方法时，编译器做如下的事：\n\n\n接收实参列表，用它们在堆中创建并初始化一个数组\n\n\n把数组的引用作为形参保存在栈中\nListInts(10, 20, 30)\nCopy\n\n\n\n\n用数组作为实参\n在这种情况下，编译器会直接使用传入的数组，也就是说栈中的形参指向内存中intArray的位置\nint[] intArray = &#123;1, 2, 3&#125;;\nListInts(intArray);\nCopy\n5.命名参数\n在使用命名参数时，需要在方法调用中包含参数名。而方法的声明无需任何改变\nclass MyClass&#123;\n   //方法中的参数声明一如平常\n   public int Calc(int a, int b, int c)&#123;\n       return a + b + c;\n   &#125;\n   static void Main()&#123;\n       MyClass mc = new MyClass();\n       int result = mc.Calc(c: 2, a: 4, b: 3);\n   &#125;\n&#125;\nCopy\n6.可选参数\n所谓可选参数就是在调用方法的时候可以包含这个参数，也可以忽略它。\nclass MyClass&#123;\n   //b为可选参数，默认值为3\n   public int Calc(int a, int b = 3)&#123;\n       return a + b;\n   &#125;\n   static void Main()&#123;\n       MyClass mc = new MyClass();\n       int ro = mc.Calc(5, 6);\n       int r1 = mc.Calc(5);\n       Console.WriteLine(\"&#123;0&#125;, &#123;1&#125;\", ro, r1);\n   &#125;\n&#125;\nCopy\n上述代码会输出11，8\n\n\n只要值类型的默认值在编译的时候可以确定，就可以使用值参数作为可选参数。而只有在默认值为null的时候，引用参数才可以作为可选参数。\n总结下来，一个方法的声明中，参数要按照必填参数、可选参数、params参数的先后顺序声明。\n可以忽略最后一个可选参数，或者最后n个可选参数，但是不可以随机选择省略任意的可选参数，省略必须从最后开始。\n参数类型总结：\n\n\n\n参数类型\n修饰符\n是否在声明时使用\n是否在调用是使用\n执行\n\n\n\n\n值参数\n无\n\n\n系统把实参的值复制给形参，二者在栈中位置不同\n\n\n引用参数\nref\n是\n是\n形参是实参的别名，二者在栈中位置相同\n\n\n输出参数\nout\n是\n是\n在读取输出参数前必须对其写入，除此之外和引用参数类似\n\n\n参数数组\nparams\n是\n否\n允许传递可变数目的实参到方法\n\n\n\n栈帧\n在调用方法的时候，内存从栈的顶部开始分配，保存和方法关联的一些数据项。这块内存叫做方法的栈帧\n栈帧保存如下的内容：\n\n\n返回地址\n\n\n为参数分配的内存\n\n\n各种和方法调用相关的其他管理数据项\n在方法调用的时候，整个栈帧都会压入栈。在方法退出的时候，整个栈帧都会从栈上弹出。\n\n\n\n栈帧\n4.类\n类成员包括数据成员（保存数据）和函数成员（执行代码）\n其中数据成员包括：\n\n字段\n常量（用const修饰，包括本地常量和成员常量，本地常量声明在方法内，成员常量声明在类中）\n\n常量\n成员常量表现的和静态量相似，但唯一不同的是，成员常量没有自己的存储位置，而是在编译时被编译器替换。此外，不能将成员常量声明为static。与const有着相同作用的是readonly，不同的是，const字段只能在字段的声明语句中初始化，而readonly也可以在构造函数中初始化。因此const字段的值必须在编译时确定，而randonly字段的值可以在运行时决定。\n函数成员包括：\n\n方法\n属性\n构造函数、析构函数\n运算符\n索引\n事件\n\n属性\n属性是一组称为访问器的方法（set访问器为属性赋值，get访问器从属性中获取值）。它是类中的函数成员，因此不需为属性分配内存。\n写入和读取属性的代码和访问字段一样。属性会根据是写入还是读取，来隐式地调用适当的访问器\n属性通常和字段关联，一种常见的方式是在类中将字段声明为private以封装字段，并声明一个public属性用get和set访问器来控制对该字段的访问。和属性关联的字段成为后备字段\nclass C1&#123;\n    private int TheRealValue = 10;   //后备字段：分配内存\n    public int MyValue&#123;              //属性：不分配内存\n        set&#123;\n            TheRealValue = value;    //设置字段的值\n        &#125; \n        get&#123;\n            return TheRealValue;     //获取字段的值\n        &#125;\n    &#125;\n&#125;\n\nclass Program&#123;    static void Main()&#123;        &#x2F;&#x2F;对属性的读和写如同对字段的读和写        C1 c &#x3D; new C1();        Console.WriteLine(&quot;MyValue: &#123;0&#125;&quot;, c.MyValue);\n    c.MyValue = 20;\n    Console.WriteLine(&amp;quot;MyValue: &#123;0&#125;&amp;quot;, c.MyValue);\n&#125;\n\n}Copy\n此外，属性也可以只有get访问器（只读属性），或者只有set访问器（只写属性）\nclass RightTriangle&#123;\n    public double A = 3;\n    public double B = 4;\n    //只读属性，计算直角三角形的第三边\n    public double Hypotenuse&#123;\n        get&#123;\n            return Math.Sqrt((A * A) + (B * B));\n        &#125;\n    &#125;\n&#125;\n\nclass Program&#123;    static void Main()&#123;        RightTriangle c &#x3D; new RightTriangle();        Console.WriteLine(&quot;Hypotenuse: &#123;0&#125;&quot;, c.Hypotenuse);    &#125;&#125;\n上述代码将输出5Copy\n索引器\n可以认为索引器是为类的多个数据成员提供get和set访问器的属性。\nclass Class1&#123;\n    private int Temp0;\n    private int Temp1;\n    //和属性不同的是，索引器有参数（索引参数），并且使用this而不是名称\n    //索引器声明\n    public int this [int index]&#123;    \n        get&#123;\n            return (index == 0) ? Temp0 : Temp1;\n        &#125;\n        set&#123;\n            if(index == 0)\n                Temp0 = value;   //value为set访问器的隐式变量\n            else\n                Temp1 = value;\n        &#125;\n    &#125;\n&#125;\n\nclass Example&#123;    static void Main()&#123;        Class1 a &#x3D; new Class1();        &#x2F;&#x2F;使用索引参数0或1读取数据成员        Console.WriteLine(&quot;T0: &#123;0&#125;, T1 : &#123;1&#125;&quot;, a[0], a[1]);        &#x2F;&#x2F;使用索引参数0或1对数据成员进行写入        a[0] &#x3D; 15;        a[1] &#x3D; 20;        Console.WriteLine(&quot;T0: &#123;0&#125;, T1 : &#123;1&#125;&quot;, a[0], a[1]);    &#125;&#125;\n以上代码会输出：T0: 0, T1: 0T0: 15, T1: 20Copy\n5.继承\n如果类OtherClass继承自SomeClass，则应按如下表示\nclass OtherClass : SomeClass&#123;\n&#125;\nCopy\n一个类只能继承自一个基类，所有的类都是Object类的派生类\n屏蔽基类的成员\n虽然派生类不能删除它继承的任何成员，但可以用与基类成员名称相同的成员来屏蔽基类成员（如果是函数成员，则要求签名相同，签名指名称和参数列表，不包括返回类型）。此外还要使用new修饰符来告诉编译器我正在故意屏蔽继承的成员。\n另外，即使派生类屏蔽了基类的成员，也可以使用基类访问表达式访问隐藏的继承成员。\nclass SomeClass&#123;    //基类\n    public string Field1 = &quot;Field1--In the base class&quot;;\n&#125;\nclass OtherClass : SomeClass&#123;    //派生类\n    //使用new修饰符隐藏基类中的Field1字段\n    new public string Field1 = &quot;Field1--In the derived class&quot;;\n    public void PrintField1()&#123;\n        //访问派生类中的Field1，会输出&quot;Field1--In the derived class&quot;\n        Console.WriteLine(Field1);   \n        //使用基类访问来访问基类中的Field1，会输出&quot;Field1--In the base class&quot; \n        Console.WriteLine(base.Field1); \n    &#125;\n&#125;\nCopy\n使用基类的引用\nMyDerivedClass derived = new MyDerivedClass();   //创建一个派生类对象\nMyBaseClass mybc = (MyBaseClass)derived;        //让基类引用指向派生类对象\nCopy\n对于如上代码，派生类的引用derived可以看到完整的MyDerivedClass对象，而基类引用mybc只能看到对象的MyBaseClass部分（只能看到基类成员）\n\n使用基类的引用\n另外，也可以使用基类引用调用派生类的方法，但要满足如下条件：\n\n派生类的方法和基类方法有着相同的签名和返回类型\n基类的方法用virtual标注\n派生类的方法用override标注\n在这种情况下，当使用基类引用（mybc）调用方法时，方法会被传递到派生类执行\n\n注意：\n\n覆写（override）和被覆写的方法应该有相同的访问性\n不能覆写static方法和非虚（virtual）方法\n\n当使用对象的基类引用调用一个覆写的方法时，方法的调用被沿着派生层次上溯执行，一直到标记为override的方法的最高派生版本。\n如果在更高派生级别有该方法的其他声明，但没有被标记为override，那么它们不会被调用。\n构造函数\n构造函数初始化语句\n两种形式：\n\n关键字base：指明使用哪一个基类的构造函数\n关键字this：指明使用哪一个当前类的构造函数\n以下构造函数使用了构造函数初始化语句，构造函数初始化语句指明了要使用第一个参数是string，第二个参数是int型的那个基类构造函数\n\n当声明一个不带构造函数初始化语句的构造函数时，它实际上是使用了无参数的基类构造函数。\npublic MyDerivedClass(int x, string s) : base(s, x)&#123;\n\n&#125;Copy\n如下代码中的MyClass类包含一个有一个int型参数的构造函数，这个构造函数使用了同一个类中具有两个参数的构造函数，并为第二个参数提供了一个默认值\npublic MyClass(int x) : this(x, &quot;Using Default String&quot;)&#123;\n\n&#125;Copy\n如果一个类有好几个构造函数，并且它们都需要在构造对象的过程中执行一些公共代码。这时可以把公共代码提取出来作为一个构造函数，被其他所有的构造函数作为构造函数初始化语句使用。\n访问级别\n类有两种访问级别：\n\npublic：可以被任何程序集中的代码访问\ninternal：默认的访问级别，仅可以被自己所在的程序集中的类看到\n\n类中的成员有5种访问级别：\n\n私有的（private）：只能被自己类中的成员访问，不能被其他的类访问，即使是继承自它的类也不行\n公有的（public）：所有的类都可以自由访问\n受保护的（protected）：和private类似，唯一不同的是，它允许该类的派生类来访问\n内部的（internal）：对程序集内部的所有类可见，对程序集外部的所有类不可见\n受保护内部的（protected internal）：相当于internal与protected的并集，即对程序集内部的类可见，也对继承自该类的类可见。\n\n抽象成员\n类似于Java中的抽象方法。它使用abstract标记，并且必须是函数成员（方法、属性、事件、索引）。不能有实现代码块，抽象成员的实现用分号表示。即每一个抽象成员的声明后都要带一个分号\n如：以下声明了两个抽象成员，一个名为PrintStuff的抽象方法和一个名为MyProperty的抽象属性\nabstract public void PrintStuff(string s);\nabstract public int MyProperty&#123;\n    get;    //分号代替实现\n    set;\n&#125;\nCopy\n\n抽象类：只能被继承，不能用来创建实例，用abstract修饰符标注\n密封类：与抽象类相反，只能被用来创建实例，不能被继承。用sealed修饰符标注\n\n语句\n操作符重载\n如果面对一个用户自定义的类或结构，运算符就会不知道如何取处理它。运算符重载允许用户自己定义C#运算符来操作自定义类型的操作数。\n\n为类或结构重载一个运算符x，可以声明一个名称为operator x的方法并实现它的行为（如operator +和operator -等）。一元运算符的重载方法带有一个单独的class或struct类型的参数，二元运算符重载的方法带有两个参数，其中至少有一个是class或struct类型。\n声明必须同时使用static和public的修饰符\n运算符必须要是要操作的类或结构的成员\n\n如下代码声明了LimitedInt类的两个重载的运算符：一个是加运算符，另一个是取负运算符\nclass LimitedInt Return&#123;\n    public static LimitedInt operator + (LimitedInt x, double y)&#123;\n        LimitedInt li = new LimitedInt();\n        li.TheValue = x.TheValue + (int)y;\n        return li;\n    &#125;\n\npublic static LimitedInt operator - (LimitedInt x)&#123;\n    LimitedInt li = new LimitedInt();\n    li.TheValue = 0;\n    return li;\n&#125;\n\n}Copy\n标签语句\n标签语句由一个标识符后面跟着一个冒号再跟着一条语句组成，它有如下的形式：Identifier: Statement。这条语句在执行时与只有Statement的语句相同，加一个标签的目的只是为了允许程序从其他位置跳转到这个标签所在的位置。\n\n因为标签有自己的声明空间，所以标签语句中的标识符可以是任意有效的标识符（可以与本地变量名相同）。\n标签的作用域仅在块内部\n\ngoto语句可以跳到它本身所在的块中的任何标签语句，或跳出到任何它被嵌套的块内的标签语句。goto Indentifier\n数组\n一维数组和矩形数组\nint[] intArr1 = new int[15];   //声明一维数组\nint[,] intArr2 = new int[5, 10];  //声明二维数组\nint var2 = intArr[2, 3];      //从二维数组中读值\n\nint[] intArr &#x3D; new int[]&#123;10, 20, 30, 40&#125;;   &#x2F;&#x2F;初始化一维数组int[,] intArr2 &#x3D; new int[,]&#123;&#123;0, 1, 2&#125;, &#123;10, 11, 12&#125;&#125;; &#x2F;&#x2F;初始化二维数组Copy\n交错数组\n交错数组是数组的数组，与矩阵数组不同，交错数组的子数组的元素个数可以不同\n//实例化顶层数组，不能在声明语句中初始化顶层数组之外的数组长度\nint[][] Arr = new int[3][];  \n//实例化子数组\nArr[0] = new int[]&#123;1,2,3&#125;;\nArr[1] = new int[]&#123;4,5,6&#125;;\nArr[2] = new int[]&#123;7,8,9&#125;;\nCopy\nforeach语句\n注意：迭代变量item是只读的，不能修改。\nint[] arr1 = new int[]&#123;1,2,3&#125;;\nforeach(int item in arr1)\n    Console.WriteLine(&quot;Item Value: &#123;0&#125;, item&quot;);","categories":["C#/.NET"],"tags":["c#"]},{"title":"C#委托","url":"/2022/02/19/WebBackend/C#/%E5%A7%94%E6%89%98/","content":"什么是委托C# 中的委托（Delegate）类似于C或C++中函数的指针。委托（Delegate）是存在对某个方法的引用的一种引用类型变量。引用可在运行时被改变。\n委托（Delegate）特别用于现实事件和回调方法。所有的委托（Delegate）都派生自Sysetem.Delegate类。\n声明委托 （Delegate）委托声明决定了可由该委托引用的方法。委托可只想一个与其具有相同标签的方法。\n例如，假设有一个委托：\npublic delegate int MyDelegate (string s);\n\n上面的委托可被用于引用任何一个带有一个单一的string参数的方法，并返回一个int类型变量。\n声明委托的语法如下：\ndelegate &lt;return type&gt; &lt;delegate-name&gt; &lt;parameter list&gt;\n\n实例化委托（Delegate）一旦声明了委托类型，委托对象必须使用new关键字来创建，且与一个特定的方法有关。当创建委托时，传递到new语句的参数就像方法调用一样书写，但是不带有参数。例如：\npublic delegate void printString(string s);...printString ps1 = new printString(WriteToScreen);printString ps2 = new printString(WriteToFile);\n\n下面的实例演示了委托的声明、实例化和使用，该委托可用于引用带有一个整型参数的方法，并返回一个整型值。\nusing System;delegate int NumberChanger(int n);namespace DelegateAppl&#123;   class TestDelegate   &#123;      static int num = 10;      public static int AddNum(int p)      &#123;         num += p;         return num;      &#125;      public static int MultNum(int q)      &#123;         num *= q;         return num;      &#125;      public static int getNum()      &#123;         return num;      &#125;      static void Main(string[] args)      &#123;         // 创建委托实例         NumberChanger nc1 = new NumberChanger(AddNum);         NumberChanger nc2 = new NumberChanger(MultNum);         // 使用委托对象调用方法         nc1(25);         Console.WriteLine(&quot;Value of Num: &#123;0&#125;&quot;, getNum());         nc2(5);         Console.WriteLine(&quot;Value of Num: &#123;0&#125;&quot;, getNum());         Console.ReadKey();      &#125;   &#125;&#125;当上面的代码被编译和执行时，它会产生下列结果：Value of Num: 35Value of Num: 175委托的多播（Multicasting of a Delegate）委托对象可使用 &quot;+&quot; 运算符进行合并。一个合并委托调用它所合并的两个委托。只有相同类型的委托可被合并。&quot;-&quot; 运算符可用于从合并的委托中移除组件委托。使用委托的这个有用的特点，您可以创建一个委托被调用时要调用的方法的调用列表。这被称为委托的 多播（multicasting），也叫组播。下面的程序演示了委托的多播：实例using System;delegate int NumberChanger(int n);namespace DelegateAppl&#123;   class TestDelegate   &#123;      static int num = 10;      public static int AddNum(int p)      &#123;         num += p;         return num;      &#125;      public static int MultNum(int q)      &#123;         num *= q;         return num;      &#125;      public static int getNum()      &#123;         return num;      &#125;      static void Main(string[] args)      &#123;         // 创建委托实例         NumberChanger nc;         NumberChanger nc1 = new NumberChanger(AddNum);         NumberChanger nc2 = new NumberChanger(MultNum);         nc = nc1;         nc += nc2;         // 调用多播         nc(5);         Console.WriteLine(&quot;Value of Num: &#123;0&#125;&quot;, getNum());         Console.ReadKey();      &#125;   &#125;&#125;\n\n委托（Delegate）的用途下面的实例演示了委托的用法。委托 printString 可用于引用带有一个字符串作为输入的方法，并不返回任何东西。\n我们使用这个委托来调用两个方法，第一个把字符串打印到控制台，第二个把字符串打印到文件：\nusing System;using System.IO;namespace DelegateAppl&#123;   class PrintString   &#123;      static FileStream fs;      static StreamWriter sw;      // 委托声明      public delegate void printString(string s);      // 该方法打印到控制台      public static void WriteToScreen(string str)      &#123;         Console.WriteLine(&quot;The String is: &#123;0&#125;&quot;, str);      &#125;      // 该方法打印到文件      public static void WriteToFile(string s)      &#123;         fs = new FileStream(&quot;c:\\\\message.txt&quot;, FileMode.Append, FileAccess.Write);         sw = new StreamWriter(fs);         sw.WriteLine(s);         sw.Flush();         sw.Close();         fs.Close();      &#125;      // 该方法把委托作为参数，并使用它调用方法      public static void sendString(printString ps)      &#123;         ps(&quot;Hello World&quot;);      &#125;      static void Main(string[] args)      &#123;         printString ps1 = new printString(WriteToScreen);         printString ps2 = new printString(WriteToFile);         sendString(ps1);         sendString(ps2);         Console.ReadKey();      &#125;   &#125;&#125;\n\n","categories":["C#/.NET"],"tags":["c#"]},{"title":"C#高级","url":"/2022/02/19/WebBackend/C#/C#%E9%AB%98%E7%BA%A7/","content":"封装把一个，或者多个项目，封闭在一个物理，或者逻辑的包中。\nC#封装 ，可以设置访问权限，通过访问修饰符来实现。\n访问修饰符，定义一个类成员的范围和可见性。\nC#支持的访问修饰符：\n\npublic : 所有对象都可以访问\nprivate ：对象本身在内部可以访问\nprotected : 这类，及其子类可以访问。\ninternal : 同一程序集的对象可以访问。\nprotected internal : 当前程序集，或派生自包括类的类型。\n\n\n结构体（Struct）在 C# 中，结构体是值类型数据结构。它使得一个单一变量可以存储各种数据类型的相关数据。struct 关键字用于创建结构体。\nusing System;using System.Text;struct Books&#123;    public string title;    public string author;    public string subject;    public int book_id;&#125;;public class testStructure&#123;    public static void Main(string[] args)    &#123;      Books Book1;        /* 声明 Book1，类型为 Books */      Books Book2;        /* 声明 Book2，类型为 Books */      /* book 1 详述 */      Book1.title = &quot;C Programming&quot;;      Book1.author = &quot;Nuha Ali&quot;;      Book1.subject = &quot;C Programming Tutorial&quot;;      Book1.book_id = 6495407;      /* book 2 详述 */      Book2.title = &quot;Telecom Billing&quot;;      Book2.author = &quot;Zara Ali&quot;;      Book2.subject =  &quot;Telecom Billing Tutorial&quot;;      Book2.book_id = 6495700;      /* 打印 Book1 信息 */      Console.WriteLine(&quot;Book 1 title : &#123;0&#125;&quot;, Book1.title); //&#123;0&#125;是占位符 用于格式化输出字符串      Console.WriteLine(&quot;Book 1 author : &#123;0&#125;&quot;, Book1.author);      Console.WriteLine(&quot;Book 1 subject : &#123;0&#125;&quot;, Book1.subject);      Console.WriteLine(&quot;Book 1 book_id :&#123;0&#125;&quot;, Book1.book_id);      /* 打印 Book2 信息 */      Console.WriteLine(&quot;Book 2 title : &#123;0&#125;&quot;, Book2.title);      Console.WriteLine(&quot;Book 2 author : &#123;0&#125;&quot;, Book2.author);      Console.WriteLine(&quot;Book 2 subject : &#123;0&#125;&quot;, Book2.subject);      Console.WriteLine(&quot;Book 2 book_id : &#123;0&#125;&quot;, Book2.book_id);            Console.ReadKey();    &#125;&#125;\n\n\n\n结构和类的区别：\n\n1、结构是值类型，它在栈中分配空间；而类是引用类型，它在堆中分配空间，栈中保存的只是引用。\n2、结构类型直接存储成员数据，让其他类的数据位于堆中，位于栈中的变量保存的是指向堆中数据对象的引用。\n\nC# 中的简单类型，如int、double、bool等都是结构类型。如果需要的话，甚至可以使用结构类型结合运算符运算重载，再为 C# 语言创建出一种新的值类型来。\n由于结构是值类型，并且直接存储数据，因此在一个对象的主要成员为数据且数据量不大的情况下，使用结构会带来更好的性能。\n因为结构是值类型，因此在为结构分配内存，或者当结构超出了作用域被删除时，性能会非常好，因为他们将内联或者保存在堆栈中。当把一个结构类型的变量赋值给另一个结构时，对性能的影响取决于结构的大小，如果结构的数据成员非常多而且复杂，就会造成损失，接下来使用一段代码来说明这个问题。\n结构和类的适用场合分析：\n\n1、当堆栈的空间很有限，且有大量的逻辑对象时，创建类要比创建结构好一些；\n2、对于点、矩形和颜色这样的轻量对象，假如要声明一个含有许多个颜色对象的数组，则CLR需要为每个对象分配内存，在这种情况下，使用结构的成本较低；\n3、在表现抽象和多级别的对象层次时，类是最好的选择，因为结构不支持继承。\n4、大多数情况下，目标类型只是含有一些数据，或者以数据为主。\n\n枚举（Enum）枚举是一组命名整型常量。枚举类型是使用 enum 关键字声明的。C# 枚举是值类型。换句话说，枚举包含自己的值，且不能继承或传递继承。\nusing System;public class EnumTest&#123;    enum Day &#123; Sun, Mon, Tue, Wed, Thu, Fri, Sat &#125;;    static void Main()    &#123;        int x = (int)Day.Sun;        int y = (int)Day.Fri;        Console.WriteLine(&quot;Sun = &#123;0&#125;&quot;, x);        Console.WriteLine(&quot;Fri = &#123;0&#125;&quot;, y);    &#125;&#125;\n\n继承继承允许我们根据一个类来定义另一个类，这使得创建和维护应用变得更容易，利于重用代码和节省开发时间。\n已有的类被称为 基类 ，这个新的类被称为 派生类。\n继承的思想实现了 属于 （IS-A）关系。例如，哺乳动物属于 （IS-A） 动物，狗属于 （IS-A）哺乳动物，因此狗 属于 （IS-A）动物。\n一、基类和派生类一个类可以派生自多个类或接口。\n语法：\n&lt;访问修饰符&gt; class &lt;基类/父类&gt;&#123;    ...&#125;class &lt;派生类/子类&gt; ; &lt;基类/父类&gt;&#123;    ...\n\n二、基类的初始化派生类继承了基类成员变量和成员方法，因此父亲对象应在子类对象创建之前创建。\n可以在 成员初始化列表 中进行父类的初始化。99\n三、C#多重继承多重继承指的是一个类别可以同时从多于一个父类继承行为与特征的功能。与单一继承相对，单一继承指一个类别只可以继承自一个父类。C# 不支持多重继承。但是可以使用接口实现多重继承。\nC# 多态性多态：一个接口多个功能。\n静态多态性：编译时发生函数响应（调用）；\n动态多态性：运行时发生函数响应。\n静态绑定（早期绑定）：编译时函数和对象的连接机制。 两种技术实现静态多态性：函数重载&#x2F;运算符重载。\n函数重载：在同一范围内对相同函数名有多个定义，可以是参数类型或参数个数的不同，但不许只有返回值类型不同。\n运算符重载：\n关键字 abstract 声明抽象类：用于接口部分类的实现（派生类继承抽象类时，实现完成）。抽象类包含抽象方法，抽象方法可被派生类实现。\n抽象类规则：\n\n1.不能创建抽象类的实例\n2.不能在抽象类外定义抽象方法\n3.不能把抽象类声明为sealed（类前带关键字sealed代表该类是密封类，不能被继承）\n\n关键字virtual声明虚方法:用于方法在继承类中的实现（在不同的继承类中有不同的实现）。\n抽象类和虚方法共同实现动态多态性。\n注：继承类中的重写虚函数需要声明关键字 override，在方法参数传入中写（类名 形参名）例如 public void CallArea(Shape sh)，意思是传入一个 shape 类型的类。\n","categories":["C#/.NET"],"tags":["c#"]},{"title":"Druid案例","url":"/2022/12/06/WebBackend/Java/Druid%E6%A1%88%E4%BE%8B/","content":"Druid（德鲁伊）是由阿里巴巴开发，集合了c3p0、dbcp、proxool等连接池的优点，加入了日志监控，有效的监控DB池连接和SQL的执行情况\n配置文件# druid.properties文件的配置driverClassName=com.mysql.cj.jdbc.Driverurl=jdbc:mysql://127.0.0.1:3306/mysqlusername=rootpassword=# 初始化连接数量initialSize=5# 最大连接数maxActive=10# 最大超时时间maxWait=3000\n\n实例USE sql2_wyg;DROP TABLE IF EXISTS tb_brand;CREATE TABLE tb_brand (  -- id 主键  id INT PRIMARY KEY AUTO_INCREMENT,  -- 品牌名称  brand_name VARCHAR(20),  -- 企业名称  company_name VARCHAR(20),  -- 排序字段  ordered INT,\t-- 描述信息  description varchar(100),  -- 状态:0 禁用，1 启用  status int);INSERT INTO tb_brand (\tbrand_name,\tcompany_name,\tordered,\tdescription,\t`status`)VALUES\t(&#x27;三只松鼠&#x27;, &#x27;三只松鼠股份有限公司&#x27;, 5, &#x27;好吃不上火&#x27;, 0),\t(&#x27;华为&#x27;, &#x27;华为技术有限公司&#x27;, 100, &#x27;华为致力于把数字世界带入每个人、每个家庭、每个组织，构建万物互联的智能世界&#x27;, 1),\t(&#x27;小米&#x27;, &#x27;小米科技有限公司&#x27;, 50, &#x27;are you ok&#x27;, 1);\tSELECT * FROM tb_brand;\n\n\n\npackage com.itheima.example;import com.alibaba.druid.pool.DruidDataSourceFactory;import com.itheima.pojo.Brand;import org.junit.Test;import javax.sql.DataSource;import java.io.FileInputStream;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.util.ArrayList;import java.util.List;import java.util.Properties;public class BrandTest &#123;    @Test    public void testSelectAll() throws  Exception&#123;        //1. 获取Connection        // 加载配置文件        Properties prop = new Properties();        prop.load(new FileInputStream(System.getProperty(&quot;user.dir&quot;) + &quot;/src/druid.properties&quot;));        // 获取连接池对象        DataSource dataSource = DruidDataSourceFactory.createDataSource(prop);        // 获取数据库连接 Connection        Connection conn = dataSource.getConnection();        // 定义SQL        String sql = &quot;SELECT * FROM tb_brand&quot;;        // 获取pstmt对象，使用prepareStatement，防止sql注入        PreparedStatement pstmt = conn.prepareStatement(sql);        // 设置参数        // 执行SQL        ResultSet rs = pstmt.executeQuery();        // 处理结果 List&lt;Brand&gt; 封装Brand对象,装载List集合        Brand brand = null;        List&lt;Brand&gt; brands = new ArrayList&lt;&gt;();        while (rs.next())&#123;            // 获取数据            int id = rs.getInt(&quot;id&quot;);            String brandName = rs.getString(&quot;brand_name&quot;);            String companyName = rs.getString(&quot;company_name&quot;);            int ordered = rs.getInt(&quot;ordered&quot;);            String description = rs.getString(&quot;description&quot;);            int status = rs.getInt(&quot;status&quot;);            // 封装Brand对象            brand = new Brand();            brand.setId(id);            brand.setBrandName(brandName);            brand.setCompanyName(companyName);            brand.setOrdered(ordered);            brand.setDescription(description);            brand.setStatus(status);            // 装载集合            brands.add(brand);        &#125;        System.out.println(brands);        // 资源释放        rs.close();        pstmt.close();        conn.close();    &#125;    @Test    public void testAdd() throws  Exception &#123;        // 接收页面提交的参数        String brandName = &quot;香飘飘&quot;;        String companyName = &quot;香飘飘&quot;;        int ordered = 1;        String description = &quot;绕地球一圈&quot;;        int status = 1;        //1. 获取Connection        // 加载配置文件        Properties prop = new Properties();        prop.load(new FileInputStream(System.getProperty(&quot;user.dir&quot;) + &quot;/src/druid.properties&quot;));        // 获取连接池对象        DataSource dataSource = DruidDataSourceFactory.createDataSource(prop);        // 获取数据库连接 Connection        Connection conn = dataSource.getConnection();        // 定义SQL        String sql = &quot;INSERT INTO tb_brand(brand_name, company_name, ordered, description, status) VALUES(?,?,?,?,?)&quot;;        // 获取pstmt对象，使用prepareStatement，防止sql注入        PreparedStatement pstmt = conn.prepareStatement(sql);        // 设置参数        pstmt.setString(1, brandName);        pstmt.setString(2, companyName);        pstmt.setInt(3, ordered);        pstmt.setString(4, description);        pstmt.setInt(5, status);        // 执行SQL        int count = pstmt.executeUpdate();//影响的行数        // 处理结果        System.out.println(count &gt; 0);        // 资源释放        pstmt.close();        conn.close();    &#125;    @Test    public void testUpdate() throws  Exception &#123;        // 接收页面提交的参数        String brandName = &quot;香飘飘&quot;;        String companyName = &quot;香飘飘&quot;;        int ordered = 1000;        String description = &quot;绕地球三圈&quot;;        int status = 1;        int id = 4;        //1. 获取Connection        // 加载配置文件        Properties prop = new Properties();        prop.load(new FileInputStream(System.getProperty(&quot;user.dir&quot;) + &quot;/src/druid.properties&quot;));        // 获取连接池对象        DataSource dataSource = DruidDataSourceFactory.createDataSource(prop);        // 获取数据库连接 Connection        Connection conn = dataSource.getConnection();        // 定义SQL        String sql = &quot;UPDATE tb_brand\\n&quot; +                &quot;SET\\n&quot; +                &quot;\\tbrand_name = ?,\\n&quot; +                &quot;\\tcompany_name = ?,\\n&quot; +                &quot;\\tordered = ?,\\n&quot; +                &quot;\\tdescription = ?, \\n&quot; +                &quot;\\t`status` = ?\\n&quot; +                &quot;WHERE id = ?;&quot;;        // 获取pstmt对象，使用prepareStatement，防止sql注入        PreparedStatement pstmt = conn.prepareStatement(sql);        // 设置参数        pstmt.setString(1, brandName);        pstmt.setString(2, companyName);        pstmt.setInt(3, ordered);        pstmt.setString(4, description);        pstmt.setInt(5, status);        pstmt.setInt(4, id);        // 执行SQL        int count = pstmt.executeUpdate();//影响的行数        // 处理结果        System.out.println(count &gt; 0);        // 资源释放        pstmt.close();        conn.close();    &#125;    @Test    public void testDeleteById() throws  Exception &#123;        // 接收页面提交的参数        int id = 4;        //1. 获取Connection        // 加载配置文件        Properties prop = new Properties();        prop.load(new FileInputStream(System.getProperty(&quot;user.dir&quot;) + &quot;/src/druid.properties&quot;));        // 获取连接池对象        DataSource dataSource = DruidDataSourceFactory.createDataSource(prop);        // 获取数据库连接 Connection        Connection conn = dataSource.getConnection();        // 定义SQL        String sql = &quot;DELETE FROM tb_brand WHERE id = ?&quot;;        // 获取pstmt对象，使用prepareStatement，防止sql注入        PreparedStatement pstmt = conn.prepareStatement(sql);        // 设置参数        pstmt.setInt(1, id);        // 执行SQL        int count = pstmt.executeUpdate();//影响的行数        // 处理结果        System.out.println(count &gt; 0);        // 资源释放        pstmt.close();        conn.close();    &#125;&#125;\n\n","categories":["WEBbackend"],"tags":["Java","mysql"]},{"title":"Mysql OF CodeWithMosh","url":"/2022/12/01/DBMS/MySql/Mysql%20OF%20CodeWithMosh/","content":"ⅡThe SELECT ClauseSELECT \t\tfirst_name, \tlast_name, \tpoints, \t(points + 10) * 100 AS &#x27;discount factor&#x27;FROM customers-- WHERE customer_id = 1-- ORDER BY first_name\n\n\nSELECT DISTINCT state FROM customers;\n\nDISTINCT - 用于返回唯一不同的值\n\nThe WHERE ClauseSELECT *FROM CustomersWHERE points &gt; 3000;\n\n\nSELECT *FROM Customers-- WHERE state != &#x27;va&#x27;WHERE state &lt;&gt; &#x27;va&#x27;;\n\n\nSELECT *FROM CustomersWHERE birth_date &gt; &#x27;1990-01-01&#x27;;\n\n\nThe AND,OR and NOT OperatorsSELECT *FROM Customers-- WHERE birth_date &gt; &#x27;1990-01-01&#x27; &amp;&amp; points &gt; 1000 || state = &quot;VA&quot;WHERE birth_date &gt; &#x27;1990-01-01&#x27; AND points &gt; 1000 OR state = &#x27;VA&#x27;;\n\n\nSELECT *FROM CustomersWHERE NOT (birth_date &gt; &#x27;1990-01-01&#x27; OR points &gt; 1000);\n\n\n\nThe IN OperatorSELECT *FROM Customers-- WHERE state = &#x27;VA&#x27; OR state = &#x27;GA&#x27; OR state = &#x27;FL&#x27;WHERE state IN (&#x27;VA&#x27;,&#x27;FL&#x27;,&#x27;GA&#x27;);-- WHERE state NOT IN (&#x27;VA&#x27;,&#x27;FL&#x27;,&#x27;GA&#x27;)\n\n\nThe BETWEEN OperatorSELECT *FROM customers-- WHERE points &gt;= 1000 AND points &lt;= 3000WHERE points BETWEEN 1000 AND 3000;\n\n\nThe LIKE Operator\n% any number of characters\n_ single character\n\nSELECT *FROM customersWHERE last_name LIKE &#x27;%b%&#x27;;\n\n\nSELECT *FROM customersWHERE last_name LIKE &#x27;b____y&#x27;;\n\n\nThe REGEXP Operator\n^   beginning\n$   end\n|   logical or\n[abcd]\n[a-f]\n\nSELECT *FROM customers-- WHERE last_name LIKE &#x27;%field&#x27; OR last_name LIKE &#x27;mac%&#x27; OR last_name LIKE &#x27;%rose%&#x27;WHERE last_name REGEXP &#x27;field$|^mac|rose&#x27;;\n\n\nSELECT *FROM customersWHERE last_name REGEXP &#x27;[a-h]e&#x27;;\n\n\nThe IS NULL OperatorSELECT *FROM customers-- WHERE phone NOT IS NULLWHERE phone IS NULL;\n\n\nThe ORDER BY ClauseSELECT *FROM customersORDER BY points DESC;\n\n\nSELECT birth_date, first_name, last_name, 10 AS pointsFROM customersORDER BY 1, 2;\n\n\nThe LIMIT ClauseSELECT *FROM customersLIMIT 6, 3;-- page 1: 1 - 3-- page 2: 4 - 6-- page 3: 7 - 9\n\n\nⅢInner Joins\nSELECT order_id, orders.customer_id, first_name, last_nameFROM ordersINNER JOIN customers\tON orders.customer_id = customers.customer_id;\n\nSELECT order_id, o.customer_id, first_name, last_nameFROM orders oJOIN customers c\tON o.customer_id = c.customer_id;\n\n\nJoining Across DatabasesUSE sql_store;SELECT *FROM order_items oiJOIN sql_inventory.products p\tON oi.product_id = p.product_id;\n\n\nSelf JoinsUSE sql_hr;SELECT\te.employee_id,\te.first_name,\tm.first_name AS managerFROM employees eJOIN employees m\tON e.reports_to = m.employee_id;\n\n\nJoining Multiple TablesUSE sql_store;SELECT\to.order_id,\to.order_date,\tc.first_name,\tc.last_name,\tos.name AS statusFROM orders oJOIN customers c\tON o.customer_id = c.customer_idJOIN order_statuses os\tON o.status = os.order_status_id\n\n\nCompound Join ConditionsSELECT *FROM order_items oiJOIN order_item_notes oin\tON oi.order_id = oin.order_id\tAND oi.product_id = oin.product_id\n\n\n\nImplicit Join Syntax不建议使用隐式连接，WHERE不能省略 否则造成笛卡尔积 \nSELECT *FROM orders oJOIN customers c\tON o.customer_id = c.customer_id;\n\n-- Implpicit Join SyntaxSELECT *FROM orders o, customers cWHERE o.customer_id = c.customer_id;\n\n\nOuter Joins左连接就是以FROM后面的表为主，右连接就是以JOIN 后面的表为主\n\n-- LEFT JOINSELECT\tc.customer_id,\tc.first_name,\to.order_idFROM customers c-- LEFT OUTER JOIN orders oLEFT JOIN orders o\tON c.customer_id = o.customer_idORDER BY c.customer_id;\n\n\n\n-- RIGHT JOINSELECT\tc.customer_id,    c.first_name,    o.order_idFROM customers c-- RIGHT OUTER JOIN orders oRIGHT JOIN orders o\tON c.customer_id = o.customer_idORDER BY c.customer_id;\n\n\nOuter Joins Between Multiple TablesSELECT *FROM customers cLEFT JOIN orders o\tON c.customer_id = o.customer_idLEFT JOIN shippers sh\tON o.shipper_id = sh.shipper_idORDER BY c.customer_id;\n\n\nSelf Outer JoinsSELECT\te.employee_id,\te.first_name,\tm.first_name AS managerFROM employees eLEFT JOIN employees m\tON e.reports_to = m.employee_id\n\n\nThe USING ClauseSELECT\to.order_id,    c.first_name,    sh.name AS shipperFROM orders oJOIN customers c\t-- ON o.customer_id = c.customer_id    USING (customer_id)LEFT JOIN shippers sh\tUSING (shipper_id);\n\n\nSELECT *FROM order_items oiJOIN order_item_notes oin\t-- ON oi.order_id = oin.order_id AND\t\t-- oi.product_id = oin.product_id\tUSING(order_id, product_id);\n\n\n\nNatural Joins不建议使用随缘大法\nSELECT\to.order_id,    c.first_nameFROM orders oNATURAL JOIN customers c\n\n\nCross Joins笛卡尔积\nSELECT\tc.first_name AS customer,\tp.name AS product-- FROM customers c, products pFROM customers cCROSS JOIN products pORDER BY c.first_name\n\n\nUnions没啥用,但是并和列数必须相等\nUNION &#x2F; UNION ALL\nSELECT\torder_id,\torder_date,\t&#x27;Active&#x27; AS statusFROM ordersWHERE order_date &gt;= &#x27;2019-01-01&#x27;UNIONSELECT\torder_id,\torder_date,\t&#x27;Archived&#x27; AS statusFROM ordersWHERE order_date &lt; &#x27;2019-01-01&#x27;\n\n\nⅣColumn Attributes\n\nPK – 主键\nNN – 非空值\nAI – 自动递增\nDefault&#x2F;Expression – 默认值\n\nInserting a Single RowINSERT INTO customersVALUES (\tDEFAULT,    &#x27;John&#x27;,    &#x27;Smith&#x27;,    &#x27;1990-01-01&#x27;,    NULL,    &#x27;address&#x27;,    &#x27;city&#x27;,    &#x27;CA&#x27;,    DEFAULT);\n\nINSERT INTO customers (\tfirst_name,    last_name,    birth_date,    address,    city,    state)VALUES (    &#x27;John&#x27;,    &#x27;Smith&#x27;,    &#x27;1990-01-01&#x27;,    &#x27;address&#x27;,    &#x27;city&#x27;,    &#x27;CA&#x27;);\n\n\nInserting Multiple RowsINSERT INTO shippers (name)VALUES (&#x27;Shipper1&#x27;),\t(&#x27;Shipper2&#x27;),\t(&#x27;Shipper3&#x27;);\n\n\nInserting Hierarchical Rows\nLAST_INSERT_ID() –  最近插入ID\n\nINSERT INTO orders (customer_id, order_date, status)VALUES (1, &#x27;2019-01-02&#x27;, 1);INSERT INTO order_itemsVALUES\t(LAST_INSERT_ID(), 1, 1, 2.95),\t(LAST_INSERT_ID(), 2, 1, 3.95)\n\n\nCreating a Copy of a TableCREATE TABLE orders_archived ASSELECT * FROM orders;\n\n\nTruncate Table\n\nINSERT INTO orders_archivedSELECT *FROM ordersWHERE order_date &lt; &#x27;2019-01-01&#x27;;\n\n\nUpdating a Single RowUPDATE invoicesSET payment_total = 10, payment_date = &#x27;2019-03-01&#x27;WHERE invoice_id = 1\n\n\nUPDATE invoicesSET\tpayment_total = invoice_total * 0.5,\tpayment_date = due_dateWHERE invoice_id = 3\n\n\nUpdating Multiple RowsUPDATE invoicesSET\tpayment_total = invoice_total * 0.5,\tpayment_date = due_dateWHERE invoice_id IN (3, 4)\n\n\n\nUsing Subqueries in UpdatesUPDATE invoicesSET\tpayment_total = invoice_total * 0.5,\tpayment_date = due_dateWHERE client_id IN\t(SELECT client_id     FROM clients     WHERE state IN (&#x27;CA&#x27;,&#x27;NY&#x27;))\n\n\n\nDeleting RowsDELETE FROM invoicesWHERE client_id = (\tSELECT client_id    FROM clients    WHERE name = &#x27;Myworks&#x27;)\n\n\n\nⅤAggregate FunctionsSELECT\tMAX(invoice_total) AS highest,\tMIN(invoice_total) AS lowest,\tAVG(invoice_total) AS average,\tSUM(invoice_total * 1.1) AS total,\tCOUNT(DISTINCT client_id) AS total_recordsFROM invoicesWHERE invoice_date &gt; &#x27;2019-07-01&#x27;\n\n\nThe GROUP BY ClauseFROM-&gt;WHERE-&gt;GROUP BY-&gt;SELECT-&gt;ORDER BY\nSELECT\tclient_id,\tSUM(invoice_total) AS total_salesFROM invoicesWHERE invoice_date &gt;= &#x27;2019-07-01&#x27;GROUP BY client_idORDER BY total_sales DESC;\n\n\nSELECT\tstate,\tcity,\tSUM(invoice_total) AS total_salesFROM invoicesJOIN clients USING (client_id)GROUP BY state, city\n\n\nThe HAVING ClauseSELECT\tclient_id,\tSUM(invoice_total) AS total_sales,\tCOUNT(*) AS number_of_invoicesFROM invoicesGROUP BY client_idHAVING total_sales &gt; 500 AND number_of_invoices &gt; 5\n\n\nThe ROLLUP OperatorSELECT\tstate,\tcity,\tSUM(invoice_total) AS total_salesFROM invoicesJOIN clients c USING (client_id)GROUP BY state, city WITH ROLLUP\n\n\nⅥSubqueriesSELECT *FROM productsWHERE unit_price &gt; (    SELECT unit_price    FROM products    WHERE product_id = 3)\n\n\nThe IN OperatorSELECT *FROM productsWHERE product_id NOT IN (    SELECT DISTINCT product_id    FROM order_items)\n\n\nSubqueries vs Joins-- Find clients without invoicesSELECT *FROM clientsWHERE client_id NOT IN (    SELECT DISTINCT client_id    FROM invoices)\n\nSELECT *FROM clientsLEFT JOIN invoices USING (client_id)WHERE invoice_id IS NULL\n\n\nThe ALL KeywordNOT IN &#x3D; &lt;&gt;all\nSELECT *FROM invoicesWHERE invoice_total &gt; (    SELECT MAX(invoice_total)    FROM invoices    WHERE client_id = 3)\n\nSELECT *FROM invoicesWHERE invoice_total &gt; ALL (    SELECT invoice_total    FROM invoices    WHERE client_id = 3)\n\n\nThe ANY KeywordIN &#x3D; =ANY\n-- Select clients with at least two invoicesSELECT *FROM clients-- WHERE client_id IN (WHERE client_id = ANY (    SELECT client_id    FROM invoices    GROUP BY client_id    HAVING COUNT(*) &gt;= 2)\n\n\nCorrelated Subqueries-- Select employees whose salary is above the average in their officeSELECT *FROM employees eWHERE salary &gt; (    SELECT AVG(salary)    FROM employees    WHERE office_id = e.office_id)\n\n\nThe EXISTS Operator-- Select clients that have an invoiceSELECT *FROM clientsWHERE client_id IN (    SELECT DISTINCT client_id    FROM invoices)\n\nSELECT *FROM clients cWHERE EXISTS (    SELECT client_id    FROM invoices    WHERE client_id = c.client_id)\n\n\nNOT EXISTS 比 NOT IN 效率高\nSubqueries in the SELECT ClauseSELECT\tinvoice_id,    invoice_total,    (SELECT AVG(invoice_total)\t\tFROM invoices) AS invoice_average,\tinvoice_total - (SELECT invoice_average) AS differenceFROM invoices\n\n\nSubqueries in the FROM ClauseUSE sql_invoicing;SELECT *FROM (\tSELECT\t\tclient_id,\t\tname,\t\t(SELECT SUM(invoice_total)\t\t\tFROM invoices\t\t\tWHERE client_id = c.client_id) AS total_sales,\t\t(SELECT AVG(invoice_total) FROM invoices) AS average,\t\t(SELECT total_sales - average) AS difference\tFROM clients c) AS sales_summaryWHERE total_sales IS NOT NULL\n\n\nⅦNumeric Functions\n\n\n名称\n描述\n\n\n\nABS()\n返回绝对值\n\n\nACOS()\n返回反余弦\n\n\nASIN()\n返回反正弦\n\n\nATAN()\n返回反正切\n\n\nATAN2(),  ATAN()\n返回两个参数的反正切值\n\n\nCEIL()\n返回不小于参数的最小整数值\n\n\nCEILING()\n返回不小于参数的最小整数值\n\n\nCONV()\n在不同数基之间转换数字\n\n\nCOS()\n返回余弦\n\n\nCOT()\n返回余切\n\n\nCRC32()\n计算循环冗余校验值\n\n\nDEGREES()\n将弧度转换为度数\n\n\nEXP()\n提升到的力量\n\n\nFLOOR()\n返回不大于参数的最大整数值\n\n\nLN()\n返回参数的自然对数\n\n\nLOG()\n返回第一个参数的自然对数\n\n\nLOG10()\n返回参数的以 10 为底的对数\n\n\nLOG2()\n返回参数的以 2 为底的对数\n\n\nMOD()\n退还余数\n\n\nPI()\n返回 pi 的值\n\n\nPOW()\n返回参数的指定幂\n\n\nPOWER()\n返回参数的指定幂\n\n\nRADIANS()\n返回参数转换为弧度\n\n\nRAND()\n返回一个随机浮点值\n\n\nROUND()\n绕过论点\n\n\nSIGN()\n返回参数的符号\n\n\nSIN()\n返回参数的正弦\n\n\nSQRT()\n返回参数的平方根\n\n\nTAN()\n返回参数的正切\n\n\nTRUNCATE()\n截断到指定的小数位数\n\n\nString Functions\n\n\n姓名\n描述\n\n\n\nASCII()\n返回最左边字符的数值\n\n\nBIN()\n返回包含数字二进制表示的字符串\n\n\nBIT_LENGTH()\n以位为单位返回参数的长度\n\n\nCHAR()\n返回传递的每个整数的字符\n\n\nCHAR_LENGTH()\n返回参数中的字符数\n\n\nCHARACTER_LENGTH()\nCHAR_LENGTH() 的同义词\n\n\nCONCAT()\n返回连接的字符串\n\n\nCONCAT_WS()\n返回带分隔符的连接\n\n\nELT()\n返回索引号处的字符串\n\n\nEXPORT_SET()\n返回一个字符串，这样对于值位中设置的每个位，您       得到一个 on string，对于每个未设置的位，你得到一个 off string\n\n\nFIELD()\n后续参数中第一个参数的索引（位置）\n\n\nFIND_IN_SET()\n第二个参数中第一个参数的索引（位置）\n\n\nFORMAT()\n返回格式化为指定小数位数的数字\n\n\nFROM_BASE64()\n解码base64编码的字符串并返回结果\n\n\nHEX()\n十进制或字符串值的十六进制表示\n\n\nINSERT()\n在指定位置插入子串，最多指定个数       人物\n\n\nINSTR()\n返回第一次出现的子字符串的索引\n\n\nLCASE()\nLOWER() 的同义词\n\n\nLEFT()\n返回指定的最左边的字符数\n\n\nLENGTH()\n以字节为单位返回字符串的长度\n\n\nLIKE\n简单模式匹配\n\n\nLOAD_FILE()\n加载命名文件\n\n\nLOCATE()\n返回子串第一次出现的位置\n\n\nLOWER()\n以小写形式返回参数\n\n\nLPAD()\n返回字符串参数，左填充指定的字符串\n\n\nLTRIM()\n删除前导空格\n\n\nMAKE_SET()\n返回一组以逗号分隔的字符串，这些字符串具有       位集中的相应位\n\n\nMATCH()\n执行全文搜索\n\n\nMID()\n返回从指定位置开始的子串\n\n\nNOT LIKE\n简单模式匹配的否定\n\n\nNOT REGEXP\nREGEXP 的否定\n\n\nOCT()\n返回包含数字的八进制表示的字符串\n\n\nOCTET_LENGTH()\nLENGTH() 的同义词\n\n\nORD()\n返回参数最左边字符的字符代码\n\n\nPOSITION()\nLOCATE() 的同义词\n\n\nQUOTE()\n转义参数以在 SQL 语句中使用\n\n\nREGEXP\n字符串是否匹配正则表达式\n\n\nREGEXP_INSTR()\n子串匹配正则表达式的起始索引\n\n\nREGEXP_LIKE()\n字符串是否匹配正则表达式\n\n\nREGEXP_REPLACE()\n替换匹配正则表达式的子串\n\n\nREGEXP_SUBSTR()\n返回匹配正则表达式的子串\n\n\nREPEAT()\n重复一个字符串指定的次数\n\n\nREPLACE()\n替换指定字符串的出现\n\n\nREVERSE()\n反转字符串中的字符\n\n\nRIGHT()\n返回指定的最右边的字符数\n\n\nRLIKE\n字符串是否匹配正则表达式\n\n\nRPAD()\n追加字符串指定的次数\n\n\nRTRIM()\n删除尾随空格\n\n\nSOUNDEX()\n返回一个 soundex 字符串\n\n\nSOUNDS LIKE\n比较声音\n\n\nSPACE()\n返回指定空格数的字符串\n\n\nSTRCMP()\n比较两个字符串\n\n\nSUBSTR()\n返回指定的子字符串\n\n\nSUBSTRING()\n返回指定的子字符串\n\n\nSUBSTRING_INDEX()\n返回字符串中指定数目之前的子串       分隔符的出现\n\n\nTO_BASE64()\n返回转换为 base-64 字符串的参数\n\n\nTRIM()\n删除前导和尾随空格\n\n\nUCASE()\nUPPER() 的同义词\n\n\nUNHEX()\n返回包含数字的十六进制表示的字符串\n\n\nUPPER()\n转换为大写\n\n\nWEIGHT_STRING()\n返回字符串的权重字符串\n\n\nDate Functions\n\n\n名称\n描述\n\n\n\nADDDATE()\n将时间值（间隔）添加到日期值\n\n\nADDTIME()\n添加时间\n\n\nCONVERT_TZ()\n从一个时区转换为另一个时区\n\n\nCURDATE()\n返回当前日期\n\n\nCURRENT_DATE(),  CURRENT_DATE\nCURDATE() 的同义词\n\n\nCURRENT_TIME(),  CURRENT_TIME\nCURTIME() 的同义词\n\n\nCURRENT_TIMESTAMP(),  CURRENT_TIMESTAMP\nNOW() 的同义词\n\n\nCURTIME()\n返回当前时间\n\n\nDATE()\n提取日期或日期时间表达式的日期部分\n\n\nDATE_ADD()\n将时间值（间隔）添加到日期值\n\n\nDATE_FORMAT()\n按指定格式设置日期\n\n\nDATE_SUB()\n从日期中减去时间值（间隔）\n\n\nDATEDIFF()\n减去两个日期\n\n\nDAY()\nDAYOFMONTH() 的同义词\n\n\nDAYNAME()\n返回工作日的名称\n\n\nDAYOFMONTH()\n返回月份中的第几天 (0-31)\n\n\nDAYOFWEEK()\n返回参数的工作日索引\n\n\nDAYOFYEAR()\n返回一年中的第几天 (1-366)\n\n\nEXTRACT()\n提取日期的一部分\n\n\nFROM_DAYS()\n将天数转换为日期\n\n\nFROM_UNIXTIME()\n将 Unix 时间戳格式化为日期\n\n\nGET_FORMAT()\n返回日期格式字符串\n\n\nHOUR()\n提取小时\n\n\nLAST_DAY\n返回参数月份的最后一天\n\n\nLOCALTIME(),  LOCALTIME\nNOW() 的同义词\n\n\nLOCALTIMESTAMP,  LOCALTIMESTAMP()\nNOW() 的同义词\n\n\nMAKEDATE()\n从年份和年份创建日期\n\n\nMAKETIME()\n从小时、分钟、秒创建时间\n\n\nMICROSECOND()\n从参数返回微秒\n\n\nMINUTE()\n从参数中返回分钟\n\n\nMONTH()\n从传递的日期返回月份\n\n\nMONTHNAME()\n返回月份名称\n\n\nNOW()\n返回当前日期和时间\n\n\nPERIOD_ADD()\n在年月中添加句点\n\n\nPERIOD_DIFF()\n返回期间之间的月数\n\n\nQUARTER()\n从日期参数返回季度\n\n\nSEC_TO_TIME()\n将秒数转换为 ‘hh:mm:ss’ 格式\n\n\nSECOND()\n返回第二个 (0-59)\n\n\nSTR_TO_DATE()\n将字符串转换为日期\n\n\nSUBDATE()\n使用三个参数调用时 DATE_SUB() 的同义词\n\n\nSUBTIME()\n减去次数\n\n\nSYSDATE()\n返回函数执行的时间\n\n\nTIME()\n提取传递的表达式的时间部分\n\n\nTIME_FORMAT()\n格式化为时间\n\n\nTIME_TO_SEC()\n返回转换为秒的参数\n\n\nTIMEDIFF()\n减去时间\n\n\nTIMESTAMP()\n使用单个参数，此函数返回日期或日期时间       表达;  有两个参数，参数之和\n\n\nTIMESTAMPADD()\n向日期时间表达式添加间隔\n\n\nTIMESTAMPDIFF()\n从日期时间表达式中减去一个间隔\n\n\nTO_DAYS()\n返回转换为天数的日期参数\n\n\nTO_SECONDS()\n返回转换为秒数的日期或日期时间参数       0年\n\n\nUNIX_TIMESTAMP()\n返回一个 Unix 时间戳\n\n\nUTC_DATE()\n返回当前 UTC 日期\n\n\nUTC_TIME()\n返回当前 UTC 时间\n\n\nUTC_TIMESTAMP()\n返回当前 UTC 日期和时间\n\n\nWEEK()\n返回周数\n\n\nWEEKDAY()\n返回工作日索引\n\n\nWEEKOFYEAR()\n返回日期的日历周 (1-53)\n\n\nYEAR()\n返回年份\n\n\nYEARWEEK()\n返回年份和星期\n\n\nFormatting Dates and Times\n\n\n说明符\n描述\n\n\n\n%a\n缩写的工作日名称                 ( Sun.. Sat)\n\n\n%b\n缩写月份名称 ( Jan.. Dec)\n\n\n%c\n月份，数字 ( 0.. 12)\n\n\n%D\n带有英文后缀的月份中的第几天 ( 0th,                 1st,  2nd,                 3rd, …)\n\n\n%d\n一个月中的第几天，数字 ( 00.. 31)\n\n\n%e\n一个月中的第几天，数字 ( 0.. 31)\n\n\n%f\n微秒 ( 000000.. 999999)\n\n\n%H\n小时 （ 00.. 23)\n\n\n%h\n小时 （ 01.. 12)\n\n\n%I\n小时 （ 01.. 12)\n\n\n%i\n分钟，数字 ( 00.. 59)\n\n\n%j\n一年中的第几天 ( 001.. 366)\n\n\n%k\n小时 （ 0.. 23)\n\n\n%l\n小时 （ 1.. 12)\n\n\n%M\n月名 ( January.. December)\n\n\n%m\n月份，数字 ( 00.. 12)\n\n\n%p\nAM或者 PM\n\n\n%r\n时间，12 小时（ *hh:mm:ss*其次是                 AM或者 PM)\n\n\n%S\n秒 ( 00.. 59)\n\n\n%s\n秒 ( 00.. 59)\n\n\n%T\n时间，24 小时制（ hh:mm:ss)\n\n\n%U\n星期 （ 00.. 53), 其中周日是                 一周的第一天；                 WEEK()模式 0\n\n\n%u\n星期 （ 00.. 53), 其中星期一是                 一周的第一天；                 WEEK()方式一\n\n\n%V\n星期 （ 01.. 53), 其中周日是                 一周的第一天；                 WEEK()方式二；  与                 %X\n\n\n%v\n星期 （ 01.. 53), 其中星期一是                 一周的第一天；                 WEEK()模式 3；  与                 %x\n\n\n%W\n工作日名称 ( Sunday.. Saturday)\n\n\n%w\n一周中的天                 ( 0&#x3D;星期天.. 6&#x3D;星期六）\n\n\n%X\n星期日是一周的第一天的那一周的年份，数字，                 四位数;  与 %V\n\n\n%x\n一周的年份，其中星期一是一周的第一天，数字，                 四位数;  与 %v\n\n\n%Y\n年份，数字，四位数字\n\n\n%y\n年份，数字（两位数）\n\n\n%%\n文字 %特点\n\n\n%*x*\nx, 对于任何                   “ *x*” 未列出                   以上\n\n\nSELECT TIME_FORMAT(NOW(), &#x27;%H:%i %p&#x27;)\n\n\nCalculating Dates and TimesSELECT DATE_ADD(NOW(), INTERVAL 1 YEAR)\n\n\n-- SELECT DATE_ADD(NOW(), INTERVAL -1 YEAR)SELECT DATE_SUB(NOW(), INTERVAL 1 YEAR)\n\n\nSELECT DATEDIFF(&#x27;2019-01-05&#x27;, &#x27;2019-01-01&#x27;)\n\n\nSELECT TIME_TO_SEC(&#x27;09:00&#x27;)\n\n\nSELECT TIME_TO_SEC(&#x27;09:00&#x27;) - TIME_TO_SEC(&#x27;09:02&#x27;)\n\n\nThe IFNULL and COALESCE FunctionsSELECT\torder_id,\tIFNULL(shipper_id, &#x27;Not assigned&#x27;) AS shipperFROM orders\n\n\nSELECT\torder_id,\tCOALESCE(shipper_id, comments, &#x27;Not assigned&#x27;) AS shipperFROM orders\n\n\nSELECT\torder_id,\tIFNULL(shipper_id, &#x27;...&#x27;),    COALESCE(shipper_id, comments, &#x27;Not assigned&#x27;) AS shipperFROM orders\n\n\nThe IF FunctionSELECT\torder_id,\torder_date,    IF(\t\tYEAR(order_date) = YEAR(NOW()),        &#x27;Active&#x27;,        &#x27;Archived&#x27;) AS categoryFROM orders\n\n\nThe CASE OperatorSELECT\torder_id,    CASE\t\tWHEN YEAR(order_date) = YEAR(NOW()) THEN &#x27;Active&#x27;        WHEN YEAR(order_date) = YEAR(NOW()) - 1 THEN &#x27;Last Year&#x27;        WHEN YEAR(order_date) &lt; YEAR(NOW()) - 1 THEN &#x27;Archived&#x27;        ELSE &#x27;Future&#x27;\tEND AS categoryFROM orders\n\n\n","categories":["WEBbackend"],"tags":["sql","mysql"]},{"title":"File类","url":"/2022/11/03/WebBackend/Java/File%E7%B1%BB/","content":"构造方法//方式1 new File(String pathname)\t//根据文件路径名String path = &quot;D:\\\\Demo\\\\new.txt&quot;;File file = new File(path); //方式2 new File(String parent, String child) //根据父目录+子路径构建String parentPath = &quot;D:\\\\Demo&quot;;String fileName = &quot;new.txt&quot;;File file = new File(parentPath, fileName);//方式3 new File(File parent,String child) //根据父目录文件+子路径构造File parentFile = new File(&quot;D:\\\\Demo&quot;);String fileName = &quot;new.txt&quot;;File file = new File(parentFile, fileName);\n\n常用方法//创建文件对象File file = new File(D:\\\\Demo\\\\new.txt);//调用相应的方法，得到对应信息System.out.println(&quot;文件名：&quot; + file.getName());System.out.println(&quot;文件绝对路径：&quot; + file.getAbsolutePath());System.out.println(&quot;文件父级目录：&quot; + file.getParent());System.out.println(&quot;文件大小(字节)：&quot; + file.length());System.out.println(&quot;文件是否存在：&quot; + file.exists());System.out.println(&quot;是不是一个文件：&quot; + file.isFile());System.out.println(&quot;是不是一个目录：&quot; + file.isDirectory());\n\n创建删除功能的方法\npublic boolean createNewFile() ：文件不存在，创建一个新的空文件并返回true，文件存在，不创建文件并返回false。\npublic boolean delete() ：删除由此File表示的文件或目录 （目录必须为空才能删除）\npublic boolean mkdir() ：创建由此File表示的目录。\npublic boolean mkdirs() ：创建由此File表示的多级目录（开发中一般用mkdirs()）\n\n//判断news1.txt 是否存在，如果存在就删除public void  m1() &#123;    String parentPath = System.getProperty(&quot;user.dir&quot;) + &quot;\\\\src&quot;;    String fileName = &quot;news1.txt&quot;;    File file = new File(parentPath,fileName);    if (file.exists()) &#123;        if(file.delete())&#123;            System.out.println(file.getName() + &quot;删除成功&quot;);        &#125; else &#123;            System.out.println(file.getName() + &quot;删除失败&quot;);        &#125;    &#125; else &#123;        System.out.println(file.getName() + &quot;该文件不存在&quot;);    &#125;&#125;//在Java中目录也当作文件，删除demo目录public void m2() &#123;    String filePath = System.getProperty(&quot;user.dir&quot;);    String fileName = &quot;demo1&quot;;    File file = new File(filePath,fileName);    if (file.exists())&#123;        if(file.delete())&#123;            System.out.println(file.getName() + &quot;删除成功&quot;);        &#125; else &#123;            System.out.println(file.getName() + &quot;删除失败&quot;);        &#125;    &#125; else &#123;        System.out.println(file.getName() + &quot;该文件夹不存在&quot;);    &#125;&#125;//创建多级目录public void m3() &#123;    String directoryPath = System.getProperty(&quot;user.dir&quot;) + &quot;\\\\demo1\\\\1\\\\2\\\\3\\\\4\\\\5&quot;;    File file = new File(directoryPath);    if (file.exists())&#123;        System.out.println(file.getName() + &quot;存在...&quot;);    &#125; else &#123;        if (file.mkdirs()) &#123;            System.out.println(&quot;目录&quot; + file.getName() + &quot;创建成功..&quot;);        &#125; else &#123;            System.out.println(&quot;目录&quot; + file.getName() + &quot;创建失败..&quot;);        &#125;    &#125;&#125;//判断news1.txt 是否存在，如果存在就删除public void  m1() &#123;    String parentPath = System.getProperty(&quot;user.dir&quot;) + &quot;\\\\src&quot;;    String fileName = &quot;news1.txt&quot;;    File file = new File(parentPath,fileName);    if (file.exists()) &#123;        if(file.delete())&#123;            System.out.println(file.getName() + &quot;删除成功&quot;);        &#125; else &#123;            System.out.println(file.getName() + &quot;删除失败&quot;);        &#125;    &#125; else &#123;        System.out.println(file.getName() + &quot;该文件不存在&quot;);    &#125;&#125;//在Java中目录也当作文件，删除demo目录public void m2() &#123;    String filePath = System.getProperty(&quot;user.dir&quot;);    String fileName = &quot;demo1&quot;;    File file = new File(filePath,fileName);    if (file.exists())&#123;        if(file.delete())&#123;            System.out.println(file.getName() + &quot;删除成功&quot;);        &#125; else &#123;            System.out.println(file.getName() + &quot;删除失败&quot;);        &#125;    &#125; else &#123;        System.out.println(file.getName() + &quot;该文件夹不存在&quot;);    &#125;&#125;//创建多级目录 mkdirs()可以创建多级目录比如//a//b//c，所以开发中一般用mkdirs()public void m3() &#123;    String directoryPath = System.getProperty(&quot;user.dir&quot;) + &quot;\\\\demo1\\\\1\\\\2\\\\3\\\\4\\\\5&quot;;    File file = new File(directoryPath);    if (file.exists())&#123;        System.out.println(file.getName() + &quot;存在...&quot;);    &#125; else &#123;        if (file.mkdirs()) &#123;            System.out.println(&quot;目录&quot; + file.getName() + &quot;创建成功..&quot;);        &#125; else &#123;            System.out.println(&quot;目录&quot; + file.getName() + &quot;创建失败..&quot;);        &#125;    &#125;&#125;\n\n目录的遍历\npublic String[] list() ：返回一个String数组，表示该File目录中的所有子文件或目录。\npublic File[] listFiles() ：返回一个File数组，表示该File目录中的所有的子文件或目录。\n\npublic class FileFor &#123;    public static void main(String[] args) &#123;        File dir = new File(&quot;G:\\光标&quot;);            \t//获取当前目录下的文件以及文件夹的名称。\t\tString[] names = dir.list();\t\tfor(String name : names)&#123;\t\t\tSystem.out.println(name);\t\t&#125;        //获取当前目录下的文件以及文件夹对象，只要拿到了文件对象，那么就可以获取更多信息        File[] files = dir.listFiles();        for (File file : files) &#123;            System.out.println(file);        &#125;    &#125;&#125;\n\n递归遍历文件夹下所有文件以及子文件package File;import java.io.File;//递归遍历文件夹下所有的文件public class RecursionDirectory &#123;    public static void main(String[] args) &#123;      File file=new File(&quot;D:\\\\java专属IO测试&quot;);        Recursion(file);    &#125;    public static void Recursion(File file)&#123;        //1、判断传入的是否是目录        if(!file.isDirectory())&#123;            //不是目录直接退出            return;        &#125;        //已经确保了传入的file是目录        File[] files = file.listFiles();        //遍历files        for (File f: files) &#123;            //如果该目录下文件还是个文件夹就再进行递归遍历其子目录            if(f.isDirectory())&#123;                //递归                Recursion(f);            &#125;else &#123;                //如果该目录下文件是个文件，则打印对应的名字                System.out.println(f.getName());            &#125;        &#125;    &#125;&#125;\n\n","categories":["WEBbackend"],"tags":["Java"]},{"title":"Java collections (集合)","url":"/2022/11/28/WebBackend/Java/Java%20collections%20(%E9%9B%86%E5%90%88)/","content":"数组声明数组变量dataType[] arrayRefVar;   // Java风格，首选方法dataType arrayRefVar[];   // C、C++风格，可以用但不是首选\n\n创建数组arrayRefVar = new dataType[arraySize];//1、使用 dataType[arraySize] 创建了一个数组。//2、把新创建的数组的引用赋值给变量 arrayRefVar\n\n数组变量声明和创建数组一条语句实现\ndataType[] arrayRefVar = new dataType[arraySize];dataType[] arrayRefVar = &#123;value0, value1, ..., valuek&#125;;\n\nFor-Each循环for(type element: array)&#123;    System.out.println(element);&#125;\n\n等价于：\nfor(type element = 0; element &lt; array.size(); i++)&#123;    type element2 = array.get(element);&#125;\n\n\n\n多维数组初始化type[][] typeName = new type[typeLength1][typeLength2];\n\ntype 可以为基本数据类型和复合数据类型，typeLength1 和 typeLength2 必须为正整数，typeLength1 为行数，typeLength2 为列数\nList\nList表示一种有序列表，会根据放入元素先后顺序存放，可以包含重复的元素。\nList 实现了 Collection 接口，它主要有两个常用的实现类：ArrayList 类和 LinkedList 类\n\n\n\n\nArrayList\nLinkedList\n\n\n\n获取指定元素\n速度很快\n需要从头开始查找元素\n\n\n添加元素到末尾\n速度很快\n速度很快\n\n\n在指定位置添加&#x2F;删除\n需要移动元素\n不需要移动元素\n\n\n内存占用\n少\n较大\n\n\n实现方式\n动态数组数据结构\n链表数据结构\n\n\n高运行速度往往是以牺牲空间为代价的，而节省占用空间往往是以牺牲运行速度为代价的，所谓“鱼与熊掌不可得兼”\nArrayList类import java.util.List;import java.util.ArrayList;class Main &#123;    public static void main(String[] args) &#123;        //使用ArrayList类创建列表        List&lt;Integer&gt; numbers = new ArrayList&lt;&gt;();        //将元素添加到列表        numbers.add(1);        numbers.add(2);        numbers.add(3);        System.out.println(&quot;List: &quot; + numbers);        //从列表中访问元素        int number = numbers.get(2);        System.out.println(&quot;访问元素: &quot; + number);        //从列表中删除元素        int removedNumber = numbers.remove(1);        System.out.println(&quot;删除元素: &quot; + removedNumber);    &#125;&#125;\n\n输出结果：\nList: [1, 2, 3]访问元素: 3删除元素: 2\n\nLinkedList类LinkedList底层的数据结构是基于双向循环链表，且头结点中不存放数据\n\n既然是双向链表，那么必定存在一种数据结构——我们可以称之为节点，节点实例保存业务数据，前一个节点的位置信息和后一个节点位置信息，如：\n\nList&lt;Integer&gt; numbers = new LinkedList&lt;&gt;();\n\nMap\nHashMap&lt;Integer, String&gt; Sites = new HashMap&lt;Integer, String&gt;();\n\nProperties(属性)Properties 继承于 Hashtable，其作用用来读写以.properties为扩展名的配置文件。每行以key=value表示，以之前的连接池笔记为例：\n\n\nProperties读取配置文件，一共有三步：\n\n创建Properties实例；\n调用load()读取文件；\n调用getProperty()获取配置。\n\nSetList接口和Set接口都继承了Collection接口。 但是，它们之间存在一些差异。\n\nList可以包含重复的元素。但是，Set不能有重复的元素。\nList中的元素以某种顺序存储。但是，Set中的元素以组的形式存储，就像数学中的集合一样。\n\nQueue表示先进先出（FIFO：First In First Out）的有序表\n\n通过add()&#x2F;offer()方法将元素添加到队尾；\n通过remove()&#x2F;poll()从队首获取元素并删除；\n通过element()&#x2F;peek()从队首获取元素但不删除。\n\nPriorityQueuePriorityQueue实现了一个优先队列：从队首获取元素时，总是获取优先级最高的元素。\nPriorityQueue默认按元素比较的顺序排序（必须实现Comparable接口），也可以通过Comparator自定义排序算法（元素就不必实现Comparable接口）\nDequeDeque实现了一个双端队列（Double Ended Queue），它可以：\n\n将元素添加到队尾或队首：addLast()&#x2F;offerLast()&#x2F;addFirst()&#x2F;offerFirst()；\n从队首／队尾获取元素并删除：removeFirst()&#x2F;pollFirst()&#x2F;removeLast()&#x2F;pollLast()；\n从队首／队尾获取元素但不删除：getFirst()&#x2F;peekFirst()&#x2F;getLast()&#x2F;peekLast()；\n总是调用xxxFirst()&#x2F;xxxLast()以便与Queue的方法区分开；\n避免把null添加到队列\n\nStack(栈)栈（Stack）是一种后进先出（LIFO）的数据结构，操作栈的元素的方法有：\n\n把元素压栈：push(E)；\n把栈顶的元素“弹出”：pop(E)；\n取栈顶元素但不弹出：peek(E)。\n\n在Java中，我们用Deque可以实现Stack的功能，注意只调用push()&#x2F;pop()&#x2F;peek()方法，避免调用Deque的其他方法。\n最后，不要使用遗留类Stack\nIteratorIterator（迭代器）不是一个集合，它是一种用于访问集合的方法，可用于迭代   ArrayList和 HashSet等集合，比如我们之前的增强for就是迭代器简化的书写格式（增强for循环的底层使用了迭代器遍历）\nCollectionsCollections类提供了一组工具方法来方便使用集合类：\n\n创建空集合；\n创建单元素集合；\n创建不可变集合；\n排序／洗牌等操作。\n\n","categories":["WEBbackend"],"tags":["Java"]},{"title":"Java内部类","url":"/2022/11/29/WebBackend/Java/Java%E5%86%85%E9%83%A8%E7%B1%BB/","content":"Java Inner Classes (Nested Classes)内部类又称嵌套类，是在类或接口内部声明的类，内部类可以访问外部类私有数据，但外部类不能访问内部类的成员，隐藏细节和内部结构封装性好\n\n\nPublic Class一个文件可以写多个类，但只能有一个public类\nMember Inner class(成员内部类)成员内部类 ：\n\n静态成员内部类：使用static修饰类；\n非静态成员内部类：未用static修饰类，在没有说明是静态成员内部类时，默认成员内部类指的就是非静态成员内部类；\n\nclass Outer &#123;    //code    class Inner &#123;        //code    &#125;&#125;\n\nLocal Inner Class(局部内部类)定义在一个方法或者一个作用域里面的类\npublic class locallnner1 &#123;    private int data = 30;  //instance variable    void display() &#123;        class Local &#123;            void msg()&#123;                System.out.println(data);            &#125;        &#125;        Local l = new Local();        l.msg();    &#125;    public static void main(String args[])&#123;        locallnner1 obj = new locallnner1();        obj,display();    &#125;&#125;\n\nAnonymous Class(匿名类)匿名类是没有名字的内部类\npublic class Main &#123;    public static void main(String[] args) &#123;        Outer outer = new Outer(&quot;Nested&quot;); // 实例化一个Outer        Outer.Inner inner = outer.new Inner(); // 实例化一个Inner        inner.hello();    &#125;&#125;class Outer &#123;    private String name;    Outer(String name) &#123;        this.name = name;    &#125;    class Inner &#123;        void hello() &#123;            System.out.println(&quot;Hello, &quot; + Outer.this.name);        &#125;    &#125;&#125;","categories":["WEBbackend"],"tags":["Java"]},{"title":"Java 项目模块化管理","url":"/2023/04/04/WebBackend/Java/Java%20%E9%A1%B9%E7%9B%AE%E6%A8%A1%E5%9D%97%E5%8C%96%E7%AE%A1%E7%90%86/","content":"父项目子模块Git 子模块是一种特殊的 Git 仓库，它保存在主项目中的一个独立目录中。当您使用 git submodule add 命令添加一个子模块时，Git 会在主项目的 .gitmodules 文件中添加一个条目，用于记录子模块的 Git URL 和保存位置等信息。同时，Git 会将子模块的代码克隆到主项目的子目录中，这个子目录就是您指定的子模块保存位置。\n因此，当您执行 Git 命令时，应该在主项目目录中执行命令，而不是在子模块目录或 .git 目录中执行。如果您需要在子模块中执行 Git 命令，可以使用 cd 命令切换到子模块目录中。\n例如，如果您需要更新子模块的代码，可以按照以下步骤执行 Git 命令：\n\n切换到主项目目录中： cd /path/to/main/project\n初始化子模块： git submodule init\n拉取子模块的最新代码： git submodule update\n切换到子模块目录中： cd path/to/submodule\n在子模块目录中执行 Git 命令，例如： git pull 更新子模块的代码。\n\n请注意，在使用 Git 子模块时，您需要额外注意子模块的版本控制。如果您更新了子模块的代码，您需要提交子模块的变更，并在主项目中提交对子模块的更新。\n更新全部子模块git submodule update --init --recursive\n\n\n更新指定子模块**更新单个子模块：如果您只想更新一个子模块，可以指定子模块的路径，例如：\n\ngit submodule update --init path/to/submodule\n在这个命令中，path/to/submodule 是要更新的子模块的路径。Git 将拉取该子模块的最新代码，并将其更新为子模块仓库中的默认分支或提交。\n\n更新所有子模块中的特定分支：如果您希望更新所有子模块到一个特定的分支，可以使用 --remote 选项来拉取最新的远程分支代码，例如：\n\n\n\ngit submodule update --remote\n在这个命令中，--remote 选项告诉 Git 拉取子模块的最新远程代码，而不是使用子模块仓库中的默认分支或提交。这将使得所有子模块更新到最新的远程分支代码。\n\n\n请注意，在使用这些命令时，您需要在主项目中运行 Git 命令，并在执行命令前，确保您已经初始化了子模块。否则，命令将无法更新子模块。\n父项目启动子项目默认情况下，父项目启动时，子项目不会自动启动。子项目和父项目是两个独立的 Java 项目，需要分别进行构建和启动。然而，您可以使用 Maven 或其他构建工具来自动化这个过程，使得父项目能够启动子项目。\n如果您使用 Maven 进行构建和依赖管理，可以将子项目作为父项目的子模块，并使用 Maven 的插件来自动化子项目的构建和部署。以下是一些常见的用例：\n\n在父项目的 pom.xml 文件中添加子模块依赖：\n\n&lt;modules&gt;  &lt;module&gt;submodule1&lt;/module&gt;  &lt;module&gt;submodule2&lt;/module&gt;  ...&lt;/modules&gt;\n\n在这个例子中，我们将子模块 submodule1 和 submodule2 添加为父项目的子模块。这将使 Maven 在构建父项目时，自动构建和打包子模块，并将其包含在父项目的 JAR 或 WAR 文件中。\n\n\n在父项目的 pom.xml 文件中添加子模块构建插件：\n\n&lt;build&gt;  &lt;plugins&gt;    &lt;plugin&gt;      &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;      &lt;artifactId&gt;maven-ejb-plugin&lt;/artifactId&gt;      &lt;version&gt;2.3&lt;/version&gt;      &lt;executions&gt;        &lt;execution&gt;          &lt;id&gt;ejb&lt;/id&gt;          &lt;phase&gt;package&lt;/phase&gt;          &lt;goals&gt;            &lt;goal&gt;ejb&lt;/goal&gt;          &lt;/goals&gt;        &lt;/execution&gt;      &lt;/executions&gt;    &lt;/plugin&gt;    ...  &lt;/plugins&gt;&lt;/build&gt;\n\n在这个例子中，我们添加了一个 EJB 插件，用于构建子模块中的 EJB 代码。当父项目构建时，该插件将自动构建子模块，并将生成的 EJB JAR 文件包含在父项目的 WAR 文件中。\n\n请注意，子模块和父项目是两个独立的 Java 项目，它们需要分别进行构建和部署。如果您使用 Maven 等构建工具，可以使用上述方法来自动化这个过程，以便父项目能够启动子项目。另外，如果您使用 Spring Boot 等框架，您可以使用 Spring Boot 的依赖管理和自动配置功能来管理子项目和父项目之间的依赖关系，并使得父项目能够启动子项目。\n详细教程：https://iphysresearch.github.io/blog/post/programing/git/git_submodule/\n","categories":["WEBbackend"],"tags":["Java"]},{"title":"IO流","url":"/2022/12/09/WebBackend/Java/IO%E6%B5%81/","content":" IO概述\nJava中I&#x2F;O操作主要是指使用java.io包下的内容，进行输入、输出操作。输入也叫做读取数据，输出也叫做作写出数据。\nIO的分类根据数据的流向分为：输入流 和 输出流。\n\n\n\n\n输入流\n输出流\n\n\n\n字节流\n字节输入流 InputStream\n字节输出流 OutputStream\n\n\n字符流\n字符输入流 Reader\n字符输出流 Writer\n\n\n\nInput指从外部读入数据到内存，例如，把文件从磁盘读取到内存，从网络读取数据到内存等等。\nOutput指把数据从内存输出到外部，例如，把数据从内存写入到文件，把数据从内存输出到网络等等。\n\n根据数据的类型分为：字节流 和 字符流。\n\n字节流 ：以字节为单位，读写数据的流。\n字符流 ：以字符为单位，读写数据的流。\n\n\n\n字节流字节输出流（OutputStream）字节输出流的基本共性功能方法:\n\npublic void close() ：关闭此输出流并释放与此流相关联的任何系统资源。\npublic void flush()  ：刷新此输出流并强制任何缓冲的输出字节被写出。\npublic void write(byte[] b)：将 b.length个字节从指定的字节数组写入此输出流。\npublic void write(byte[] b, int off, int len) ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。  也就是说从off个字节数开始读取一直到len个字节结束\npublic abstract void write(int b) ：将指定的字节输出流。\n\n\n以上五个方法则是字节输出流都具有的方法，由父类OutputStream定义提供，子类都会共享以上方法\n\nFileOutputStream类OutputStream有很多子类，我们从最简单的一个子类FileOutputStream开始。看名字就知道是文件输出流，用于将数据写出到文件。\nFileOutputStream构造方法\npublic FileOutputStream(File file)：根据File对象为参数创建对象。 \npublic FileOutputStream(String name)： 根据名称字符串为参数创建对象。\n\n第二种构造方法开发常用：\npublic class FileOutputStreamConstructor throws IOException &#123;    public static void main(String[] args) &#123;   \t \t// 使用File对象创建流对象        File file = new File(&quot;G:\\\\自动创建的文件夹\\\\a.txt&quot;);        FileOutputStream fos = new FileOutputStream(file);              // 使用文件名称创建流对象        FileOutputStream fos = new FileOutputStream(&quot;G:\\\\b.txt&quot;);    &#125;&#125;\n\nFileOutputStream写出字节数据使用FileOutputStream写出字节数据主要通过Write方法，而write方法分如下三种\npublic void write(int b)public void write(byte[] b)public void write(byte[] b,int off,int len)  //从`off`索引开始，`len`个字节\n\n\n写出字节：write(int b) 方法，每次可以写出一个字节数据，代码如下：\n\npublic class IoWrite &#123;    public static void main(String[] args) throws IOException &#123;        // 使用文件名称创建流对象        FileOutputStream fos = new FileOutputStream(&quot;fos.txt&quot;);           \t// 写出数据      \tfos.write(97); // 写出第1个字节      \tfos.write(98); // 写出第2个字节      \tfos.write(99); // 写出第3个字节      \t// 关闭资源        fos.close();    &#125;&#125;\n\n写出字节数组：write(byte[] b)，每次可以写出数组中的数据，代码使用演示：\npublic class FOSWrite &#123;    public static void main(String[] args) throws IOException &#123;        // 使用文件名称创建流对象        FileOutputStream fos = new FileOutputStream(&quot;fos.txt&quot;);           \t// 字符串转换为字节数组      \tbyte[] b = &quot;麻麻我想吃烤山药&quot;.getBytes();      \t// 写出字节数组数据      \tfos.write(b);      \t// 关闭资源        fos.close();    &#125;&#125;\n\n\n写出指定长度字节数组：write(byte[] b, int off, int len) ,每次写出从off索引开始，len个字节，代码如下：\n\npublic class FOSWrite &#123;    public static void main(String[] args) throws IOException &#123;        // 使用文件名称创建流对象        FileOutputStream fos = new FileOutputStream(&quot;fos.txt&quot;);           \t// 字符串转换为字节数组      \tbyte[] b = &quot;abcde&quot;.getBytes();\t\t// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。        fos.write(b,2,2);      \t// 关闭资源        fos.close();    &#125;&#125;\n\nFileOutputStream实现数据追加续写、换行1、public FileOutputStream(File file, boolean append)\n2、public FileOutputStream(String name, boolean append)\n这两个构造方法，第二个参数中都需要传入一个boolean类型的值，true 表示追加数据，false 表示不追加也就是清空原有数据。\n实现数据追加续写代码如下：\npublic class FOSWrite &#123;    public static void main(String[] args) throws IOException &#123;        // 使用文件名称创建流对象        FileOutputStream fos = new FileOutputStream(&quot;fos.txt&quot;，true);           \t// 字符串转换为字节数组      \tbyte[] b = &quot;abcde&quot;.getBytes();\t\t// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。        fos.write(b);      \t// 关闭资源        fos.close();    &#125;&#125;\n\nWindows系统里，换行符号是\\r\\n ,具体代码如下：\npublic class FOSWrite &#123;    public static void main(String[] args) throws IOException &#123;        // 使用文件名称创建流对象        FileOutputStream fos = new FileOutputStream(&quot;fos.txt&quot;);        \t// 定义字节数组      \tbyte[] words = &#123;97,98,99,100,101&#125;;      \t// 遍历数组        for (int i = 0; i &lt; words.length; i++) &#123;          \t// 写出一个字节            fos.write(words[i]);          \t// 写出一个换行, 换行符号转成数组写出            fos.write(&quot;\\r\\n&quot;.getBytes());        &#125;      \t// 关闭资源        fos.close();    &#125;&#125;\n\n字节输入流（InputStream）java.io.InputStream 抽象类是表示字节输入流的所有类的超类（父类），可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。\n字节输入流的基本共性功能方法:\n\npublic void close() ：关闭此输入流并释放与此流相关联的任何系统资源。\npublic abstract int read()： 从输入流读取数据的下一个字节。\npublic int read(byte[] b)： 该方法返回的int值代表的是读取了多少个字节，读到几个返回几个，读取不到返回-1\n\nFileInputStream类java.io.FileInputStream 类是文件输入流，从文件中读取字节。\n构造方法\nFileInputStream(File file)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。\nFileInputStream(String name)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名name命名。\n\n同样的，推荐使用第二种构造方法：\nFileInputStream inputStream = new FileInputStream(&quot;a.txt&quot;);\n\npublic class FileInputStreamConstructor throws IOException&#123;    public static void main(String[] args) &#123;   \t \t// 使用File对象创建流对象        File file = new File(&quot;a.txt&quot;);        FileInputStream fos = new FileInputStream(file);              // 使用文件名称创建流对象        FileInputStream fos = new FileInputStream(&quot;b.txt&quot;);    &#125;&#125;\n\nFileInputStream读取字节数据\n读取字节：read方法，每次可以读取一个字节的数据，提升为int类型，读取到文件末尾，返回-1，代码测试如下【read.txt文件中内容为abcde】：\n\npublic class FISRead &#123;    public static void main(String[] args) throws IOException&#123;      \t// 使用文件名称创建流对象       \tFileInputStream fis = new FileInputStream(&quot;read.txt&quot;);//read.txt文件中内容为abcde      \t// 读取数据，返回一个字节        int read = fis.read();        System.out.println((char) read);        read = fis.read();        System.out.println((char) read);        read = fis.read();        System.out.println((char) read);        read = fis.read();        System.out.println((char) read);        read = fis.read();        System.out.println((char) read);      \t// 读取到末尾,返回-1       \tread = fis.read();        System.out.println( read);\t\t// 关闭资源        fis.close();    &#125;&#125;\n\n循环改进读取方式，代码使用演示：\npublic class FISRead &#123;    public static void main(String[] args) throws IOException&#123;      \t// 使用文件名称创建流对象       \tFileInputStream fis = new FileInputStream(&quot;read.txt&quot;);      \t// 定义变量，保存数据        int b ；        // 循环读取        while ((b = fis.read())!=-1) &#123;            System.out.println((char)b);        &#125;\t\t// 关闭资源        fis.close();    &#125;&#125;\n\n\n使用字节数组读取：read(byte[] b)，每次读取b的长度个字节到数组中，返回读取到的有效字节个数，读取到末尾时，返回-1 ，代码使用演示：\n\npublic class FISRead &#123;    public static void main(String[] args) throws IOException&#123;      \t// 使用文件名称创建流对象.       \tFileInputStream fis = new FileInputStream(&quot;read.txt&quot;); // read.txt文件中内容为abcde      \t// 定义变量，作为有效个数        int len ；        // 定义字节数组，作为装字节数据的容器           byte[] b = new byte[2];        // 循环读取        while (( len= fis.read(b))!=-1) &#123;           \t// 每次读取后,把数组变成字符串打印            System.out.println(new String(b));        &#125;\t\t// 关闭资源        fis.close();    &#125;&#125;\n\n由于read.txt文件中内容为abcde，而错误数据d，是由于最后一次读取时，只读取一个字节e，数组中，上次读取的数据没有被完全替换【注意是替换，看下图】，所以要通过len ，获取有效的字节  代码如下：\npublic class FISRead &#123;    public static void main(String[] args) throws IOException&#123;      \t// 使用文件名称创建流对象.       \tFileInputStream fis = new FileInputStream(&quot;read.txt&quot;); // 文件中为abcde      \t// 定义变量，作为有效个数        int len ；        // 定义字节数组，作为装字节数据的容器           byte[] b = new byte[2];        // 循环读取        while (( len= fis.read(b))!=-1) &#123;           \t// 每次读取后,把数组的有效字节部分，变成字符串打印            System.out.println(new String(b，0，len));//  len 每次读取的有效字节个数        &#125;\t\t// 关闭资源        fis.close();    &#125;&#125;\n\n在开发中一般强烈推荐使用数组读取文件，代码如下：\nimport java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;public class input2 &#123;    public static void main(String args[])&#123;        FileInputStream inputStream = null;        try &#123;            inputStream = new FileInputStream(&quot;a.txt&quot;);            int len = 0 ;            byte[] bys = new byte[1024];            while ((len = inputStream.read(bys)) != -1) &#123;                System.out.println(new String(bys,0,len));            &#125;                &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;finally &#123;            try &#123;                inputStream.close();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;\n\n字节流FileInputstream复制文件原理 \n代码实现\n复制文件，代码如下：\npublic class Copy &#123;    public static void main(String[] args) throws IOException &#123;        // 1.创建流对象        // 1.1 指定数据源        FileInputStream fis = new FileInputStream(&quot;D:\\\\test.jpg&quot;);        // 1.2 指定目的地        FileOutputStream fos = new FileOutputStream(&quot;test_copy.jpg&quot;);        // 2.读写数据        // 2.1 定义数组        byte[] b = new byte[1024];        // 2.2 定义长度        int len;        // 2.3 循环读取        while ((len = fis.read(b))!=-1) &#123;            // 2.4 写出数据            fos.write(b, 0 , len);        &#125;        // 3.关闭资源        fos.close();        fis.close();    &#125;&#125;\n\n字符流\n字符流 &#x3D; 字节流 + 编码表\n\n使用字符流：\npublic class CharaterStream &#123;    public static void main(String[] args) throws Exception &#123;        FileInputStream inputStream = new FileInputStream(&quot;a.txt&quot;);        byte[] bytes = new byte[1024];        int len;        while ((len=inputStream.read(bytes))!=-1)&#123;           System.out.print(new String(bytes,0,len));        &#125;    &#125;&#125;\n\n字符输入流（Reader）java.io.Reader抽象类是字符输入流的所有类的超类（父类），可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。\n字符输入流的共性方法：\n\npublic void close() ：关闭此流并释放与此流相关联的任何系统资源。\npublic int read()： 从输入流读取一个字符。\npublic int read(char[] cbuf)： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中\n\nFileReader类java.io.FileReader 类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。\n构造方法\nFileReader(File file)： 创建一个新的 FileReader ，给定要读取的File对象。\nFileReader(String fileName)： 创建一个新的 FileReader ，给定要读取的文件的字符串名称。\n\npublic class FileReaderConstructor throws IOException&#123;    public static void main(String[] args) &#123;   \t \t// 使用File对象创建流对象        File file = new File(&quot;a.txt&quot;);        FileReader fr = new FileReader(file);              // 使用文件名称创建流对象        FileReader fr = new FileReader(&quot;b.txt&quot;);    &#125;&#125;\n\nFileReader读取字符数据public class FRRead &#123;    public static void main(String[] args) throws IOException &#123;      \t// 使用文件名称创建流对象       \tFileReader fr = new FileReader(&quot;new.txt&quot;);      \t// 定义变量，保存数据        int b ；        // 循环读取        while ((b = fr.read())!=-1) &#123;            System.out.println((char)b);        &#125;\t\t// 关闭资源        fr.close();    &#125;&#125;\n\n字符输出流（Writer）java.io.Writer 抽象类是字符输出流的所有类的超类（父类），将指定的字符信息写出到目的地。它同样定义了字符输出流的基本共性功能方法。\n字符输出流的基本共性功能方法：\n\nvoid write(int c) 写入单个字符。\nvoid write(char[] cbuf) 写入字符数组。\nabstract  void write(char[] cbuf, int off, int len) 写入字符数组的某一部分,off数组的开始索引,len写的字符个数。\nvoid write(String str) 写入字符串。\nvoid write(String str, int off, int len) 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。\nvoid flush() 刷新该流的缓冲。\nvoid close() 关闭此流，但要先刷新它。\n\nFileWriter类java.io.FileWriter 类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。\n构造方法1、 FileWriter(File file)： 创建一个新的 FileWriter，给定要读取的File对象。 2、FileWriter(String fileName)： 创建一个新的 FileWriter，给定要读取的文件的名称。\npublic class FileWriterConstructor &#123;    public static void main(String[] args) throws IOException &#123;   \t \t// 第一种：使用File对象创建流对象        File file = new File(&quot;a.txt&quot;);        FileWriter fw = new FileWriter(file);              // 第二种：使用文件名称创建流对象        FileWriter fw = new FileWriter(&quot;b.txt&quot;);    &#125;&#125;\n\nFileWriter写出数据写出字符：write(int b) 方法，每次可以写出一个字符数据，代码使用演示：\npublic class FWWrite &#123;    public static void main(String[] args) throws IOException &#123;        // 使用文件名称创建流对象        FileWriter fw = new FileWriter(&quot;fw.txt&quot;);           \t// 写出数据      \tfw.write(97); // 写出第1个字符      \tfw.write(&#x27;b&#x27;); // 写出第2个字符      \tfw.write(&#x27;C&#x27;); // 写出第3个字符      \t        //关闭资源时,与FileOutputStream不同。 如果不关闭,数据只是保存到缓冲区，并未保存到文件。        // fw.close();    &#125;&#125;\n\n\n注：关闭资源时,与FileOutputStream不同。 如果不关闭,数据只是保存到缓冲区，并未保存到文件。\n\n关闭close和刷新flush因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要flush 方法了。\nflush ：刷新缓冲区，流对象可以继续使用。close  ：先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。\npublic class FWWrite &#123;    public static void main(String[] args) throws IOException &#123;        // 使用文件名称创建流对象        FileWriter fw = new FileWriter(&quot;fw.txt&quot;);        // 写出数据，通过flush        fw.write(&#x27;刷&#x27;); // 写出第1个字符        fw.flush();        fw.write(&#x27;新&#x27;); // 继续写出第2个字符，写出成功        fw.flush();            \t// 写出数据，通过close        fw.write(&#x27;关&#x27;); // 写出第1个字符        fw.close();        fw.write(&#x27;闭&#x27;); // 继续写出第2个字符,【报错】java.io.IOException: Stream closed        fw.close();    &#125;&#125;\n\nFileWriter的续写和换行public class FWWrite &#123;    public static void main(String[] args) throws IOException &#123;        // 使用文件名称创建流对象，可以续写数据        FileWriter fw = new FileWriter(&quot;new.txt&quot;，true);           \t// 写出字符串        fw.write(&quot;Hello&quot;);      \t// 写出换行      \tfw.write(&quot;\\r\\n&quot;);      \t// 写出字符串  \t\tfw.write(&quot;World&quot;);      \t// 关闭资源        fw.close();    &#125;&#125;\n\nFileReader和FileWriter类完成文本文件复制import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;public class CopyFile &#123;    public static void main(String[] args) throws IOException &#123;        //创建输入流对象        FileReader fr=new FileReader(&quot;F:\\\\新建文件夹\\\\aa.txt&quot;);//文件不存在会抛出java.io.FileNotFoundException        //创建输出流对象        FileWriter fw=new FileWriter(&quot;C:\\\\copyaa.txt&quot;);        /*创建输出流做的工作：         *      1、调用系统资源创建了一个文件         *      2、创建输出流对象         *      3、把输出流对象指向文件                 * */        //文本文件复制，一次读一个字符        copyMethod1(fr, fw);        //文本文件复制，一次读一个字符数组        copyMethod2(fr, fw);                fr.close();        fw.close();    &#125;    public static void copyMethod1(FileReader fr, FileWriter fw) throws IOException &#123;        int ch;        while((ch=fr.read())!=-1) &#123;//读数据            fw.write(ch);//写数据        &#125;        fw.flush();    &#125;    public static void copyMethod2(FileReader fr, FileWriter fw) throws IOException &#123;        char chs[]=new char[1024];        int len=0;        while((len=fr.read(chs))!=-1) &#123;//读数据            fw.write(chs,0,len);//写数据        &#125;        fw.flush();    &#125;&#125;\n\nIO异常的处理public class HandleException1 &#123;    public static void main(String[] args) &#123;      \t// 声明变量        FileWriter fw = null;        try &#123;            //创建流对象            fw = new FileWriter(&quot;fw.txt&quot;);            // 写出数据            fw.write(&quot;哥敢摸si&quot;); //哥敢摸si        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            try &#123;                if (fw != null) &#123;                    fw.close();                &#125;            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;\n\n缓冲流概述首先我们来认识认识一下缓冲流,也叫高效流，是对4个FileXxx 流的“增强流”。\n缓冲流的基本原理：\n\n使用了底层流对象从具体设备上获取数据，并将数据存储到缓冲区的数组内。\n通过缓冲区的read()方法从缓冲区获取具体的字符数据，这样就提高了效率。\n如果用read方法读取字符数据，并存储到另一个容器中，直到读取到了换行符时，将另一个容器临时存储的数据转成字符串返回，就形成了readLine()功能。\n\n字节缓冲流构造方法\npublic BufferedInputStream(InputStream in) ：创建一个新的缓冲输入流，注意参数类型为InputStream。\npublic BufferedOutputStream(OutputStream out)： 创建一个新的缓冲输出流，注意参数类型为OutputStream。\n\n构造举例代码如下：\n//构造方式一： 创建字节缓冲输入流【但是开发中一般常用下面的格式申明】FileInputStream fps = new FileInputStream(b.txt);BufferedInputStream bis = new BufferedInputStream(fps)//构造方式一： 创建字节缓冲输入流BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;b.txt&quot;));///构造方式二： 创建字节缓冲输出流BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;b.txt&quot;));\n\n感受缓冲流的高效缓冲流读写方法与基本的流是一致的，我们通过复制370多MB的大文件，测试它的效率。\n\n基本流，代码如下：\n\npublic class BufferedDemo &#123;    public static void main(String[] args) throws FileNotFoundException &#123;        // 记录开始时间      \tlong start = System.currentTimeMillis();\t\t// 创建流对象        try (        \tFileInputStream fis = new FileInputStream(&quot;py.exe&quot;);//exe文件够大        \tFileOutputStream fos = new FileOutputStream(&quot;copyPy.exe&quot;)        )&#123;        \t// 读写数据            int b;            while ((b = fis.read()) != -1) &#123;                fos.write(b);            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;\t\t// 记录结束时间        long end = System.currentTimeMillis();        System.out.println(&quot;普通流复制时间:&quot;+(end - start)+&quot; 毫秒&quot;);    &#125;&#125;不好意思十分钟过去了还在玩命复制中...\n\n\n缓冲流，代码如下：\n\npublic class BufferedDemo &#123;    public static void main(String[] args) throws FileNotFoundException &#123;        // 记录开始时间      \tlong start = System.currentTimeMillis();\t\t// 创建流对象        try (         BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;py.exe&quot;));\t     BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;copyPy.exe&quot;));        )&#123;        // 读写数据            int b;            while ((b = bis.read()) != -1) &#123;                bos.write(b);            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;\t\t// 记录结束时间        long end = System.currentTimeMillis();        System.out.println(&quot;缓冲流复制时间:&quot;+(end - start)+&quot; 毫秒&quot;);    &#125;&#125;缓冲流复制时间:8016 毫秒\n\n想要更快可以使用数组的方式，代码如下：\npublic class BufferedDemo &#123;    public static void main(String[] args) throws FileNotFoundException &#123;      \t// 记录开始时间        long start = System.currentTimeMillis();\t\t// 创建流对象        try (\t\t BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;py.exe&quot;));\t\t BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;copyPy.exe&quot;));        )&#123;          \t// 读写数据            int len;            byte[] bytes = new byte[8*1024];            while ((len = bis.read(bytes)) != -1) &#123;                bos.write(bytes, 0 , len);            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;\t\t// 记录结束时间        long end = System.currentTimeMillis();        System.out.println(&quot;缓冲流使用数组复制时间:&quot;+(end - start)+&quot; 毫秒&quot;);    &#125;&#125;缓冲流使用数组复制时间:521 毫秒  \n\n字符缓冲流构造方法相同的来看看其构造，其格式以及原理和字节缓冲流是一样一样的！\n\npublic BufferedReader(Reader in) ：创建一个新的缓冲输入流，注意参数类型为Reader。\npublic BufferedWriter(Writer out)： 创建一个新的缓冲输出流，注意参数类型为Writer。\n\n构造举例，代码如下：\n// 创建字符缓冲输入流BufferedReader br = new BufferedReader(new FileReader(&quot;b.txt&quot;));// 创建字符缓冲输出流BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;b.txt&quot;));\n\n字符缓冲流特有方法字符缓冲流的基本方法与普通字符流调用方式一致，这里不再阐述，我们来看字符缓冲流具备的特有方法。\n\nBufferedReader：public String readLine(): 读一行数据。 读取到最后返回null\nBufferedWriter：public void newLine(): 换行,由系统属性定义符号。\n\nreadLine方法演示代码如下：\npublic class BufferedReaderDemo &#123;    public static void main(String[] args) throws IOException &#123;      \t // 创建流对象        BufferedReader br = new BufferedReader(new FileReader(&quot;a.txt&quot;));\t\t// 定义字符串,保存读取的一行文字        String line  = null;      \t// 循环读取,读取到最后返回null        while ((line = br.readLine())!=null) &#123;            System.out.print(line);            System.out.println(&quot;------&quot;);        &#125;\t\t// 释放资源        br.close();    &#125;&#125;\n\nnewLine方法演示代码如下：\npublic class BufferedWriterDemo throws IOException &#123;  public static void main(String[] args) throws IOException  &#123;    \t// 创建流对象  \tBufferedWriter bw = new BufferedWriter(new FileWriter(&quot;b.txt&quot;));    \t// 写出数据      bw.write(&quot;He);    \t// 写出换行      bw.newLine();      bw.write(&quot;ll&quot;);      bw.newLine();      bw.write(&quot;o&quot;);      bw.newLine();      bw.write(&quot;World&quot;);      bw.newLine();  \t\t// 释放资源      bw.close();  &#125;&#125;\n\n字符缓冲流练习6.你说你的程序叫简单，我说我的代码叫诗篇1.一想到你我就哦豁豁豁豁豁豁豁豁豁豁....哦nima个头啊，完全不理人家受得了受不了8.Just 简单你和我  ，Just 简单程序员3.约了地点却忘了见面 ，懂得寂寞才明白浩瀚5.沉默是最大的发言权2.总是喜欢坐在电脑前，  总是喜欢工作到很晚7.向左走 又向右走，我们转了好多的弯4.你从来就不问我，你还是不是那个程序员\n\n代码实现public class BufferedTest &#123;    public static void main(String[] args) throws IOException &#123;        // 创建map集合,保存文本数据,键为序号,值为文字        HashMap&lt;String, String&gt; lineMap = new HashMap&lt;&gt;();        // 创建流对象  源        BufferedReader br = new BufferedReader(new FileReader(&quot;a.txt&quot;));        //目标        BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;b.txt&quot;));        // 读取数据        String line  = null;        while ((line = br.readLine())!=null) &#123;            // 解析文本            String[] split = line.split(&quot;\\\\.&quot;);            // 保存到集合            lineMap.put(split[0],split[1]);        &#125;        // 释放资源        br.close();        // 遍历map集合        for (int i = 1; i &lt;= lineMap.size(); i++) &#123;            String key = String.valueOf(i);            // 获取map中文本            String value = lineMap.get(key);          \t// 写出拼接文本            bw.write(key+&quot;.&quot;+value);          \t// 写出换行            bw.newLine();        &#125;\t\t// 释放资源        bw.close();    &#125;&#125;\n\n运行效果：\n1.一想到你我就哦豁豁豁豁豁豁豁豁豁豁…哦nima个头啊，完全不理人家受得了受不了2.总是喜欢坐在电脑前， 总是喜欢工作到很晚3.约了地点却忘了见面 ，懂得寂寞才明白浩瀚4.你从来就不问我，你还是不是那个程序员5.沉默是最大的发言权6.你说你的程序叫简单，我说我的代码叫诗篇7.向左走 又向右走，我们转了好多的弯8.Just 简单你和我 ，Just 简单程序员\n\n转换流字符流&#x3D;字节流+编码表\nString(byte[] bytes, String charsetName):通过指定的字符集解码字节数组byte[] getBytes(String charsetName):使用指定的字符集合把字符串编码为字节数组编码:把看得懂的变成看不懂的String -- byte[]解码:把看不懂的变成看得懂的byte[] -- String\n\n\n字符编码 Character Encoding: 就是一套自然语言的字符与二进制数之间的对应规则。\n而编码表则是生活中文字和计算机中二进制的对应规则\n\n\n字符集\n字符集 Charset：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。\n\n计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBK字符集、Unicode字符集等。 \n\nASCII字符集 ：\n\nASCII（American Standard Code for Information  Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。\n基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。ASCII的扩展字符集使用8位（bits）表示一个字符，共256字符，方便支持欧洲常用字符。\n\n\nISO-8859-1字符集 ：\n\n拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。\nISO-8859-1使用单字节编码，兼容ASCII编码。\n\n\nGBxxx字符集 ：\n\nGB就是国标的意思，是为了显示中文而设计的一套字符集。\nGB2312：简体中文码表。一个小于127的字符的意义与原来相同。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。\nGBK：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。\nGB18030：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。\n\n\nUnicode字符集 ：\n\nUnicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。\n它最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF-32。最为常用的UTF-8编码。\nUTF-8编码，可以用来表示Unicode标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。所以，我们开发Web应用，也要使用UTF-8编码。它使用一至四个字节为每个字符编码，编码规则：\n128个US-ASCII字符，只需一个字节编码。\n拉丁文等字符，需要二个字节编码。\n大部分常用字（含中文），使用三个字节编码。\n其他极少使用的Unicode辅助字符，使用四字节编码。\n\n\n\n\n\nInputStreamReader类(字节流到字符流的桥梁)转换流java.io.InputStreamReader，是Reader的子类，从字面意思可以看出它是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。\n构造方法\nInputStreamReader(InputStream in): 创建一个使用默认字符集的字符流。InputStreamReader(InputStream in, String charsetName): 创建一个指定字符集的字符流。\n\nInputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;in.txt&quot;));InputStreamReader isr2 = new InputStreamReader(new FileInputStream(&quot;in.txt&quot;) , &quot;GBK&quot;);\n\n使用转换流解决编码问题public class ReaderDemo2 &#123;    public static void main(String[] args) throws IOException &#123;      \t// 定义文件路径,文件为gbk编码        String FileName = &quot;C:\\\\A.txt&quot;;      \t// 创建流对象,默认UTF8编码        InputStreamReader isr = new InputStreamReader(new FileInputStream(FileName));      \t// 创建流对象,指定GBK编码        InputStreamReader isr2 = new InputStreamReader(new FileInputStream(FileName) , &quot;GBK&quot;);\t\t// 定义变量,保存字符        int read;      \t// 使用默认编码字符流读取,乱码        while ((read = isr.read()) != -1) &#123;            System.out.print((char)read); // �����ʺ              &#125;        isr.close();            \t// 使用指定编码字符流读取,正常解析        while ((read = isr2.read()) != -1) &#123;            System.out.print((char)read);// 美丽水世界        &#125;        isr2.close();    &#125;&#125;\n\nOutputStreamWriter类(字符流到字节流的桥梁)构造方法\nOutputStreamWriter(OutputStream in): 创建一个使用默认字符集的字符流。OutputStreamWriter(OutputStream in, String charsetName): 创建一个指定字符集的字符流。\n\n构造举例，代码如下：\nOutputStreamWriter isr = new OutputStreamWriter(new FileOutputStream(&quot;a.txt&quot;));OutputStreamWriter isr2 = new OutputStreamWriter(new FileOutputStream(&quot;b.txt&quot;) , &quot;GBK&quot;);\n\n指定编码构造代码public class OutputDemo &#123;    public static void main(String[] args) throws IOException &#123;      \t// 定义文件路径        String FileName = &quot;C:\\\\s.txt&quot;;      \t// 创建流对象,默认UTF8编码        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(FileName));        // 写出数据      \tosw.write(&quot;哥敢&quot;); // 保存为6个字节        osw.close();      \t\t\t// 定义文件路径\t\tString FileName2 = &quot;D:\\\\A.txt&quot;;     \t// 创建流对象,指定GBK编码        OutputStreamWriter osw2 = new OutputStreamWriter(new FileOutputStream(FileName2),&quot;GBK&quot;);        // 写出数据      \tosw2.write(&quot;摸屎&quot;);// 保存为4个字节        osw2.close();    &#125;&#125;\n\n 为了达到最高效率，可以考虑在 BufferedReader 内包装 InputStreamReader\nBufferedReader in = new BufferedReader(new InputStreamReader(System.in))；\n\n序列化流概述Java 提供了一种对象序列化的机制。用一个字节序列可以表示一个对象，该字节序列包含该对象的数据、对象的类型和对象中存储的属性等信息。字节序列写出到文件之后，相当于文件中持久保存了一个对象的信息。\n反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化。对象的数据、对象的类型和对象中存储的数据信息，都可以用来在内存中创建对象。看图理解序列化： \nObjectOutputStream类java.io.ObjectOutputStream  类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。\n构造方法public ObjectOutputStream(OutputStream out) ： 创建一个指定OutputStream的ObjectOutputStream。\n构造代码如下：\nFileOutputStream fileOut = new FileOutputStream(&quot;aa.txt&quot;);ObjectOutputStream out = new ObjectOutputStream(fileOut);\n\n序列化操作\n一个对象要想序列化，必须满足两个条件:\n\n该类必须实现java.io.Serializable  接口，Serializable 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出NotSerializableException 。\n该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用transient 关键字修饰。\npublic class Employee implements java.io.Serializable &#123;    public String name;    public String address;    public transient int age; // transient瞬态修饰成员,不会被序列化    public void addressCheck() &#123;      \tSystem.out.println(&quot;Address  check : &quot; + name + &quot; -- &quot; + address);    &#125;&#125;\n\n2.写出对象方法\npublic final void writeObject (Object obj) : 将指定的对象写出。\npublic class SerializeDemo&#123;   \tpublic static void main(String [] args)   &#123;    \tEmployee e = new Employee();    \te.name = &quot;zhangsan&quot;;    \te.address = &quot;beiqinglu&quot;;    \te.age = 20;     \ttry &#123;      \t\t// 创建序列化流对象          ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;employee.txt&quot;));        \t// 写出对象        \tout.writeObject(e);        \t// 释放资源        \tout.close();        \tfileOut.close();        \tSystem.out.println(&quot;Serialized data is saved&quot;); // 姓名，地址被序列化，年龄没有被序列化。        &#125; catch(IOException i)   &#123;            i.printStackTrace();        &#125;   \t&#125;&#125;输出结果：Serialized data is saved\n\nObjectInputStream类ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。\n构造方法public ObjectInputStream(InputStream in) ： 创建一个指定InputStream的ObjectInputStream。\n反序列化操作1如果能找到一个对象的class文件，我们可以进行反序列化操作，调用ObjectInputStream读取对象的方法：\n\npublic final Object readObject () : 读取一个对象。\n\npublic class DeserializeDemo &#123;   public static void main(String [] args)   &#123;        Employee e = null;        try &#123;\t\t             // 创建反序列化流             FileInputStream fileIn = new FileInputStream(&quot;employee.txt&quot;);             ObjectInputStream in = new ObjectInputStream(fileIn);             // 读取一个对象             e = (Employee) in.readObject();             // 释放资源             in.close();             fileIn.close();        &#125;catch(IOException i) &#123;             // 捕获其他异常             i.printStackTrace();             return;        &#125;catch(ClassNotFoundException c)  &#123;        \t// 捕获类找不到异常             System.out.println(&quot;Employee class not found&quot;);             c.printStackTrace();             return;        &#125;        // 无异常,直接打印输出        System.out.println(&quot;Name: &quot; + e.name);\t// zhangsan        System.out.println(&quot;Address: &quot; + e.address); // beiqinglu        System.out.println(&quot;age: &quot; + e.age); // 0    &#125;&#125;\n\n对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 ClassNotFoundException 异常。\n反序列化操作2另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个InvalidClassException异常。发生这个异常的原因如下：\n\n该类的序列版本号与从流中读取的类描述符的版本号不匹配\n该类包含未知数据类型\n该类没有可访问的无参数构造方法\n\nSerializable 接口给需要序列化的类，提供了一个序列版本号。serialVersionUID 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。\npublic class Employee implements java.io.Serializable &#123;     // 加入序列版本号     private static final long serialVersionUID = 1L;     public String name;     public String address;     // 添加新的属性 ,重新编译, 可以反序列化,该属性赋为默认值.     public int eid;      public void addressCheck() &#123;         System.out.println(&quot;Address  check : &quot; + name + &quot; -- &quot; + address);     &#125;&#125;\n\n序列化集合练习\n将存有多个自定义对象的集合序列化操作，保存到list.txt文件中。\n反序列化list.txt ，并遍历集合，打印对象信息。\n\n案例分析\n把若干学生对象 ，保存到集合中。\n把集合序列化。\n反序列化读取时，只需要读取一次，转换为集合类型。\n遍历集合，可以打印所有的学生信息\n\n案例代码实现public class SerTest &#123;\tpublic static void main(String[] args) throws Exception &#123;\t\t// 创建 学生对象\t\tStudent student = new Student(&quot;老王&quot;, &quot;laow&quot;);\t\tStudent student2 = new Student(&quot;老张&quot;, &quot;laoz&quot;);\t\tStudent student3 = new Student(&quot;老李&quot;, &quot;laol&quot;);\t\tArrayList&lt;Student&gt; arrayList = new ArrayList&lt;&gt;();\t\tarrayList.add(student);\t\tarrayList.add(student2);\t\tarrayList.add(student3);\t\t// 序列化操作\t\t// serializ(arrayList);\t\t\t\t// 反序列化  \t\tObjectInputStream ois  = new ObjectInputStream(new FileInputStream(&quot;list.txt&quot;));\t\t// 读取对象,强转为ArrayList类型\t\tArrayList&lt;Student&gt; list  = (ArrayList&lt;Student&gt;)ois.readObject();\t\t      \tfor (int i = 0; i &lt; list.size(); i++ )&#123;          \tStudent s = list.get(i);        \tSystem.out.println(s.getName()+&quot;--&quot;+ s.getPwd());      \t&#125;\t&#125;\tprivate static void serializ(ArrayList&lt;Student&gt; arrayList) throws Exception &#123;\t\t// 创建 序列化流 \t\tObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;list.txt&quot;));\t\t// 写出对象\t\toos.writeObject(arrayList);\t\t// 释放资源\t\toos.close();\t&#125;&#125;\n\n打印流概述平时我们在控制台打印输出，是调用print方法和println方法完成的，各位用了这么久的输出语句肯定没想过这两个方法都来自于java.io.PrintStream类吧，哈哈。该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。\n打印流分类：\n\n字节打印流PrintStream，字符打印流PrintWriter\n\n打印流特点：\n\nA:只操作目的地,不操作数据源B:可以操作任意类型的数据C:如果启用了自动刷新，在调用println()方法的时候，能够换行并刷新D:可以直接操作文件\n\n这个时候有同学就要问了，哪些流可以直接操作文件呢?答案很简单，如果该流的构造方法能够同时接收File和String类型的参数，一般都是可以直接操作文件的！\nPrintStream是OutputStream的子类，PrintWriter是Writer的子类，两者处于对等的位置上，所以它们的API是非常相似的。二者区别无非一个是字节打印流，一个是字符打印流。\n字节输出打印流PrintStream复制文本文件import java.io.BufferedReader;import java.io.FileReader;import java.io.IOException;import java.io.PrintStream;public class PrintStreamDemo &#123;    public static void main(String[] args) throws IOException &#123;        BufferedReader br=new BufferedReader(new FileReader(&quot;copy.txt&quot;));        PrintStream ps=new PrintStream(&quot;printcopy.txt&quot;);        String line;        while((line=br.readLine())!=null) &#123;            ps.println(line);        &#125;        br.close();        ps.close();    &#125;&#125;\n\n字符输出打印流PrintWriter复制文本文件import java.io.BufferedReader;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;import java.io.PrintWriter;/** * 使用打印流复制文本文件 */public class PrintWriterDemo &#123;    public static void main(String[] args) throws IOException &#123;        BufferedReader br=new BufferedReader(new FileReader(&quot;aa.txt&quot;));        PrintWriter pw=new PrintWriter(&quot;printcopyaa.txt&quot;);        String line;        while((line=br.readLine())!=null) &#123;            pw.println(line);        &#125;        br.close();        pw.close();    &#125;&#125;","categories":["WEBbackend"],"tags":["Java"]},{"title":"Java泛型","url":"/2022/11/03/WebBackend/Java/Java%E6%B3%9B%E5%9E%8B/","content":"java 中泛型标记符：\n\nE - Element (在集合中使用，因为集合中存放的是元素)\nT - Type（Java 类）\nK - Key（键）\nV - Value（值）\nN - Number（数值类型）\n？ - 表示不确定的 java 类型\n\n","categories":["WEBbackend"],"tags":["Java"]},{"title":"Windows本地MySQL安装","url":"/2022/09/11/DBMS/MySql/Windows%E6%9C%AC%E5%9C%B0MySQL%E5%AE%89%E8%A3%85/","content":"Windows本地MySQL安装下载下载地址\n选择MySQL版本，以及计算机系统\n这里选择5.7.24，比较稳定\n\n安装(解压)解压到安装目录\n\n配置添加环境配置复制你MySQL的路径，变量名填MYSQL_HOME\n\n在系统变量，Path里添加：\n%MYSQL_HOME%\\bin\n\n\n新建配置文件在\\mysql-5.7.24-winx64\\bin 目录下新建my.ini文本文件\n\n右键记事本打开，内容如下：\n[mysqld]default-character-set=utf8[mysqld]character-set-server=utf8default-storage-engine=INNODBsql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION\n\n\n初始化MySQlmysqld --initialize-insecure\n\n\n注册MySQL服务mysqld -install\n\n\n启动MySQL服务net start mysql\n\n\n停止mysql服务：\nnet stop mysql\n\n修改账户默认密码mysqladmin -u root password 1234\n\n\n登录MySQL出现下午左下角为mysql&gt;，则登录成功。\nmysql -uroot -p1234\n\n\n到这里你就可以开始你的MySQL之旅了！\n退出mysql：\nexitquit\n\n登录参数：\nmysql -u用户名 -p密码 -h要连接的mysql服务器的ip地址(默认127.0.0.1) -P端口号(默认3306)\n\n卸载MySQLnet stop mysql\n\nmysqld -remove mysql\n\n最后删除MySQL目录以及相关的环境变量\n","categories":["WEBbackend"],"tags":["mysql"]},{"title":"Java继承","url":"/2022/11/10/WebBackend/Java/Java%E7%BB%A7%E6%89%BF/","content":"Introduction继承（inheritance）。继承的基本思想是，可以基于已有的类创建新的类。继承已存在的类就是复用（继承）这些类的方法，而且可以增加一些新的方法和字段，是新类能够适应新的情况。\nClass、superclass and subclass定义subclass继承Employee类来定义Manager类，这里使用关键字extends表示继承。\npublic class Manager extends Employee&#123;    added methods and fields&#125;\n\n\nC++&#x2F;C# 注：Java与C++定义继承的方式十分相似。Java用关键字替代了C++和C#中的冒号( : )。在Java中，所有继承都是公开继承。 \n\n关键字extends表明正在构造的新类派生于一个存在的类。\n已存在的类称为：超类(superclass)、基类(base class)或父类(parent class);\n新类称为：子类(subclass)、派生类(derived class)或孩子类(child class)\n\n注：前缀**超(super)和子(sub)**来源于计算机科学与数学理论中集合语言的术语。所有员工组成的集合包含所有经理组成的集合。即，员工集合是经理集合的超级，也可以说，经理集合是员工集合的子集。\n\n在Manager类中增加一个用于存储奖金信息的字段，以及一个用于设置这个字段的新方法：\npublic class Manager extends Employee&#123;    private double bonus;    ...    public void setBonus(double bonus)    &#123;        this.bonus = bonus;    &#125;&#125;\n\noverride方法超类中的有些方法对子类Manager不一定使用。具体来说，Manager类中getSalary方法应该返回薪水和奖金的总和。为此需要提供一个新的方法来**覆盖(override)**超类中的这个方法：\npublic class Manager extends Employee&#123;    ...    public double getSalary()    &#123;        double baseSalary = super.getSalary();        return baseSalary + bonus;    &#125;    ...&#125;\n\n在这里，我们希望调用超类Employee中的getSalary方法，而不是当前类的这个方法。为此，可以使用特殊的关键字super解决这个问题:\n\n注：有些人认为super与this引用是类似的概念，实际上，这样比较并不太恰当。这是因为super不是一个对象的引用，例如，不能将值super赋给另一个对象变量，它只是一个指示编译器调用超类方法的特殊关键字。\n\n正像前面所看到的那样，在子类可以增加字段、增加方法或覆盖超类的方法，不过，继承绝不会删除任何字段或方法。\n\nC++注：在Java中使用关键字super调用超类的方法，而在C++中则采用超类名加::操作符的形式。例如，Manager类的getSalary方法要调用Employee::getSalary而不是super.getSalarty。\n\nsubclass构造器public Manager(String name,double salary,int year,int month,int day)&#123;    super(name,salary,year,month,day);    bonus = 0;&#125;\n\n这里的关键字super具有不同的含义。语句super(name,salary,year,month,day);是”调用超类Employee中带有name、salary、year、month和day参数的构造器“的简写形式。\n由于Manager类的构造器不能访问Employee类的私有字段，所以必须通过一个构造器来初始化这些私有字段。可以利用特殊的super语法调用这个构造器。使用super调用构造器的语法句必须是子类构造器的第一条语句。\n如果子类的构造器没有显式地调用超类的构造器，将自动地调用超类的无参数构造器。如果超类没有无参数的构造器，并且在子类的构造器中又没有显式地调用超类的其他构造器，Java编译器就会报告一个错误。\n\n回想一下，关键字this有两个含义：一是指示隐式参数的引用，二是调用该类的其他构造器。\n类似地，super关键字也有两个含义：一是调用超类的方法，二是调用超类的构造器。在调用构造器的时候，this和super这两个关键字紧密相关。调用构造器的语句只能作为另一个构造器的第一条语句出现。构造器参数可以传递给当前类(this)的另一个构造器，也可以传递给超类(super)的构造器。\n\n创建一个新经理，并设置他的奖金：\nManager boss = new Manager(&quot;Carl Cracker&quot;,80000,1987,12,15);boss.setBonus(5000);\n\n下面定义一个包含3个员工的数组：\nvar staff = new Employee[3];\n\n在数组中混合填入经理和员工：\nstaff[0] = boss;staff[1] = new Employee(&quot;Harry Hacker&quot;,50000,1989,10,1);staff[2] = new Employee(&quot;Tony Tester&quot;,40000,1990,3,15);\n\n输出每个人的薪水：\nfor (Employee e : staff)&#123;    System.out.println(e.getName() + &quot; &quot; + e.getSalary());&#125;//输出：//\tCarl Cracker 85000.0//\tHarry Hacker 50000.0//\tTommy Tester 40000.0\n\n一个对象变量（例如，变量e）可以指示多种实际类型的现象称为**多态(polymorphism)。在运行时能够自动地选择适当的方法，称为动态绑定(dynamic binding)**。\n\nC++注：在C++中，如果希望实现动态绑定，需要将成员函数声明为virtual。在Java中，动态绑定是默认的行为。如果不希望让一个方法是虚拟的，可以将它标记为final\n\n/* File name: ManagerTest.java */public class ManagerTest&#123;    public static void main(String[] args)    &#123;        // construct a Manager object        var boss = new Manager(&quot;Carl Cracker&quot;,80000,1987,12,15);        boss.setBonus(5000);                var staff = new Employee[3];                // fill the staff array with Manager and Employee objects                staff[0] = boss;        staff[1] = new Employee(&quot;Harry Hacker&quot;,50000,1989,10,1);        staff[2] = new Employee(&quot;Tommy Tester&quot;,40000,1990,3,15);                // print out information about all Employee objects        for (Employee e : staff)            System.out.println(&quot;name=&quot; + e.getName() + &quot;,salary=&quot; + e.getSalary());    &#125;&#125;\n\n/* File name: Employee.java */public class Employee&#123;    private String name;    private double salary;    private LocalDate hireDay;        public Employee(String name,double salary,int year,int month,int day)    &#123;        this.name = name;        this.salary = salary;        hireDay = LocalDate.of(year,month,day);    &#125;        public String getName()    &#123;        return name;    &#125;        public double getSalary()    &#123;        return salary;    &#125;        public LocalDate getHireDay()    &#123;        return hireDay;    &#125;        public void raiseSalary(double byPercent)    &#123;        double raise = salary * byPercent / 100;        salary += raise;    &#125;&#125;\n\npublic class Manager extends Employee&#123;    private double bonus;        public Manager(String name,double salary,int year,int month,int day)    &#123;        super(name,salary,year,month,day);        bonus = 0;    &#125;        public double getSalary()    &#123;        double baseSalary = super.getSalary();        return baseSalary + bonus;    &#125;        public void setBonus(double b)    &#123;        bonus = b;    &#125;&#125;\n\n多态有一个简单规则可以用来判断是否应该将数据设计为继承关系，这就是is-a规则，它指出子类的每个对象也是超类的对象\n。例如，每个经理都是员工，因此，将Manager类设计为Employee类的子类是有道理的。\nis-a规则的另一种表述是替换原则（substitution principle）。它指出程序中出现超类对象任何地方都可以使用子类对象替换。\n例如，可以将子类的对象赋给超类变量：\nEmployee e;e = new Employee(...);\t//Employee object expectede = new Manager(...);\t//OK,Manager can be used well\n\n在Java程序设计语言中，对象变量是多态的（polymorphic）。一个Employee类型的变量即可以引用一个Employee类型的变量，也可以引用Employee类的任何一个子类的对象（例如，Manager、Executive、Secretary等）。\nManager boss = new Manager(...);Employee[] staff = new Employee[3];staff[0] = boss;\n\n在这个例子中，变量staff[0]与boss引用同一个对象。但编译器只将staff[0]看成是一个Employee对象。\nboss.setBonus(5000);\t\t// OKstaff[0].setBonus(5000);\t//ERRORManager m = staff[i];\t\t//ERROR\n\n理解方法调用假设调用：\nx.f(atgs)\n\n隐式参数x声明为类c的一个对象：\n\n编译器查看对象的声明类型和方法名。需要注意的是：有可能存在多个名字为f但参数类型不一样的方法。例如，可能存在方法f(int)和方法f(String)。编译器将会一一列举C类中所有名为f但参数类型不一样的方法。例如，可能存在方法f(int)和方法f(String)。\n\n接下来，编译器要确定方法调用中提供的参数类型。如果在所有名为f的方法中存在一个与所类型提供参数类型完全匹配的方法，就选择这个方法。这个过程称为重载解析(overloading resolution)\n\n如果是private方法、static方法、final方法 或者构造器，那么编译器将可以准确地知道应该调用哪个方法。这称为静态绑定(static binding)\n\n程序运行并且采用动态绑定调用方法时，虚拟机必须调用与x所引用对象的实际类型对应的那个方法。假设x的实际类型是D，它是C类的子类。如果D类定义了方法f(String), 就会调用这个方法；否则，将在D类的超类中寻找f(String)，以此类推。\n如果调用的是super.f(param)，那么编译器将对隐式参数超类的方法表进行搜索。\n\n\n阻止继承：final 类和方法有时候，我们可能希望阻止人们利用某个类定义子类。不允许扩展的类被称为final类。如果在定义类的时候使用了final修饰符就表明这个类是final类。例如，假设希望阻止人们派生Executive类的子类，就可以在声明这个类的时候使用final修饰符：\npublic final class Executive extends Manager&#123;    ...&#125;\n\n类中的某个特定方法也可以被声明为final。如果这样做，子类就不能覆盖这个方法（final 类中的所有方法自动地称为final方法）。例如：\npublic class Employee&#123;    ...    public final String getName()    &#123;        return name;    &#125;    ...&#125;\n\n\n注：对于final字段来说，构造对象之后就不允许改变它们的值了。不过，如果将一个类声明为final，只有其中的方法自动地称为final，而不包括字段。\n\n强制类型转换Java程序设计语言为强制类型转换提供了一种特殊的表示法。例如：\ndouble x = 3.405;int nx = (int) x;\n\n有时候也可能需要将某个类的对象引用转换成另一个类的对象引用。语法和数值表达式的强制类型转换类似，例如：\nManager boss = (Manager) staff[0];\n\n抽象类\npublic abstract String getDescroption();\t//no implementation required\n\n为了提高程序的清晰度，包含一个或多个抽象方法的类本身必须被声明为抽象的。\npublic abstract class Person&#123;    ...    public abstract String getDescription();&#125;\n\n除了抽象方法之外，抽象类还可以包含字段和具体方法。例如，Person类还保存着一个人的姓名，另外有一个返回姓名的具体方法。\npublic abstract class Person&#123;    private String name;        public Person(String name)    &#123;        this.name = name;    &#125;        public abstract String getDescription();        public String getName()    &#123;        return name;    &#125;&#125;\n\n抽象方法充当着占位方法的角色，它们在子类中具体实现。扩展抽象类可以有两种选择。\n一种是在子类中保留抽象类中的部分或所有抽象方法仍未定义，这样就必须将子类也标记为抽象类；\n另一种做法是定义全部方法，这样一来，子类就不是抽象的了。\n例如，通过扩展抽象Person类，并实现getDescription方法来定义Student类。由于在Student类中不再含有抽象方法，所以不需要将这个类声明为抽象类。\n抽象类不能实例化\n可以定义一个抽象类的对象变量，但是这样一个变量只能引用非抽象子类的对象。例如：\nPerson p = new Student(&quot;Vince Vu&quot;,&quot;Economics&quot;);\n\n这里的p是一个抽象类型Person的变量，它引用了一个非抽象子类Student的实例。\n\nC++注：在C++中，有一种抽象方法称为纯虚函数(pure virtual function)，要在末尾用 &#x3D; 0 标记，例如：\nclass Person //C++&#123; public: \tvirtual string getDescription() = 0; \t...&#125;;// 如果至少有一个纯虚函数，这个C++类就是抽象类。在C++中，没有提供用于表示抽象类的特殊关键字。\n\n如果至少有一个纯虚构函数，这个C++类就是抽象类。C++中，没有提供用于表示抽象类的特殊关键字。\n\n下面定义一个扩展抽象类Person的具体子类Student：\npublic class Student extends Person&#123;    private String major;        public Student(String name,String major)    &#123;        super(name);        this.major = major;    &#125;        public String getDescription()    &#123;        return &quot;a student majoring in &quot; + major;    &#125;&#125;\n\nStudent 类定义了 getDescription 方法，在 Student 类中的全部方法都是具体的，这个类不再是抽象类。\npublic class PersonTest&#123;    public static void main(String[] args)    &#123;        var people = new Person[2];                // fill the people array with Student and Employee objects        people[0] = new Employee(&quot;Harry Hacker&quot;,5000,1989,10,1);        people[1] = new Student(&quot;Maria Morris&quot;,&quot;computer science&quot;);                // print out names and descriptions of all Person objects        for (Person p : people)            System.out.println(p.getName() + &quot;, &quot; + p.getDescription)    &#125;&#125;\n\npublic abstract class Person&#123;    public abstract String getDescription();    private String name;        public Person(String name)    &#123;        this.name = name;    &#125;        public String getName()    &#123;        return name;    &#125;&#125;\n\npublic class Employee extends Person&#123;    private double salary;    private LocalDate hireDay;        public Employee(String name,double salary,int year,int month,int day)    &#123;        super(name);        this.salary = salary;        hireDay = LocalDate.of(year,month,day);    &#125;        public double getSalary()    &#123;        return salary;    &#125;        public LocalDate getHireDay()    &#123;        return hireDay;    &#125;        public String getDescripting()    &#123;        return String format(&quot;an employee with a salary of $%.2f&quot;,salary)    &#125;        public void raiseSalary(double byPercent)    &#123;        double raise = salary * byPercent / 100;        salart += raise;    &#125;&#125;\n\npublic class Student extends Person&#123;    private String major;        /**     * @param name the student&#x27;s name     * @param major the student&#x27;s major     */    public Student(String name,String major)    &#123;        // pass name to superclass constructor        super(name);        this.major = major;    &#125;        public String getDescription()    &#123;        return &quot;a student majoring in &quot; + major;    &#125;&#125;\n\n受保护访问\n仅对本类可见 —— private\n对外部完全可见 —— public\n对本包和所有子类可见 —— protected\n对本包可见 —— 默认，不需要修饰符\n\n\n C++注：Java中的受保护部分对所有子类及同一个包中的所有其他类都可见。这与C++中的保护机制稍有不同，Java中的protected概念要比C++中的安全性差。\n\nObject：所有类的超类Object类是Java中所有类的始祖，在Java中每个类都扩展了Object。但是并不需要这样写：\npublic class Employee extends Object\n\n如果没有明确地指出超类，Object就被认为是这个类的超类。\nObject类型的变量可以使用Object类型的变量引用任何类型的对象：\nObject obj = new Employee(&quot;Harry Hacker&quot;,35000);\n\n当然，Object类型的变量只能用于作为各种值的一个泛型容器。想要对其内容进行具体的操作，还需要清除对象的原始类型，并进行相应的强制类型转换：\nEmployee e = (Employee) obj;\n\n在Java中，只有基本类型（primitive）不是对象，例如，数值、字符和布尔类型的值都不是对象。\n所有的数组类型，不管是对象数组还是基本类型的数组都扩展了Object类。\nEmployee[] staff = new Employee[10];obj = staff;\t//OKobj = new int[10];\t// OK\n\n\nC++注：在C++中没有所有类的根类，不过，每个指针都可以转换成void*指针。\n\nequals方法Object类中的equals方法用于检测一个对象是否等于另外一个对象\n相等测试与继承如果隐式和显示的参数不属于同一个类equals方法就返沪false。\n但是许多程序员却喜欢使用instanceof进行检测：\nif (!(otherObject instanceof Employee)) return false;\n\n这样就允许otherObject属于一个子类。但是这种方法可能会招致一些麻烦。正因为这些麻烦，所以建议不要采用这种处理方式。Java语言规范要求equals方法具有下面的特性：\n\n自反性：对于任何非空引用x，x.equals(x) 应该返回true\n对称性：对于任何引用x和y，当且仅当y.equals(x) 返回 true时，x.equals(y) 返回 true\n传递性：对于任何引用x、y和z，如果x.equals(y)返回true，y.equals(z) 返回 true,x.equals(z) 也应该返回true \n一致性：如果x和y引用的对象么有发生变化，反复调用x.equals(y)应该返回同样的结果\n\nequals 方法的建议：\n\n显式参数命名为otherObject，稍后我们需要将它强制转换成另一个名为other的变量\n\n检测this与otherObject是否想等：\nif (this == otherObject) return true;\n\n检测otherObject是否为null：\nif (otherObject == null) return false;\n\n比较this与otherObject的类。如果equals的语句可以在子类中改变，就使用getClass检测：\nif (getClass() != otherObject.getClass()) return false;\n\n将otherObject强制转换为对应类型的变量：\nClassName other = (ClassName) otherObject\n\n使用 &#x3D;&#x3D; 比较基本类型字段，使用Objects，equals比较对象字段。如果所有的字段都匹配，就返回true；否则返回false\nreturn field1 == ohter.field1    &amp;&amp; Objects.equals(field2,other.field2)    &amp;&amp; ...;\n\n如果在子类中重新定义equals，就要在其中包含一个super.equals(other)调用。\n\n\n\n对于数组类型的字段，可以使用静态Arrays.equals方法检测相应的数组元素是否相等\n\nhashCode方法散列码（hash code）是由对象导出的一个整型值。散列码是没有规律的。\n如果x和y是两个不同的对象，x.hashCode() 与y.hashCode() 基本上不会相同。\nString类使用以下算法计算散列码：\nint hash = 0;for (int i = 0;i &lt; length();i++)    hash = 31 * hash + charAt(i);\n\n由于hashCode方法定义在Object类中，因此每个对象都有默认的散列码，其值由对象的存储地址得出。\nvar s = &quot;Ok&quot;;var sb = new StringBuilder(s);System.out.println(s.hashCode() + &quot; &quot; + sb.hashCode()); //s 2556  sb 20526976var t = = new String(&quot;Ok&quot;);var tb = new StringBuilder(t);System.out.println(t.hashCode() + &quot; &quot; + tb.hashCode()); //t 2556  tb 20527144\n\n其中字符串s与t的散列码是由内容导出的。在StringBuilder类中没有定义hashCode方法，而Object类的默认hashCode方法会从对象的地址得出散列码。\n如果重新定义了equal方法，就必须为用户可能插入散列表的对象重新定义hashCode方法。\nhashCode方法应该返回一个整数（也可以是负数）。要合理地组合实例字段的散列码，以便能够让不同对象产生的散列码分布更加均匀。\n例如，下面是Employee类的hashCode方法：\npublic class Employee&#123;    public int hashCode()    &#123;        return Objects.hash(name,salary,hireDay);    &#125;&#125;\n\nequals与hashCode的定义必须相容：如果x.equals(y)返回true，那么x.hashCode()就必须与y.hashCode()返回相同的值。例如，如果定义Employee.equals比较员工的ID，那么hashCode方法就需要散列ID，而不是员工的姓名或存储地址。\n\n返回一个散列码，由提供的所有对象的散列码组合而得到\nstatic int hash(Object...objects)\n\n如果a为null返回0，否则返回a.hashCode()\nstatic int hashCode(Object a)\n\n返回给定值的散列码。这里xxx是对应给定包装器类型的基本类型。\nstatic int hasCode(xxx value)\n\n计算数组a的散列码。组成这个数组的元素类型xxx可以是object、int、long、short、char、byte、boolean、float或double。\n\n\ntoString方法在Object中还有一个重要的方法，就是toString方法，它会返回表示对象值的一个字符串。\n下面是一个典型的例子。Point类的toString方法将返回下面这样的字符串：\njava.awt.Point[x=10,y=20]\n\n绝大多数（但不是全部）的toString方法都遵循这样的格式：类的名字，随后是一对方括号括起来的字段值。下面是Employee类中的toString方法的实现：\npublic String toString()&#123;    return &quot;Employee[name=&quot; + name        + &quot;,salart=&quot; + salary        + &quot;,hireDay=&quot; + hireDay        + &quot;]&quot;;&#125;\n\n还可以设计得更好一些。最好通过**getClass().getName()**获得类名的字符串，但是不要将类名硬编码写道toString方法中。\npublic String toString()&#123;    return getClass().getName()        + &quot;[name=&quot; + name        + &quot;,salary=&quot; + salary        + &quot;,hireDay=&quot; + hireDay        + &quot;]&quot;;&#125;\n\n这样toString方法也可以由子类调用。\n当然，设计子类的程序员应该定义自己的toString方法，并加入子类的字段。如果超类使用了getClass().getName(),那么子类只需要调用super.toString()就可以了。例如：\npublic class Manager extends Employee&#123;    ...    public String toString()    &#123;        return super.toString()            + &quot;[bonus=&quot; + bonus            + &quot;]&quot;;    &#125;&#125;\n\n\n可以不写x.toString(),而写作”“ + x。这条语句将一个空串与x的字符串表示(也就是x.toString())相连接。与toString不用的是，即使x是基本类型，这条语句照样能够执行。\n\n如果x是一个任意对象，并调用\nSystem.out.println(x);\n\nprintln方法就会简单地调用x.toString()，并打印输出得到的字符串。\nObject类定义了toString方法，可以打印对象的类名和散列码。例如：\nSystem.out.println(System.our)\n\n输出：java.io.PrintStream@626b2d4a\n之所以得到这样的结果，是因为PrintStream类的实现者没有覆盖toString方法。\n\n警告：令人烦恼的是，数组继承了object类的toString方法，更有甚者，数组类型将采用一种古老的格式打印。例如：\nint[] luckyNumbers = &#123;2,3,5,7,11,13&#125;;String s = &quot;&quot; + luckyNumber;\n\n会生成字符串[I@626b2d4a(前缀[I表明是一个整型数组])。补救的方法是调用静态方法Arrays.toString。代码：\nString s = Arrays.toString(luckyNumber);\n\n将生成字符串[2, 3, 5, 7, 11, 13].\n想要打印多维数组(即，数组的数组)，则需要调用Arrays.deepToString方法。\n\n\ntoString方法是一种非常有用的调试工具。在标准类库中，许多类都定义了toString方法，以便用户能够获得一些有关对象状态的有用信息：\nSystem.out.println(&quot;Current position = &quot; + position);\n\n更好的解决方法是使用Logger类的一个对象并调用：\nLogger.global.info(&quot;Current position = &quot; + position);\n\n\n最好为自定义的每一个类都添加toString方法\n\n如下的程序测试了Employee类和Manager类的equals、hashCode和toString方法\n/* File name: EqualsTest.java */public class EqualsTest &#123;        public static void main(String[] args) &#123;        var alice1 = new Employee(&quot;Alice Adams&quot;, 75000, 1987, 12, 15);        var alice2 = alice1;        var alice3 = new Employee(&quot;Bob Brandson&quot;, 75000, 1987, 12, 15);        var bob = new Employee(&quot;Bob Brandson&quot;, 50000, 1989, 10, 1);                System.out.println(&quot;alice1 == alice2: &quot; + (alice1 == alice2));        System.out.println(&quot;alice1 == alice3: &quot; + (alice1 == alice3));        System.out.println(&quot;alice1.equals(alice3): &quot; + alice1.equals(alice3));        System.out.println(&quot;alice1.equals(bob): &quot; + alice1.equals(bob));        System.out.println(&quot;bob.toString(): &quot; + bob);                var carl = new Manager(&quot;Carl Cracker&quot;, 80000, 1987, 12, 15);        var boss = new Manager(&quot;Carl Cracker&quot;, 80000, 1987, 12, 15);        boss.setBonus(5000);        System.out.println(&quot;boss.toString(): &quot; + boss);        System.out.println(&quot;carl.equals(boss): &quot; + carl.equals(boss));        System.out.println(&quot;alice1.hashCode(): &quot; + alice1.hashCode());        System.out.println(&quot;alice3.hashCode(): &quot; + alice3.hashCode());        System.out.println(&quot;bob.hashCode(): &quot; + bob.hashCode());        System.out.println(&quot;carl.hashCode(): &quot; + carl.hashCode());    &#125;&#125;\n\n/* File name: Employee.java */import java.time.LocalDate;import java.util.Objects;public class Employee &#123;    private String name;    private double salary;    private LocalDate hireDay;        public Employee(String name,double salary,int year,int month,int day)    &#123;        this.name = name;        this.salary = salary;        hireDay = LocalDate.of(year, month, day);    &#125;        public String getName()    &#123;        return name;    &#125;        public double getSalary()    &#123;        return salary;    &#125;        public LocalDate getHireDay()    &#123;        return hireDay;    &#125;        public void raiseSalary(double byPercent)    &#123;        double raise = salary * byPercent / 100;        salary += raise;    &#125;        public boolean equals(Object otherObject) &#123;        // a quick test to see if the objects are identical        if(this == otherObject) return true;                // must return false if the explicit parameter is null        if(otherObject == null) return false;                // if the classes don&#x27;t match,they can&#x27;t be equal        if(getClass() != otherObject.getClass()) return false;                // now we know otherObject is a non-null Employee        var other = (Employee) otherObject;                // text whether the fields have identical values        return Objects.equals(name, other.name)                &amp;&amp; salary == other.salary &amp;&amp; Objects.equals(hireDay, other.hireDay);    &#125;        public int hashCode() &#123;        return Objects.hash(name,salary,hireDay);    &#125;        public String toString() &#123;        return getClass().getName() + &quot;[name=&quot; + name + &quot;,salary=&quot; + salary + &quot;,hireDay=&quot;                + hireDay + &quot;]&quot;;    &#125;&#125;\n\n/* File name: Manager.java */public class Manager extends Employee &#123;    private double bonus;    public Manager(String name,double salary,int year,int month,int day) &#123;        super(name,salary,year,month,day);        bonus = 0;    &#125;        public double getSalary() &#123;        double baseSalary = super.getSalary();        return baseSalary + bonus;    &#125;        public void setBonus(double b) &#123;        bonus = b;    &#125;        public boolean equals(Object otheObject) &#123;        if (!super.equals(otheObject)) return false;        var other = (Manager) otheObject;        // super.equals checked that this and other belong to the same class        return bonus == other.bonus;    &#125;        public int hashCode()    &#123;        return java.util.Objects.hash(super.hashCode(),bonus);    &#125;        public String toString() &#123;        return super.toString() + &quot;[bonus=&quot; + bonus + &quot;]&quot;;    &#125;&#125;\n\n\nClass getClass()\n返回包含对象信息的类对象。\n\nboolean equals(Object otherObject)\n比较两个对象是否相等，如果两个对象指向同一块存储地区，方法返回true：否则方法返回false。要在自定义的类中覆盖这个方法。\n\nString toString()\n返回表示该对象的字符串。要在自定义的类中覆盖这个方法。\n\nString getName()\n返回这个类的名字。\n\nClass getSuperclass()\n以Class对象的形式返回这个类的超类。\n\n\n泛型数组列表在许多程序设计语言，特别是在C&#x2F;C++语言中，必须在编译时就确定整个数组的大小。\n在Java中，情况就好多了。它允许在运行时确定数组的大小。\nint actualSize = ...;var staff = new Employee[actualSize];\n\n当然，这段代码并没有完全解决运行时动态更改数组的问题。一旦确定了数组的大小，就不能很容易地改变它了。在Java中，解决这个问题最简单的方法就是使用Java中的另外一个类，名为ArrayList。ArrayList类类似于数组，但在添加或删除元素时，它能够自动地调整数组容量，而不需要为此编写任何代码。\nArrayList是一个有**类型参数(type parameter)的泛型类(generic class)**。为了指定数组列表保存的元素对象的类型，需要用一对尖括号将类名括起来追加刀ArrayList后面，例如：\nArrayList&lt;Employee&gt;\n\n声明数组列表声明和构造一个保存Employee对象的数组列表：\nArrayList&lt;Employee&gt; staff = new ArrayList&lt;Employee&gt;();\n\n在Java10中，最好使用var关键字以避免重复写类名：\nvar staff = new ArrayList&lt;Employee&gt;();\n\n如果没有使用var关键字，可以省去右边的类型参数：\nArrayList&lt;Employee&gt; staff = new ArrayList&lt;&gt;();\n\n这称为”菱形”语法，因为空尖括号&lt;&gt; 就像是一个菱形。可以结合new操作符使用菱形语法。检查器会检查新值要做什么。如果赋值给一个变量，或传递给某个方法，或者从某个方法返回，检查器会检查这个变量、参数或方法的泛型类型，然后将这个类型放在&lt;&gt;中。在这个例子中，new ArrayList&lt;&gt;将赋值给一个类型为ArrayList&lt;Employee&gt;的变量，所以泛型类型为Employee。\n\n如果使用var声明ArrayList，就不要使用菱形语法：\nvar elements = new ArrayList&lt;&gt;();\n\n会生成一个ArrayList&lt;Object&gt;\n\n使用add方法可以将元素添加到数组列表中：\nstaff.add(new Employee(&quot;Harry Hacker&quot;,...));staff.add(new Employee(&quot;Tony Tester&quot;,...));\n\n如果调用add而内部数组已经满了，数组列表会自动地创建一个更大的数组，并将所有的对象从较小的数组中拷贝到较大的数组中。\n如果已经知道或能够估计出数组可能存值的元素数量，就可以在填充数组之前调用ensureCapacity方法：\nstaff.ensureCapacity(100);\n\n这个方法调用将分配一个包含100个对象的内部数组。这样一来，前100次add调用不会带来开销很大的重新分配空间。\n另外，还可以把初始容量传递给ArrayList构造器：\nArrayList&lt;Employee&gt; staff = new ArrayList&lt;&gt;(100);\n\nsize方法将返回数组列表中包含的实际元素个数，等价于数组a的a.length。例如：\nstaff.size()\n\n\nArrayList&lt;E&gt;()\n构造一个空数组列表。\n\nArrayList&lt;E&gt;(int initialCapacity)\n用指定容量构造一个空数组列表。\n\nboolean add(E obj)\n在数组列表的末尾追加一个元素。永远返回true。\n\nint size()\n返回当前存储在数组列表中的元素个数。(当然，这个值永远不会大于数组列表的容量。)\n\nvoid ensureCapacity(int capacity)\n确保数组列表在不重新分类内部存储数组的情况下有足够的内容存储给定数量的元素。\n\nvoid trimToSize()\n将数组列表的存储容量削减到当前大小。\n\n\n访问数组列表元素数组列表自动扩展容量的便利增加了访问元素语法的复杂程度。其原因是ArrayList类并不是Java程序设计语言的一部分；它只是由某个人编写并在标准库中提供的一个实用工具类。\n不能使用[]语法格式访问或改变数组的元素，而要使用get和set方法。\n\nE set(int index,E obj)\n将值obj放置在数组列表的指定索引位置，返回之前的内容。\n\nE get(int index)\n得到指定索引位置存储的值。\n\nvoid add(int index,E obj)\n后移元素从而将obj插入到指定索引位置。\n\nE remove(int index)\n删除指定索引位置的元素，并将后面的所有元素前移。返回所删除的元素。\n\n\n对象包装器与自动装箱有时，需要将int这样的基本类型转换为对象。所有的基本类型都有一个与之对应的类。例如，Integer类对应基本类型int。通常，这些类称为包装器(wrapper)。这些包装器类有显而易见的名字：Integer、Long、Float、Double、Short、Byte、Character、Boolean(前6个类派生于公共的超类Number)。\n声明Integer对象的数组列表：\nvar list = new ArrayList&lt;Integer&gt;();\n\n\nint intValue()\n将这个Integer对象的值作为int返回（覆盖Number类中intValue方法）\n\nstatic String toString(int i)\n返回一个新的String对象，表示指定数值i的十进制表示\n\nstatic String toString(int i,int radix)\n返回数值i基于radix参数指定进制的表示\n\nstatic int parseInt(String s)\n\nstatic int parseInt(String s,int radix)\n返回字符串s表示的整数，指定字符串必须表示一个十进制整数（第一种方法），或者采用radix参数指定的进制（第二种方法）\n\nstatic Integer valueOf(String s)\n\nstatic Integer valueOf(String s,int radix)\n返回一个新的Integer对象，用字符串s表示的整数初始化。指定字符串必须表示一个十进制整数（第一种方法），或者采用radix参数指定的进制（第二种方法）\n\nNumber parse(String s)\n返回数字值，假设给定的String表示一个值\n\n\n学习效率太差，该笔记停止更新！！！","categories":["WEBbackend"],"tags":["Java"]},{"title":"Java集合","url":"/2022/11/03/WebBackend/Java/Java%E9%9B%86%E5%90%88/","content":"数组声明数组变量dataType[] arrayRefVar;   // Java风格，首选方法dataType arrayRefVar[];   // C、C++风格，可以用但不是首选\n\n创建数组arrayRefVar = new dataType[arraySize];//1、使用 dataType[arraySize] 创建了一个数组。//2、把新创建的数组的引用赋值给变量 arrayRefVar\n\n数组变量声明和创建数组一条语句实现\ndataType[] arrayRefVar = new dataType[arraySize];dataType[] arrayRefVar = &#123;value0, value1, ..., valuek&#125;;\n\nFor-Each循环for(type element: array)&#123;    System.out.println(element);&#125;\n\n等价于：\nfor(type element = 0; element &lt; array.size(); i++)&#123;    type element2 = array.get(element);&#125;\n\n\n\n多维数组初始化type[][] typeName = new type[typeLength1][typeLength2];\n\ntype 可以为基本数据类型和复合数据类型，typeLength1 和 typeLength2 必须为正整数，typeLength1 为行数，typeLength2 为列数\nList\nList表示一种有序列表，会根据放入元素先后顺序存放，可以包含重复的元素。\nList 实现了 Collection 接口，它主要有两个常用的实现类：ArrayList 类和 LinkedList 类\n\n\n\n\nArrayList\nLinkedList\n\n\n\n获取指定元素\n速度很快\n需要从头开始查找元素\n\n\n添加元素到末尾\n速度很快\n速度很快\n\n\n在指定位置添加&#x2F;删除\n需要移动元素\n不需要移动元素\n\n\n内存占用\n少\n较大\n\n\n实现方式\n动态数组数据结构\n链表数据结构\n\n\n高运行速度往往是以牺牲空间为代价的，而节省占用空间往往是以牺牲运行速度为代价的，所谓“鱼与熊掌不可得兼”\nArrayList类import java.util.List;import java.util.ArrayList;class Main &#123;    public static void main(String[] args) &#123;        //使用ArrayList类创建列表        List&lt;Integer&gt; numbers = new ArrayList&lt;&gt;();        //将元素添加到列表        numbers.add(1);        numbers.add(2);        numbers.add(3);        System.out.println(&quot;List: &quot; + numbers);        //从列表中访问元素        int number = numbers.get(2);        System.out.println(&quot;访问元素: &quot; + number);        //从列表中删除元素        int removedNumber = numbers.remove(1);        System.out.println(&quot;删除元素: &quot; + removedNumber);    &#125;&#125;\n\n输出结果：\nList: [1, 2, 3]访问元素: 3删除元素: 2\n\nLinkedList类LinkedList底层的数据结构是基于双向循环链表，且头结点中不存放数据\n\n既然是双向链表，那么必定存在一种数据结构——我们可以称之为节点，节点实例保存业务数据，前一个节点的位置信息和后一个节点位置信息，如：\n\nList&lt;Integer&gt; numbers = new LinkedList&lt;&gt;();\n\nMap\nHashMap&lt;Integer, String&gt; Sites = new HashMap&lt;Integer, String&gt;();\n\nProperties(属性)Properties 继承于 Hashtable，其作用用来读写以.properties为扩展名的配置文件。每行以key=value表示，以之前的连接池笔记为例：\n\n\nProperties读取配置文件，一共有三步：\n\n创建Properties实例；\n调用load()读取文件；\n调用getProperty()获取配置。\n\nSetList接口和Set接口都继承了Collection接口。 但是，它们之间存在一些差异。\n\nList可以包含重复的元素。但是，Set不能有重复的元素。\nList中的元素以某种顺序存储。但是，Set中的元素以组的形式存储，就像数学中的集合一样。\n\nQueue表示先进先出（FIFO：First In First Out）的有序表\n\n通过add()&#x2F;offer()方法将元素添加到队尾；\n通过remove()&#x2F;poll()从队首获取元素并删除；\n通过element()&#x2F;peek()从队首获取元素但不删除。\n\nPriorityQueuePriorityQueue实现了一个优先队列：从队首获取元素时，总是获取优先级最高的元素。\nPriorityQueue默认按元素比较的顺序排序（必须实现Comparable接口），也可以通过Comparator自定义排序算法（元素就不必实现Comparable接口）\nDequeDeque实现了一个双端队列（Double Ended Queue），它可以：\n\n将元素添加到队尾或队首：addLast()&#x2F;offerLast()&#x2F;addFirst()&#x2F;offerFirst()；\n从队首／队尾获取元素并删除：removeFirst()&#x2F;pollFirst()&#x2F;removeLast()&#x2F;pollLast()；\n从队首／队尾获取元素但不删除：getFirst()&#x2F;peekFirst()&#x2F;getLast()&#x2F;peekLast()；\n总是调用xxxFirst()&#x2F;xxxLast()以便与Queue的方法区分开；\n避免把null添加到队列\n\nStack(栈)栈（Stack）是一种后进先出（LIFO）的数据结构，操作栈的元素的方法有：\n\n把元素压栈：push(E)；\n把栈顶的元素“弹出”：pop(E)；\n取栈顶元素但不弹出：peek(E)。\n\n在Java中，我们用Deque可以实现Stack的功能，注意只调用push()&#x2F;pop()&#x2F;peek()方法，避免调用Deque的其他方法。\n最后，不要使用遗留类Stack\nIteratorIterator（迭代器）不是一个集合，它是一种用于访问集合的方法，可用于迭代   ArrayList和 HashSet等集合，比如我们之前的增强for就是迭代器简化的书写格式（增强for循环的底层使用了迭代器遍历）\nCollectionsCollections类提供了一组工具方法来方便使用集合类：\n\n创建空集合；\n创建单元素集合；\n创建不可变集合；\n排序／洗牌等操作。\n\n","categories":["WEBbackend"],"tags":["Java"]},{"title":"Java面向对象","url":"/2022/11/03/WebBackend/Java/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","content":"简介\n面向对象程序设计(object-oriented programming,OPP)\n\n一个程序就是一个世界，有很多事物(对象[属性,行为])\n\n\n类(class)与对象(object)类：是对象一个模板（抽象的概念集合），定义属性和行为(方法)\n\nclass 类名称 &#123;    属性（变量）;    行为（方法）;&#125;\n\n\n\n\n注：\n\n属性是类的组成部分，一般是基本数据类型，也可以是引用类型(对象，数组)\n\n属性的定义：set&#x2F;get方法名，去掉set&#x2F;get后，把剩余的部分首字母改为小写后，即为这个类的属性\n例如：\npublic class student&#123;　　public String getName()&#123;　　　　return &quot;Hello World&quot;;　　&#125;&#125;//成员变量：无//属性：name\n\n所以,成员变量!&#x3D;属性，还有个叫法实例字段(instance field)\n\n\n\n对象：是类的一个实例，每个对象拥有自己独立的属性(数据)，依靠属性来区分不用的对象。\n实例：由类构造(construct)对象的过程称为创建类的实例(instance)\n\n面向对象基本特性封装：(encapsulation,有时被称为数据隐藏)封装就是将属性(数据)和行为组合在一个包中，并对对象的使用者隐藏具体的实现方式。\n继承：在原本的基础之上继续进行扩充\n多态：在一个指定的范围之内进行概念的转换\n\n方法(method)：操作数据的过程\n状态(state)：实例字段值的集合就是这个对象的当前状态。\n\n类的成员成员变量：在类中声明的变量\n局部变量：在方法中声明的变量\n\n成员方法访问修饰符 返回值类型 方法名(形参列表) &#123;\t//方法体    语句;    return;&#125;\n\n\n访问修饰符：public，protected，默认，private\n返回值类型：基本类型和引用类型（数组，对象）,void表示无返回值\n方法名：遵循驼峰命名法\n形参列表：表示成员方法的输入\n一个方法可以有零个参数，也可以有多个参数\n参数类型可以为任意类型，包括基本类型和引用类型（数组，对象）\n调用带参数的方法时，一定要对应着参数列表传入相同类型或兼容类型的参数\n方法定义时的参数叫形式参数，简称形参；方法调用时的参数叫实际参数，简称实参；实参和形参的类时要一致或兼容，个数、顺序必须一致\n\n\n方法主体：表示为了实现某一功能代码块\nreturn：如果有返回值类型，必须用return\n\nthis.对象成员方法(参数值,参数值);\n对象名.对象成员方法(参数值,参数值);\n重载(overload)\n方法名和作用域必须相同\n参数必须不同：数量、类型、顺序不用（只要有一个不用，就是重载方法）\n\n可变参数作用域构造器this","categories":["WEBbackend"],"tags":["Java"]},{"title":"Java面试八股文（Company）","url":"/2022/11/25/WebBackend/Java/Java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87%EF%BC%88Company%EF%BC%89/","content":"1. jdk和jre的区别\njdk是开发工具\njre是运行环境\n\n2. jdk目录？\nbin-&gt;可执行文件 javac.exe编译   java.exe执行\nlib-&gt;类库包   tools.jar公共类库\ndb-&gt;数据库\ninclude-&gt;包含函数库\nsrc.zip-&gt;源代码\n\n3. java为什么能跨平台？JVM（java虚拟机）\n4. JVM的工作机制？*.java源文件通过javac.exe编译生成.class的字节码文件。再由java.exe解释执行字节码文件，生成中间代码，显示结果\n5. java是哪种语言派生？又是哪种语言衍生？oak派生，c语言衍生\n6. java有几种基本数据类型各占多少字节？\n\n\n数据类型1\n数据类型2\n占用字节\n\n\n\nbyte\nboolean\n1字节\n\n\nchar\nshort\n2字节\n\n\nint\nfloat\n4字节\n\n\nlong\ndouble\n8字节\n\n\n7. byte bvar &#x3D; 129;能编译通过吗？如果不能请说明？不能通过编译，因为byte类型的数据取值范围为-128-127，超范围了\n8. short s &#x3D; 1; s &#x3D; s + 1;能编译通过吗？如果不能请说明，并改正？不能通过编译，因为s = s + 1;中的1为int型，而s为short类型。一个int和short类型运算时，自动转换为int类型所以超出short范围。改正：s += 1;\n9. int a; a &#x3D; a + 2;能编译通过吗？如果不能请说明？不能通过编译，因为a为局部变量没有进行初始化赋值，就在 a = a+2;获取a的值，所以编译产生错误\n10. char c &#x3D; ‘ab’;能编译通过吗？如果不能请说明？不能通过编译，因为char类型只能赋值一个字符，两个字符称为字符串\n11. char c&#x3D; ‘\\n’;能编译通过吗？如果不能请说明？能通过编译，因为\\n为转义字符，视为一个字符所以可以通过\n12. float&#x3D;3.4; 编译能通过吗？不能，默认的小数类型为double，改正：float=3.4f;\n13. double $a &#x3D; 3; 编译能通过吗？能，变量名可以由$_字母开头，可以包含数字，不能包含特殊字符，不能以关键字和保留字命名\n14. int num &#x3D; (int)1.3 + (int)2.9;和int num2 &#x3D; (int)(1.3 + 2.9);结果相同吗？不能 num值为3，num2值为4\n15. ‘a’ + 1结果为多少？98，因为a为char类型，以unicode编码。a的ASCII码为97.当char和数值运算时，自动转换为对应的ASCII码值进行运算\n16. System.out.println(1&lt;3?8:88.2);输出结果输出8.0。因为隐式转换，前后的类型相同。\n17. int a &#x3D; 0,b &#x3D;0; b &#x3D; a++;a和b的值是多少a为1,b为0.变量++,先赋值后自加1\n18. int a &#x3D; 0,b &#x3D;0; b &#x3D; ++a;a和b的值是多少a为1,b为1.++变量,先自加1后赋值\n19. &amp;和&amp;&amp;的区别\n&amp;与位运算符，第一个条件不满足时第二个条件继续执行\n&amp;&amp;逻辑与运算符，第一个条件不满足时第二个条件不继续执行，所以称之为短路与\n\n20. int a &#x3D;1,b &#x3D; 2; System.out.println(a++ &gt; 1 &amp;&amp; –b &gt;0 ?true:false);输出值是多少？a和b的值是多少？false a为2 b为2 &amp;&amp;为逻辑与，如果第一个表达式为假，第二个表达式不会被执行\n21. int a &#x3D;1,b &#x3D; 2; System.out.println(++a &gt; 1 || –b &lt;0 ?true:false);输出值是多少？a和b的值是多少？true a为2 b为2 &amp;&amp;为逻辑与，如果第一个表达式为真，第二个表达式不会被执行\n22. int a&#x3D;1;int b&#x3D;1;if(++a&lt;0&amp;b–&lt;&#x3D;1){System.out.print(“OK”)};输出结果a=2,b=0; OK不打印\n23. int a&#x3D;1;int b&#x3D;1;if(++a&lt;0&amp;&amp;b–&lt;&#x3D;1){System.out.print(“OK”)};输出结果a=2,b=1; OK不打印\n24. int a&#x3D;1;int b&#x3D;1;if(++a&lt;0||b–&lt;&#x3D;1){System.out.print(“OK”)};输出结果&#96;a=2,b=0; 打印OK\n25. for(int i&#x3D;0; i &lt; 3;i++){},其中i &lt; 3这个执行多少次？int i &#x3D; 0 执行几次？i++执行几次？i &lt; 3执行4次  int i = 0 执行1次  i++ 执行3次\n26. int i &#x3D; 2; while(i&lt;3) {System.out.println(i);i++;}；输出结果输出2\n27. int i &#x3D; 2; do{System.out.println(i);i++;}while(i&lt;2)；System.out.println(i);输出结果输出2,3\n28. int a&#x3D;1; switch(a){case 1:System.out.println(1);case 2:System.out.println(2);break;default:System.out.println(3);}输出结果输出1,2\n29.  数组是对象吗？是\n30. length是String的方法，数组的属性吗是\n31. 数值类型的数组，每个元素的默认值是什么，boolean的默认元素是什么，引用型的默认值是什么，Integer的默认元素是什么\n数值:0;\nboolean : false;\n引用型 : null;\nInteger : null;\n\n32. 实例化数组的几种方式int [] num &#x3D;{1,2,3};int [] num &#x3D;new int [3];int num [] &#x3D; new int[3];int num [] &#x3D; new int []{1,2,3}.\n33. int [] num &#x3D;new int [3];打印输出num[3]，编译能不能通过，如果能通过，运行能不能发生异常能通过，但是运行时会发生数组下标越界异常，因为该数组的下标最大到2\n33.1 如果声明一个数组 int[]num&#x3D;null;num[0]&#x3D;1;编译能通过，运行出现空指针异常。\n34. String [] str&#x3D;new String[3];System.out.println(str[0].length());编译能通过，运行出现空指针异常\n35. java和c哪个是面向对象的语言，哪个是面向过程的语言？java面向对象  c面向过程\n36. OOP\\OOD\\OOA代表的含义OOP面向对象编程  OOD面向对象设计  OOA面向对象分析\n37. 面向对象和面向过程的区别？面向过程，重点在执行的流程，函数调用函数，如果流程发生变化，将重新编写。程序紧耦合，代码不能复用面向对象，把事物看成对象，是对象与对象的联系。如果需求发生变化，更改联系即可。使程序更加松耦合，代码的复用性更高\n38. 面向对象的基本特征?封装、继承、多态\n39. 什么是封装？封装有什么好处？隐藏属性、方法或实现细节的过程称为封装。好处在于让使用者只能通过事先定制好的方法来访问数据，可以方便地加入控制逻辑，限制对属性的不合理操作便于修改，增强代码的可维护性\n40. 什么是继承，继承有什么好处？在Java中定义一个类时，让该类通过关键字extends继承一个已有的类，这就是类的继承(泛化)。被继承的类称为父类（超类，基类），新的类称为子类（派生类）。子类继承父类的所有属性和方法，同时也可以增加自己的属性和方法，实现代码的复用和扩展。\n41. 什么是多态，多态的优点？多态的表现方式有哪些？一种事务的多种表现形态称之为多态。多态的优点简化代码，改善代码的组织性和可读性，易于扩展。多态表现方式：重写、重载、父类 对象 &#x3D; new 子类(); 接口 对象 &#x3D; new 实现类();\n42. 在一个java文件中只能声明一个类吗？不是，可以声明多个类，但是只能有一个public类，必须与文件名相同\n43. 对象分为哪两种？引用对象，存在于栈中，指向堆中的地址实例化对象，用new实例化，存在于堆中，在内存中开辟存储空间\n44. String str &#x3D; new String(“123”);产生几个对象？产生两个对象，一个是引用对象String str存在于栈中另一个实例化对象str = new String(&quot;123&quot;);存在于堆中，开辟存储空间\n45. &#x3D;&#x3D;和equals的区别&#x3D;&#x3D;用于比对基本数据类型是否相等。对于引用对象来说，先比对地址后比较值equals,用于比对引用类型，比对String类型时只比对值，因为它重写了equlas方法。如果比对指定的引用类型，可以重写equals方法，获取属性的hashCode进行比对。\n46. String str1 &#x3D; new String(“123”);String str2 &#x3D; new String(“123”); &#x3D;&#x3D;和equals的值？&#x3D;&#x3D;：返回值为false，因为str1和str2都是实例化对象，在堆中存在不同的地址。先比对地址后比较值。因为地址不同，所以返回falseequals：返回值为true,只是比较值，应为值相等，所以返回为true\n47. String str1 &#x3D; “123”;String str2 &#x3D; “123”;&#x3D;&#x3D;和equals的值？&#x3D;&#x3D;：返回值为true，因为str1和str2两个引用对象都指向于堆中的常量池中的123，地址相同。先比对地址后比较值。因为地址相同，并且值相同，所以返回trueequals：返回值为true,只是比较值，应为值相等，所以返回为true\n48. 构造方法当什么时候被调用？有什么作用？当对象实例化的时候被调用。给对象属性初始化赋值\n49. 如果一个类中只有有参的构造，能实例化一个无参的对象吗？不能，在这种情况下想实例化无参的对象，必须重载一个无参的构造\n50. 什么是对象方法和对象属性，如何在静态方法中调用？不用static修饰的方法和属性称为对象方法和对象属性用对象进行调用对象方法和对象属性，不能使用this\n51. 静态块什么时候执行？有什么作用？静态块在类加载的时候执行，在构造方法前执行，并且只执行一次。给静态成员变量初始化。\n52. 输出一点数据”13,25,36,18,99”，中间以逗号分隔 请进行解析，分割成数组。String[] str= &quot;13,25,36,18,99&quot;.split(&quot;,&quot;);\t\t//以，解析字符串\n\n53. 截取字符串用什么方法？“字符串”.subString(起始索引，结束索引);截取位置 &gt;&#x3D;起始索引 &amp;&amp; 截取位置 &lt; 结束索引\n54. 子字串在父字串包含的位置，用什么方法？&quot;字符串&quot;.indexOf(&quot;子字串&quot;);如果大于-1，代表包含，否则代表不存在\n55. “123”.subString(0,4);,编译能通过吗？能通过编译，但运行时，会抛出字符串下标越界异常\n56. String类能被继承吗？不能，因为被final所修饰\n57. 子类覆盖了父类的方法，实例化父类对象，调用该同名方法，调用的是父类还是子类的方法？父类的方法，父类只能调用父类的方法\n58. 如果父类只有有参构造，在子类如何编写，才能编译通过？在子类编写子类的构造方法，在子类的构造方法的第一行调用父类的有参构造用super(参数值,参数值)\n59. 重写和重载的区别？重写(override覆写)：在继承关系下，子类覆盖父类的方法，要求方法名，参数列表，返回值必须相同访问修饰符必须大于等于父类访问修饰符。由private修饰的方法不能被重写，也不能被继承。由static修饰的方法不能被重写，但是能被继承。由final所修饰的方法不能被重写，但是能被继承重载（overload）:在同一类中，方法名相同，参数列表必须不同，跟返回值无关\n60. 访问修饰符有哪些？作用域是什么？\n\n\n访问修饰符\n同一类\n同一类不同包\n不同包子孙类\n不同包\n\n\n\npublic\n√\n√\n√\n公共的\n\n\nprotected\n√\n√\n√\n受保护的\n\n\n缺省的\n√\n√\n\n\n\n\nprivate\n√\n\n\n私有的\n\n\n61. 抽象类和接口能被实例化吗都不能被实例化\n62. 抽象类的构造方法什么时候被调用实例化实现子类的实例化对象的时候被调用\n63. 没有抽象方法的类一定不为抽象类不对\n64. 有抽象方法的类一定为抽象类对\n65. 一个类可以继承多个接口吗不能，一个类只能实现多个接口。\n66. 一个类能继承一个类的同时实现多个接口吗能 ，类 extends 父类  implements 接口,接口\n67. 一个接口可以继承多个接口，java是多继承吗不对，因为Java的单继承是针对于类而言，而不是接口\n68. 一个类实现了一个接口，部分实现了该接口的部分抽象方法，该类一定为抽象类吗一定\n69. 如果一个类继承了一个抽象类，部分实现了该类的部分抽象方法，该类一定为抽象类吗一定\n70. 抽象类必须得有抽象方法存在错\n71. 多态的表现方式？多态在继承关系下，重写，重载，父类 引用对象 &#x3D; new 子类();接口  引用对象 &#x3D;new 实现类();\n72. 接口和抽象类的区别抽象类:\n\n可以有变量也可以有常量 可以有抽象方法也可以有实现方法 \n一个抽象类只能继承一个类，可以被多个类所继承 \n抽象类有构造方法\n\n接口：\n\n只能有public static final修饰的常量，必须初始化赋值\n只能有public abstract的抽象方法，没有实体方法存在\n一个接口可以继承多个接口，一个类可以实现多个接口\n接口没有构造方法\n\n","categories":["其他"],"tags":["Java"]},{"title":"Java笔记","url":"/2022/09/16/WebBackend/Java/Java%E7%AC%94%E8%AE%B0/","content":"Java 程序设计概述简单性Java语法是C++语法的一个“纯净”版本。这里没有头文件、指针运算（甚至指针语法）、结构、联合、操作符重载、虚基类等。\n“简单”的另一个方面是小。Java的目标之一是支持开发能够在小型机器上独立运行的软件。\n面向对象简单来讲，面向对象设计是一种程序设计技术。它将重点放在数据（即对象）和对象的接口上。在本质上，Java的面向对象能力与C++是一样的。\n分布式Java有一个丰富的例程库，用于处理像HTTP和FTP之类的TCP&#x2F;IP 协议。\nJava应用程序能够通过URL打开和访问网络上的对象，其便捷程度就好像访问本地文件一样。\n健壮性Java的设计目标之一在于使得Java编写的程序具有多方面的可靠性。Java非常强调进行早期的问题检测、后期动态的（运行时）检测，以及消除容易出错的情况……Java与C&#x2F;C++最大的不同在于Java采用的指针模型可以消除重写内存和损坏数据的可能性。\n安全性Java要适用于网络&#x2F;分布式环境。为了实现这个目标，安全性颇受重视。使用Java可以构建防病毒、防篡改的系统。\n体系结构中立编译器生成一个体系结构中立的目标文件格式，这是一种编译过的代码，只要有Java运行时系统，这些编译后的代码可以在许多处理器上运行。Java编译器通过生成与特定的计算机体系结构无关的字节码指令来实现这一特性。精心设计的字节码不仅可以很容易地在任何机器上解释执行，而且还可以动态的转换成本地机器代码。\n解释性虚拟机指令肯定会比全速运行机器指令慢很多。不过，虚拟机有一个选项，可以将执行最频繁的字节码序列转换成机器码，这一过程为即时编译。\nJava虚拟器还有一些其他优点。它可以检查指令序列的行为，从而增强其安全性。\n可移植性与C和C++不同，Java规范中没有“依赖具体实现”的方法。基本数据类型的大小以及有关运算的行为都有明确的说明。\n例如，Java中的int永远为32位的整数，而在C&#x2F;C++中，int可能是16位整数、32位整数，也可能是编译器开发商指定的任何其他大小。唯一的限制只是int类型的字节数不能低于short int，而且不能高于long int。在Java 中，数值类型有固定的字节数，这消除了代码移植时一个令人头痛的主要问题。二进制数据以固定的格式进行存储和传输，消除了字节顺序的困扰。字符串则采用标准的Unicode格式存储。\nJava库能够很好地支持平台独立性。可以处理文件、正则表达式、XML、日期和时间、数据库、网络连接、线程等，从而不用操心地城操作系统。不仅程序是可以移植的，Java API往往也比原生的API质量更高。\n高性能尽管对解释后的字节码性能已经比较满意，但在有些场合下还需要更高的性能。\n字节码可以（在运行时）动态地转换成对应运行这个程序的特定CPU的机器码。\n多线程多线程可以带来更快的交互响应和实时行为。\n至今我们非常关注并发性。我们不再追求更快的处理器，而是着眼于获得更多的处理器，而且要让它们一直保持工作。不过，可以看到，大多数编程语言对于这个问题并没有显示出足够的重视。\nJava在当时很超前。它是第一个支持并发程序设计的主流语言。当时，多核处理器还很神秘，而Web编程才刚刚起步，处理器要花很长时间等待服务器响应，需要并发程序设计来确保用户界面不会“冻住”。\n动态性从很多方面来看，Java与C或C++相比更加具有动态性。他能够适应不断发展的环境。库中可以自由地添加新方法和实例变量，二对客户端却没有任何影响。下Java中找出运行时类型信息十分简单。\n当需要为正在运行的程序添加代码时，动态性将是一个非常重要的特性。一个很好的例子：从Internet下载代码，然后再浏览器上运行。如果使用C或C++，这确实难度很大，不过Java设计者很清楚动态语言可以很容易地实现运行程序的演进。最终，他们将这一特性引入这个主流程序设计语言中。\n\n小知识：Java成功地推出后不久，微软就发布了一个叫作J++的产品，它与Java有几乎相同的编程语言和虚拟机。现在，微软不再支持J++，取而代之的时另一个名为C#的语言。C#和Java有很多相似之处，不过在一个不同的虚拟机上运行。\n\nJava applet 与 Internet这里的想法很简单：用户从Internet下载Java字节码，并在自己的机器上运行。在网页中运行的Java程序称为applet。而使用applet，只需要一个启用Java的Web浏览器，它会为你执行字节码。不需要安装任何软件。任何时候只要访问包含applet的网页，就会得到程序的最新版本。最重要的是，要感谢虚拟机的安全性，它让我们不必再担心来自而已代码的攻击。\nJava发展简史Java的历史要追溯到1991年，由Patrick Naughton和James Gosling（一个全能的计算机奇才，Sun公司会士）带领的Sun的工程师小组想要设计一种小型的计算机语言，主要用于像有线电视转换盒这类消费设备。由于这些消费设备的处理能力和内存都很有限，所以语言必须非常小而能够生成非常紧凑的代码。另外，由于不同的厂商会选择不同的中央处理器（CPU），因此很重要的一点是这种语言不应与任何特定的体系结构绑定。这个项目被命名为“Green”。\n代码短小，紧凑且与平台无关，这些要求促使开发团队设计出一个可移植的语言，可以为虚拟机生成中间代码。\n不过，Sun公司的人都有UNIX的应用背景。因此，所开发的语言以C++为基础，而不是Lisp、Smalltalk或Pascal。不过，就像Gosling在专访中谈道：“毕竟，语言只是实现目标的工具，而不是目标本身。”Gosling把这种语言称为“Oak”。Sun公司的人后台发现，Oak是一种已有的计算机语言的名字，于是，将其改名为Java。\n1992年，Green项目发布了它的第一个产品，称之为“*7”。这个产品可以提供非常智能的远程控制。遗憾的是，Sun公司对生产这个产品并不感兴趣，Green项目组的人员必须找出其他的方法来将他们的技术推向市场。然而，仍然没有一家标准消费品电子公司对此感兴趣。于是，Green项目组投标了一个设计有线电视盒的项目，它能提供视频点播等新型有线服务，但他们没能拿到这个合同。\nGreen项目（这时换了一个新名字——“First Person公司”）在1993年一整年以及1994年的上半年，一直在苦苦寻求买家购买他们的技术。然而，一个也没有找到。1994年First Person公司解散了。\n当这一切在Sun公司发生的时候，Internet的万维网也在日渐发展壮大。万维网的关键是浏览器把超文本页面转换到屏幕上。1994年大多数人都在使用Mosaic，这是1993年出自伊利诺伊大学超级计算中心的一个非商业化的Web浏览器。\n在接受SunWorld采访的时候，Gosling说，在1994年中期，Java语言的开发者意识到：“我们能够建立一个相当酷的浏览器。在客户&#x2F;服务器主流框架中，浏览器恰好需要我们已经完成的一些工作：体系结构中立、实时、可靠、安全——这些问题在工作站环境并不太重要，所以，我们决定开发浏览器。”\n实际的浏览器是由Patrick Naughton 和Jonathan Payne 开发的，并演变为HotJava浏览器。HotJava浏览器采用Java编写，以炫耀Java语言超强的能力。这个浏览器能够在网页中执行内嵌的Java代码。这一“技术证明”在1995年5月23日的SunWorld‘95大会上展示，同时引发了人们延续至今对Java的狂热追逐。\n1996年年初，Sun发布了Java第一个版本-Java 1.0，但是Java1.0不能用来真正的应用开发。\n1998年发布了Java 1.2版。这个版本早期玩具式的GPU和图形工具包代之以复杂而且可伸缩的工具包。\n标准版的1.3和1.4版本对最初的Java2版本做出了增量式的改进，提供了不断扩展的标准类库，提高了性能，当然，还修正了一些bug。在此期间，原先对Java applet和客户端应用的炒作逐渐消退，但Java成为服务器端应用的首选平台。\n5.0版是自1.1版以来第一个对Java语言做出重大改进的版本（这一版本原来定为1.5版，在2004年的JavaOne会议之后，版本号直接升至5.0）。经过了多年的研究，这个版本添加了泛型类型（generic type0，大致相当于C++的模板），其挑战性在于添加这一特性而不需要对虚拟机做出任何修改。另外，受到C#的启发，还增加了几个很有用的语言特性：“for each”虚幻、自动装箱和注解。\n版本6（没有后缀.0）于2006年年末发布。同样，这个版本没有对语言方面再进行修改，而是做了其他性能改进，并增强了类库。\n随着数据中心越来越依赖于商业硬件而不是专用服务器，Sun公司终于沦陷，于2009年被Oracle收购。Java的开发停止了很长一段时间。直到2011年Oracle发布了Java的一个新版本——Java 7，其中只做了一些简单的改进。\n2014年，Java8终于发布，再近20年中这个版本发生的改变最大。Java 8 包含了一种“函数式”编程方式，可以很容易得表述并发执行的计算。所有编程语言都必须与时俱进，Java再这方面显示出了非凡的能力。\nJava 9的主要特性要一直追溯到2008年。那时，Java平台首席工程师Mark Reinhold开始着力分解这个庞大的Java平台。为此引入了模块，模块是提供一个特定功能的自包含的代码单元。设计和实现一个适用于Java平台的模块系统前后用了11年，而它是否也适用于Java应用和类库还有待观察。Java9于2017年发布，它提供了另外一些吸引人的特性。\n从2018年开始，每6个月就会发布一个Java版本，以支持更快地引入新特性。某些版本（如Java 11）设计为长期支持的版本。\nJava程序设计安装Java开发工具包Oracle公司为Linux、Mac OS、Solaris 和 Windows 提供了最新、最完备的Java开发工具包版本。对于很多其他平台，也有处于不同开发阶段的JDK版本，不过，这些版本要相应平台的开发商授权和分发。\n下载JDK想要下载Java开发工具包，可以访问Oracle公司的网站：https://www.oracle.com/java/technologies/downloads/\n华为镜像网站：https://repo.huaweicloud.com/java/jdk/\n在得到所需的软件之前，必须弄清楚大量专业术语：\n\n\n你已经看到，JDK是Java Development Kit 的缩写。有点混乱的是：这个工具包的版本1.2~1.4被称为Java SDK。在某些场合下，还可以看到这个过时的术语。在Java 10之前，还有一个术语是Java运行时环境（JRE），它只包含虚拟机。这不是开发人员想要的，只是专门为不需要编译器的用户提供。\n接下来，你会看到大量的Java SE，相对于Java EE和Java ME，Java SE是Java标准版。\nJava2这种提法始于1998年。当时Sun公司的销售人员感觉以增加小数点后面数值的方式改变版本号并没有反映出JDK1.2的重大改进。但是，在于发布之后才意识到这个问题，所以他们决定开发工具包的版本号仍然沿用1.2，接下来的版本是1.3、1.4和5.0.不过，Java平台重新被命名为Java 2。因此，就有了Java 2 Standard Edition Software Development Kit（Java 2标准版软件开发包）5.0版，即J2SE SDK 5.0。\n幸运的是，2006年版本号得到简化。Java标准版的下一个版本取名为Java SE 6，后来又有了Java SE 7和Java SE 8\n不过，“内部”版本号分别是1.6.0、1.7.0和1.8.0.到了Java SE 9，这种混乱终于终结，版本号变为9，以及后来的9.0.1。（为什么没有使用9.0.0作为初始版本呢？为了保留一点兴奋感，版本号规范要求在主版本和第一次安全更新之间的短暂间隔中删除版本号末尾的零。）\n\n注：在此后面的Java 9表示Java SE 9\n\n在Java9之前，有32位和64位两个版本的Java开发工具包，现在Oracle公司不再开发32位版本。要使用Oracle JDK，你需要有一个64位的操作系统。\n对于Linux，还可以在RPM文件和.tar.gz文件之间做出选择。我们建议使用后者，这样就可以在任何位置直接解压缩这个压缩包。\n小结：\n\n我们需要的是JDK（Java SE 开发工具包），而不是JRE。\n对于Linux，选择 .tar.gz版本\n\n\n注：取决于具体情况，Oracle公司可能会提供一个捆绑包，其中包含Java开发工具包（JDK）和 NetBeans 集成开发环境。建议现在不要安装任何捆绑包，目前只需要安装Java开发工具包。如果以后打算使用NetBeans，可以再从 http://netbeans.org 下载.\n\n\n设置JDK下载JDK之后，需要安装这个开发工具包并明确要在哪里安装，后面还会需要这个信息。\n\n再Windows上，启动安装程序，会询问你要在哪里安装JDK。最好不要接收路径名称包含空格的默认位置，如 C:\\Program Files\\Java\\jdk-11.0.x。取出路径名中的Program Files部分就可以了。\n\n\n在Linux上，只需要把.tar.gz解压缩到你选择的某个位置，如你的主目录，或者&#x2F;opt。如果从RPM文件安装，则要反复检查是否安装在&#x2F;usr&#x2F;java&#x2F;jdk-11.0.x上。\n\n\n环境变量配置：\n\n在Linux中，需要在&#x2F;.bashrc或&#x2F;.bash_profile文件的最后增加这样一行：\nexport PATH=jdk/bin:$PATH\n\n一定要使用JDK的正确路径，如&#x2F;opt&#x2F;jdk-11.0.4。\n\n在Windows 10中，在搜索栏输入environment（环境），选择编辑账户的环境变量-环境变量。\n\n在User Variables（用户变量）列表中找到并选择一个名为Path的变量。点击Edit（编辑）按钮，再点击New（新建）按钮，添加一个变量，值为jdk\\bin目录\n\n打开一个终端窗口输入javac --version,来检查配置是否正确：\n\n\n\n安装库源文件和文档源文件：\n\n注：如果含有源文件可以跳过此步骤\n\n\n类库源文件在JDK中以压缩文件lib&#x2F;src.zip的形式发布，将其解压缩后才能够访问源代码。只需要完成以下步骤：\n\n确保JDK已经安装，而且jdk&#x2F;bin目录在可执行路径中。\n\n在主目录中创建一个目录javasrc。如果愿意，可以从一个终端窗口完成这个步骤。\nmkdir javasrc\n\n在jdk&#x2F;lib 目录下找到文件src.zip。\n\n将src.zip 文件解压到javasrc目录。在一个终端窗口中，可以指向以下命令：\ncd javasrcjar xvf jdk/lib/src.zipcd ...\n\n\n提示：src.zip文件中包含了所有公共类库的源代码。要想获得更多源代码（例如编译器、虚拟机、原生方法以及私有辅助类），请访问网站 http://openjdk.java.net\n\n文档：\n文档包含在一个压缩文件中，它是一个独立于JDK的压缩文件。可以从网站 http://www.oracle.com/technetwork/java/javase/downloads 下载这个文档。\n使用命令行工具第一次安装Java时，需要先检查Java的安装是否正确。另外，通过自己执行这些基本步骤，可以更好得理解开发环境的后台工作。\n在掌握了编译和运行Java程序的基本步骤之后，我们就需要使用专业的开发环境，让我们从基础开始吧：\n首先介绍比较难的方法：从命令行编译并运行Java程序。\n\n打开一个终端窗口。\n\n进入 corejava\\v1ch02\\welcome目录（下载地址：点我）\n\n输入下面的命令：\njavac Welcome.javajava Welcome\n\n\n\n\n如果成功输出如上结果，可喜可贺，我们已经编译了并运行了第一个Java程序。\n那么，刚才发生了什么？javac程序是一个Java编译器，他将文件Welcome.java编译成Welcome.class。Java程序启动Java虚拟机，虚拟机执行编译器编译到类文件中的字节码。\n/** * This program displays a greeting for the reader. * @version 1.30 2014-02-27 * @author Cay Horstmann */public class Welcome&#123;   public static void main(String[] args)   &#123;      String greeting = &quot;Welcome to Core Java!&quot;;      System.out.println(greeting);      for (int i = 0; i &lt; greeting.length(); i++)         System.out.print(&quot;=&quot;);      System.out.println();   &#125;&#125;\n\n在使用集成开发环境的年代，许多程序员对于在终端窗口中运行程序已经很生疏了。常常会出现很多错误，最终导致令人沮丧的结果。\n一定要注意一下几点：\n\n如果手工输入源程序，一定要注意正确地输入大小写。例如，类名为Welcome,而不是welcome或WELCOME,\n编译器需要一个文件名(Welcome.java),而运行程序时，只需要指定类名(Welcome),不要带扩展名，.java或.class.\n如果看到诸如Bad command or file name或javac:command not found之类的消息，就要返回去反复检查安装是否有问题，特别是可执行路径的设置。\n如果javac报告了一个错误，指出无法找到Welcome.java,就应该检查目录中是否存在这个文件。\n在Linux环境下，检查Welcome.java是否以正确的大写字母开头。\n在Windows环境下，使用命令dir,而不要使用图形浏览器工具。有些文本编辑器(特别是Notepad)会在每个文件名后面添加扩展名 .txt。如果使用Notepad编辑Welcome.java,实际上会把它保存Welcome.java.txt。如果采用默认的Windows设置，浏览器会与Notepad“勾结”，隐藏，txt扩展名，因为这属于“已知的文件类型”。对于这种情况，需要使用命令ren重新命名这个文件，或是另存一次，在文件名两边加一对双引号，如：”Welcome.java”。\n\n\n运行程序之后，如果收到关于java.lang.NoClassDefFoundError的错误消息，就应该仔细地检查出问题的类名。\n如果收到关于welcome(w为小写)的错误消息，就应该重新执行命令：java Welcome(W为大写)。记住，Java区分大小写。\n如果收到有关Welcome&#x2F;java的错误信息，这说明你错误地键入了java Welcome.java,应该重新执行命令java Welcome.\n\n\n如果键入java Welcome,而虚拟机没有找到Welcome类，就应该检查是否有人设置了系统的CLASSPATH环境变量（将这个变量设置为全局并不是提倡的做法，然而，Windows中有些比较差的软件安装程序确实会这样做）。可以像设置PATH环境变量一样设置CLASSPATH,不过这里将删除这个设置。\n\n\n注：在JDK 11中，单个源文件不再需要javac命令。这个特性是为了支持以”shebang“(#!)行(#!&#x2F;path&#x2F;to&#x2F;java)开头的shell脚本。\n\n接下来再来尝试一个图像化应用。这个程序是一个简单的图像文件查看器，可以加载和显示一个图像。与前面一样，从命令行编译和运行这个程序。\n\n打开一个终端窗口\n\n切换到目录corejava\\v1ch02\\ImageViewer\n\n输入以下命令：\njavac ImageViewer.javajava ImageViewer\n\n\n\n\n会弹出一个新的程序窗口（ImageViewer应用）。现在选择File-&gt;Open，找到一个要打开的图像文件。（这个目录下有两个示例文件。）然后会显示这个文件。\n要关闭这个程序，可以点击标题栏上的关闭按钮，或者从菜单选择File-&gt;Exit。\nimport java.awt.*;import java.io.*;import javax.swing.*;/** * A program for viewing images. * @version 1.31 2018-04-10 * @author Cay Horstmann */public class ImageViewer&#123;   public static void main(String[] args)   &#123;      EventQueue.invokeLater(() -&gt; &#123;         var frame = new ImageViewerFrame();         frame.setTitle(&quot;ImageViewer&quot;);         frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);         frame.setVisible(true);      &#125;);   &#125;&#125;/** * A frame with a label to show an image. */class ImageViewerFrame extends JFrame&#123;   private static final int DEFAULT_WIDTH = 300;   private static final int DEFAULT_HEIGHT = 400;   public ImageViewerFrame()   &#123;      setSize(DEFAULT_WIDTH, DEFAULT_HEIGHT);      // use a label to display the images      var label = new JLabel();      add(label);      // set up the file chooser      var chooser = new JFileChooser();      chooser.setCurrentDirectory(new File(&quot;.&quot;));      // set up the menu bar      var menuBar = new JMenuBar();      setJMenuBar(menuBar);      var menu = new JMenu(&quot;File&quot;);      menuBar.add(menu);      var openItem = new JMenuItem(&quot;Open&quot;);      menu.add(openItem);      openItem.addActionListener(event -&gt; &#123;         // show file chooser dialog         int result = chooser.showOpenDialog(null);         // if file selected, set it as icon of the label         if (result == JFileChooser.APPROVE_OPTION)         &#123;            String name = chooser.getSelectedFile().getPath();            label.setIcon(new ImageIcon(name));         &#125;      &#125;);      var exitItem = new JMenuItem(&quot;Exit&quot;);      menu.add(exitItem);      exitItem.addActionListener(event -&gt; System.exit(0));   &#125;&#125;\n\n使用集成开发工具我们已经了解如何从命令行编译和运行一个Java程序。这是一个很有用的排错技能，不过对于大多数日常工作来说，这还是应该使用集成开发环境。这些环境非常强大，非常方便，不使用这些集成环境简直有些不合情理。我们可以免费获得一些很棒的开发环境，如Eclipse、IntelliJ IDEA 和 NetBeans。\nEclipse下载地址：http://eclipse.org/downloads\n下载之后运行安装程序，并选择Eclipse IDE for Java Developers。\n\n下面是用Eclipse编写程序的一般步骤：\n\n启动Eclipse之后，从菜单选择File-&gt;New-&gt;Project\n从向导对话框中选择Java Project\n点击Next按钮，不选中”Use default location“复选框。点击Browse导航到core-java&#x2F;v1ch02&#x2F;Welcome目录。\n点击Finish按钮。这个工程已经创建完成了。\n点击工程窗口左边窗格中的三角，直到找到Welcome.java并双击这个文件。现在应该看到一个包含程序代码的窗格\n用鼠标右键点击左侧窗格中的工程名（Welcome），选择Run-&gt;Run As-&gt;Java Application。程序输出会显示在控制台窗格中。\n\n\n之前假定这个程序没有输入错误或bug（毕竟，这段代码只有几行）。为了说明问题，假设在代码中不小心出现了录入错误（或者甚至语法错误）。试着将原来的程序修改一下，让它包含一些录入错误，列入，将String的大小写弄错：\nstring greeting = &quot;Welcome to Core Java!&quot;;\n\n\n注意string下面的波浪线。点击源代码下标签中的Problems，展开小三角，直到看到一个错误消息指出有一个未知的string类型。点击这个错误消息。光标会移到编辑窗格中相应的代码行，可以在这里纠正错误。利用这个特性可以快速地修正错误。\n\n提示：通常，Eclipse错误报告会伴有一个灯泡图标。点击这个图标可以得到解决这个错误的建议方案列表。\n\nJShellJava9进入了另一种使用Java的方式。JShell程序提供一个“读取-计算-打印循环”（Read-Evaluate-Print Loop。REPL）。键入一个Java表达式；JShell会评估你的输入，打印结果，等待你的下一个输入。\n要启动JShell，只需要在终端窗口中键入jshell\nJShell首先会向你显示一个问候语，后面是一个提示符：\n\n现在键入一个表达式，如下：\n&quot;Core Java&quot;.length()\n\nJShell会回应一个结果——在这里就是”Core Java“中的字符个数。\n$1 ==&gt; 9\n\n注意，我们并没有输入System.out.println。JShell会自动打印你输入的每一个表达式的值。输出中的$1表示这个结果可以用来的计算。例如，如果你输入：\n5 * $1 - 3\n\n\n就会得到：\n\n如果需要多次使用一个变量，可以给它们指定一个容易记忆的名字。不过，一定要遵循Java语法，需要指定类型和变量名。例如：\njshell&gt; int answer = 6 * 7answer ==&gt; 42\n\n另一个有用的特性是”tab补全“。如果输入：\nMath.\n\n然后再按一次Tab键。你就会得到可以在generator变量上调用的所有方法的一个列表：\n\n现在输入l，然后再按一次Tab键。方法名会补全位log，现在你会得到一个比较小的列表：\n\n接下来可以手动填入其余的部分：\njshell&gt; Math.log10(0.001)\n\n\n要重复运行一个命令，可以连续按↑键，知道看到想要重新运行或编辑的命令行。可以用←和→键移动命令行中的光标位置，然后添加或删除字符。编辑完命令后再按回车。例如，把命令行中的0.001替换为1000，然后按回车：\n\nJShell会让Java语言和类库的学习变得轻松而有趣，它不要求你启动一个庞大的开发环境，不会让你再为public static void main而困扰。\nJava的基本程序设计结构一个简单的Java应用程序下面看一个最简单的Java应用程序，它只发送一条消息到控制台窗口中：\npublic class FirstSample &#123;  public static void main(String[] args)  &#123;    System.out.println(&quot;We will not use &#x27;Hello,World!&#x27;&quot;);  &#125;&#125;\n\n\n\n注：出于个人习惯，本人用的是IntelliJ IDEA，Eclipse IDE实在用不惯。\n\n这个程序很简单，所有的Java应用程序都具有这种结构，因此还是值得花一些时间来研究的。首先，Java区分大小写。如果出现了大小写拼写错误（例如，将main拼写成Main），程序将无法运行。\n下面逐行地查看这段源代码。关键字public称为访问修饰符（access modifier），这些修饰符用于控制程序的其他部分对这段代码的访问级别。关键字class表明Java程序中的全部内容的包括在类中。类是构建所有Java应用程序和applet的构建块。Java应用程序中的全部内容都必须放置在类中。\n关键字class后面紧跟类名。Java中定义类名的规则很宽松。名字必须以字母开头，后面可以跟字母和数字的任意组合。长度基本上没有限制。但是不能用Java保留字（例如，public或class）作为类名。\n类名是以大写字母开头的名词。如果名字是由多个单词组成，每个单词的第一个字母都应该大写（驼峰命名法）。\n源代码的文件必须与公共类的名字相同，并用.java作为扩展名。因此，存储这段源代码的文件必须为FirstSample.java。\n如果正确的命名了这个文件，并且源代码没有任何录入错误，在编译这段源代码之后就会得到一个包含这个类字节码的文件。Java编译器将字节码文件自动地命名为FirstSample.class，并存储在源文件的同一个目录下。\nJava虚拟机总是从指定类中的main方法的代码开始执行（这里的”方法“就是Java中的”函数“），因此为了代码能够执行，在类的源文件中必须包含一个main方法。当然，也可以将用户自定义的方法添加到类中，并将main方法中调用这些方法。\n需要注意源代码中的大括号{}.在Java中，像在C&#x2F;C++中一样，用大括号划分程序的各个部分（通常称为块）。Java中任何方法的代码都用”{“ 开始，用 ”}“结束。\n大括号的使用风格曾经引发过许多无意义的争论。我们的习惯是把匹配的大括号上下对齐。不过，由于空白符会被Java编译器忽略，可以选用自己喜欢的大括号风格。\n我们暂时不用理睬关键字static void，而仅把它们当作编译Java 应用程序必须要的部分就行了。现在只需要机制：每个Java应用程序都必须有一个main方法，其声明格式如下所示：\npublic class ClassName&#123;    public static void main(String[] args)    &#123;        program statements    &#125;&#125;\n\n接下来研究以下代码：\n&#123;    System.out.printlun(&quot;We Will not use &#x27;Hello, World!&#x27;&quot;);&#125;\n\n一对大括号表示方法体的开始与结束，在这个方法中只包含一条语句。与大多数程序设计语言一样，可以将Java语句看成是语言中的句子。在Java中，每个句子必须用分号结束。特别需要说明，回车不是语句结束标志，因此，如果需要将一条语句写在多行上。\n在上面这个main方法体中只包含了一条语句，其功能是将一个文本行输出到控制台上。\n在这里，我们使用System.out对象并调用了它println方法。注意，点好（.）用于调用方法Java使用的通用语法是\nobject.method(parameters)\n\n这等价于函数调用。\n在这个示例中，调用了println方法并传递给它一个字符串参数。这个方法将传递给它的字符串参数显示在控制台上。然后，终止是这个输出行，使得每次调用println都会在新的一行上显示输出。需要注意一点，Java与C&#x2F;C++一样，都采用双引号界定字符串。\n与其他程序设计语言的函数一样，Java中的方法可以没有参数，也可以有一个或者多个参数（实参）。即使一个方法没有参数，也需要需用空括号。例如，不带参数的println方法只打印一个空行。使用下面的语句来调用：\nSystem.out.println();\n\n\n注：System.out 还有一个print方法，它不在输出之后增加换行符。例如，Ststem.out.print(“Hello”)打印”Hello”之后不换行，后面的输出紧跟在字母”o”之后。\n\n注释与大多数程序设计语言一样，Java中的注释也不会出现在可执行程序中。因此，可以在源程序中根据需要添加任意多的注释，而不必担心可执行代码会膨胀。在Java中，有3种标记注释的方式，最常用的方式是使用&#x2F;&#x2F;，其注释内容从&#x2F;&#x2F;开始到本行结尾。\nSystem.out.println(&quot;We will not use &#x27;Hello, World!&#x27;&quot;); //is this too cute?\n\n当需要更长的注释时，既可以在每行的注释前面标记&#x2F;&#x2F;。也可以使用&#x2F;* 和 *&#x2F;注释界定符将一段比较长的注释括起来。\n最后，第3种注释可以用来自动地生成文档。这种注释以/** 开始，以*/结束。\n\n\n注：注释不能嵌套\n\n数据类型Java是一种强类型语言。这就意味着必须为每一个变量声明一种类型。在Java中，一共有8种基本类型（primitive type），其中有4种整数、2种浮点类型、1种字符类型char（用于表示Unicode编码的代码单元）和1种用于表示真值的boolean类型。\n整数整数用于表示没有小数的数值，允许是负数。Java提供了4种整型。\n\n在通常情况下，int类型最常用。但如果想要表示整个地球的居住人口。就需要使用long类型了。byte和short类型主要用于特定的应用场合，例如，底层文件处理或者存储空间很宝贵时的大数组。\n在Java中，整型的范围与运行Java代码的机器无关。这就解决了软件从一个平台移植到另一个平台，或者在同一个平台中的不同操作系统直接进行移植给程序员带来的诸多问题。与此相反，C和C++程序会针对不同的处理器选择最为高效的整数，这样就会造成一个32位处理器上运行很好的C程序在16位系统上运行时却发生整数溢出。由于Java程序必须保证在所有机器上都能得到相同的运行结果，所以各种数据类型的取值范围必须固定。\n长整数数值有一个后缀L或l（如 4000000000L）。十六进制数值有一个前缀0x或0\nX（如0xCAFE）。八进制有一个前缀0，例如，010对应十进制中的8。很显然，八进制表示法比较容易混淆，所以建议做好不要使用八进制常数。\n从Java7开始，加上前缀0b或0B就可以写二进制数。列入，0b1001就是9.另外，同样是从Java7开始，还可以为数字字面量加下划线，如用1_000_000（或0B1111_0100_0010_0100_0000）表示100万。这些下划线只是为了让人更易读。Java编译器会去除这些下划线。\n浮点类型浮点类型用于表示有小数部分的数值。在Java中有两种浮点类型。\n\ndouble表示这种类型的数值精度是float类型的两倍（双精度数值）。\nfloat类型的数值有一个后缀F或f（例如，3.14F）。没有后缀F的浮点数值（如3.14）默认为double类型。当然，也可以在浮点数值后面添加后缀D或d（例如，3.14D）。\n所有的浮点数值计算都遵循IEEE 754规范。具体来说，下面是用于表示溢出和出错情况的三个特殊的浮点数值：\n\n正无穷大\n负无穷大\nNaN（不是一个数字）\n\n例如，一个正整数除以0的结果为正无穷大。计算0&#x2F;0或者负数的平方根结果为NaN。\nchar类型char类型原本用于表示单个字符。不过，现在情况已经有所变化。如今，有些Unicode字符可以用一个char值描述，另外一些Unicode字符则需要两个char值。\nchar类型的字面量值要用单引号括起来。例如：“A”是编码值为65的字符常量。它与“A”不同，“A”是包含一个字符A的字符串。\n\n在Java中，char类型描述了UTF-16编码中的一个代码单元。\n强烈建议不要在程序中使用char类型，除非确实处理UTF-16代码单元，最好将字符串作为抽象数据类型处理。\nboolean 类型boolean（布尔）类型有两个值：false和true，用来判定逻辑条件。整型值和布尔值之间不能进行相互转换。\n变量与常量与所有程序设计语言一样，Java也使用变量存储值。常量就是不变的变量。\n声明变量在Java中，每个变量都有一个类型（type）。在声明变量时，先指定变量的类型，然后是变量名。实例：\ndouble salary;int varationDays;long earthPopulation;boolean done;\n\n变量名必须是一个以字母开头并由字母或数字构成的序列。字母包括‘A’‘Z’、‘a’‘z’、‘_’、‘$’,或在某种语言中表示字母的任何Unicode字符。\n不能使用Java保留字作为变量名。在Java9中，单下划线_不能作为变量名；\n可以在一行中声明多个变量：\nint i,j;  //both are integers\n\n不过，不提倡使用这种风格。逐一声明每一个变量可以提高程序的可读性。\n变量初始化声明一个变量之后，必须用赋值语句对变量进行显式初始化，千万不要使用未初始化的变量的值。例如，Java编译器认为下面的语句序列是错误的：\nint vacationDays;System.out.println(vacationDays); //ERROR--variable not initialized\n\n想要对一个已经声明过的变量进行赋值，就需要将变量名放在等号（&#x3D;）左侧，再把一个适当取值的Java表达式放在等号右侧。\nint vacationDays;vacationDays = 12;\n\n也可以将变量的声明和初始化放在同一行中。例如：\nint vacationDays = 12;\n\n在Java中，变量的声明尽可能地靠近变量第一次使用的地方，这是一种良好的程序编写风格。\n\n注：从Java10开始，对于局部变量，如果可以从变量初始值推断出它的类型，就不再需要声明类型。只需要使用关键字var而无需指定类型：\nvar vacationDays = 12;//vacationDays is an intvar greeting = &quot;Hello&quot;; //greeting is a String\n\n常量在Java中，利用关键字final指示常量。例如：\npublic class Constants &#123;  public static void main(String[] args)&#123;    final double CM_PER_INCH = 2.54;    double paperWidth = 8.5;    double paperHeight = 11;    System.out.println(&quot;Paper size in centimeters: &quot; + paperWidth * CM_PER_INCH + &quot;by&quot; + paperHeight * CM_PER_INCH);  &#125;&#125;\n\n关键字final表示这个变量只能被赋值一次。一旦被赋值之后，就不能够再更改了。习惯上，常量名使用全大写。\n类常量（class constant）可以在一个类的多个方法使用。使用关键字static final设置一个类常量：\npublic class Constants2 &#123;  public static final double CM_PER_INCH = 2.54;//类常量  public static void main(String[] args)  &#123;    double paperWidth = 8.5;    double paperHeight = 11;    System.out.println(&quot;Paper size in Centimeters:&quot; + paperWidth * CM_PER_INCH + &quot;by&quot; + paperHeight * CM_PER_INCH);  &#125;&#125;\n\n类常量的定义位于main方法的外部。因此，同一个类的其他方法中也可以使用这个常量。\n枚举类型枚举类型包括有限个命名的值。例如：\nenum Size &#123; SMALL,MEDIUM,LARGE,EXTRA_LARGE &#125;;\n\n声明这种类型变量：\nSize s = Size.MEDIUM;\n\nSize类型的变量只能储存这个类型声明中给定的某个枚举值，或者特殊值null；\n运算符运算符用于连接值。Java提供了一组丰富的算数和逻辑运算符以及数学函数。\n算数运算符在Java中，使用算数运算符 +、-、*、&#x2F;表示加、减、乘、除运算.当参与&#x2F;运算的两个操作数都是整数时，表示整数除法：否则，表示浮点除法。整数的求余操作（有时候称为取模）用%表示。例如，15&#x2F;2等于7，15%2等于1，15.0&#x2F;2等于7.5。\n需要注意，整数被除0会产生一个异常，而浮点数被0除将会得到无穷大或NaN的结果。\n数学函数与常量在Math类中，包含了各种各样的数学函数。\n想要计算一个数值的平方根，可以使用sqrt方法：\ndouble x = 4;double y = Math.sqrt(x);System.out.println(y);  //prints 2.0\n\n\n注：println方法处理System.out对象。Math类中的sqrt方法并不处理任何对象，这种方法被称为静态方法。\n\n在Java中，没有幂运算，因此需要借助于Math类的pow方法。以下语句：\ndouble y = Math.pow(x,a);\n\n将y的值设置为x的a次幂（xᵃ）。pow方法有两个double类型的参数，其返回结果也为double类型。\nMath类提供了一些常用的三角函数：\n\nMath.sin\nMath.cos\nMath.tan\nMath.atan\nMath.atan2\n\n还有指数函数以及它的反函数-自然对数以及以10为底的对数：\n\nMath.exp\nMath.log\nMath.log10\n\n最后，Java还提供了两个用于表示Π和e常量的最接近的近似值：\n\nMath.PI\nMath.E\n\n数值类型之间的转换我们经常需要将一种数值类型转换为另一种数值类型。\n\n实线箭头表示无信息丢失的转换，虚线箭头，表示可能有精度损失的转换。\nint n = 123456789;float f = n; //f is 1.23456792E8\n\n强制类型转换有时候可能损失信息的转换通过强制类型转换（cast）来完成。\n强制类型转换的语法格式是在圆括号中给出想要转换的目标类型，后面紧跟待转换的变量名。例如：\ndouble x = 9.997;int nx = (int)x; //nx is 9\n\n这样，变量nx的值为9，因为强制类型转换通过截断小数部分将浮点值转换为整型。\n如果想对浮点数进行舍入运算，以便获得到最接近的整数，那就需要用Math.round方法：\ndouble x = 9.997;int nx = (int)Math.round(x); //nx is 10\n\n当调用round的时候，仍需要使用强制类型转换（int）。其原因是round方法返回的结果为long类型，由于存在信息丢失的可能性，所以只有通过使用显式的强制类型转换才能够将long类型转换成int类型。\n综合赋值和运算符可以在赋值中使用二元运算符，这是一种很方便的简写形式。例如：\nx += 4;\n\n等价于：\nx = x + 4;\n\n 一般来说，要把运算符放在&#x3D;号左边，如*&#x3D;或%&#x3D;.\n\n注：如果运算符得到一个值，其类型与左侧操作数的类型不同，就会发生强制类型转换。例如，如果x是一个int，则以下语句\nx += 3.5;\n\n是合法的，将把x设置为(int)(x+3.5)。\n\n自增与自减运算符当然，程序员都知道加1、减1是数值变量最常见的操作。在Java中，借鉴了C和C++中的做法，也提供了自增、自减运算符：n++将变量n的当前值加1，n–则将n的值减1.例如：\nint n = 12;n++;\n\n将n的值改为13。由于这些运算符改变的是变量的值，所以它们不能应用于数值本身。例如，4++就不是一个合法的语句。\n实际上，这些运算符有两种形式；除了上面的”后缀“形式，还有一种”前缀“形式：++n。后缀和前缀形式都会使变量值加1或减1。\n前缀形式会先完成加1；而后缀形式会使用变量原来的值。\nint m = 7;int n = 7;int a = 2 * ++m; //now a is 16,m is 8int b = 2 * m++; //new b is 14,m is 8\n\n建议不要在表达式中使用++，因为这样的代码很容易让人困惑，而且会带来烦人的bug。\n关系和boolean运算符Java包含丰富的关系运算符。要检测相等性，可以使用两个等号 ==。例如，3 == 7的值为false。\n另外可以使用!=检测不相等。例如，3 != 7的值为true。\n最后，还有经常使用的&lt;、&gt;、&lt;=和&gt;=运算符。\nJava沿用了C++的做法，使用&amp;&amp;表示逻辑”与”运算符，使用||表示逻辑”或”运算符。从!=运算符可以想到，感叹号!就是逻辑非运算符。&amp;&amp;和||运算符是按照”短路”方式来求值的：如果第一个操作数已经能够确定表达式的值，第二个操作数就不必计算了。如果用&amp;&amp;运算符合并两个表达式，\nexpression1 &amp;&amp; expression2 //false\n\n而且已经计算得到第一个表达式的真值为false，那么结果就不可能为true。因此，第二个表达式就不必计算了。可以利用这一点来避免错误。例如，在下面的表达式中：\nx != 0 &amp;&amp; 1 / x &gt; x + y //no division by 0\n\n如果x等于0，那么第二部分就不会计算。因此，如果x为0，也就不会计算1&#x2F;x，除以0的错误就不会出现。\n类似地，如果第一个表达式为true，expression1 || expressopn2的值就自动为 true，而无需计算第二个表达式。\n最后一点，Java支持三元操作符?:，这个操作符有时很有用。如果条件为true,下面的表达式\ncondition ? expression1 : expression2\n\n就为第一个表达式的值，否则计算为第二个表达式的值，例如，\nx &lt; y ? x : y\n\n会返回x和y中比较小的一个。\n位运算符处理整型类型时，可以直接对组成整数的各个位完成操作。这意味着可以使用掩码技术得到整数中的各个位，位运算符包括：\n&amp;(&quot;and&quot;) |(&quot;or&quot;) ^(&quot;xor&quot;) ~(&quot;not&quot;)\n\n这些运算符按位模式处理。例如，如果n是一个整数变量，而且用二进制表示的n从右边数第4位为1，则：\nint fourthBitFromRight = (n &amp; 0b1000) /0b1000;\n\n会返回1，否则返回0，利用&amp;结合使用适当的2的幂，可以把其他位掩掉，而只留下其中的某一位。\n另外，还有&gt;&gt;和&lt;&lt;运算符可以将位模式左移或右移。需要建立位模式来完成掩码时，这两个运算符会很方便：\nint fourthBitFromRight = (n &amp; (1 &lt;&lt;3)) &gt;&gt; 3;\n\n最后，&gt;&gt;&gt;运算符会用0填充高位，这与&gt;&gt;不同，它会用符号位填充高位。不存在&lt;&lt;&lt;运算符。\n\n警告：位移运算符的右操作数要完成模32的运算（除非左操作数时long类型，在这种情况下需要对右操作数模64）。例如,1&lt;&lt;35的值等同于1&lt;&lt;3或8。\n\n括号与运算符级别\n字符串从概念上讲，Java字符串就是Unicode字符序列。例如，字符串”Java\\u2122“由5Unicode字符J、a、v、a和™组成。Java没有内置的字符串类型。而是在标准Java类库提供了一个预定义类，很自然地叫做String。每个用双引号括起来的字符串都是String类一个实例：\nString e = &quot;&quot;; // an empty stringString greeting = &quot;Hello&quot;;\n\n子串String类的substring方法可以从一个较大的字符串提取出一个子串。例如：\nString greeting = &quot;Hello&quot;;String s = greeting.substring(0,3); \n\n创建一个由字符”Hel“组成的字符串。\n\n注：类似于C和C++，Java字符串中的代码单元和代码点从0开始计数。\n\n拼接与绝大多数程序设计语言一样，Java语言允许使用+号连接（拼接）两个字符串。\nString expletive = &quot;Expletive&quot;;String PG13 = &quot;deleted&quot;;String message = expletive + PG13; //&quot;Expletivedeleted&quot;\n\n当将一个字符串与一个非字符串的值进行拼接时，后者会转换成字符串。例如：\nint age = 13;String rating = &quot;PG&quot; + age; //&quot;PG13&quot;\n\n如果需要把多个字符串放在一起，用一个界定符分割，可以使用静态join方法：\nString all = String.join(&quot;-&quot;, &quot;This&quot;, &quot;is&quot;, &quot;a&quot;, &quot;String&quot;);\t//message returned is: &quot;This-is-a-String&quot;\n\n在Java 11中，还提供了一个repeat方法：\nString repeated = &quot;Java&quot;.repeat(3); //repeated is ”JavaJavaJava“\n\n不可变字符串String类没有提供修改字符串中某个字符的方法。如果希望将greeting的内容修改为”Hello“，可以提取想要保留的字串，再与希望替换的字符拼接：\nString greeting = &quot;Help!&quot;greeting = greeting.substrung(0,3) + &quot;lo&quot;; //greeting is Hello\n\n由于不能修改Java字符串中的单个字符。所以在Java文档中将String类对象称为是不可变的（immutable），字符串”Hello“永远包含字符H、e、l、l和o代码单元序列。虽然不能修改这些值，不过可以修改字符串变量greeting，让它引用另外一个字符串。\n这样做是否会降低运行效率呢？看起来好像修改一个代码单元要比从头创建一个新字符串更加简洁。答案是：也对，也不对。的确，通过拼接”Hel“和”lo“来创建一个新的字符串的效率确实不高。但是，不可变字符串却有一个优点：编译器还可以让字符串共享。\n检测字符串是否相等可以使用equals方法检测两个字符串是否相等。对于表达式：\ns.equals(t)\n\n如果字符串s与字符串t相等，则返回true；否则，返回false。需要注意的是，s与t可以是字符串变量，也可以是字符串字面量。例如，以下表达式是合法的：\n&quot;Hello&quot;.equalsIgnoreCase(&quot;Hello&quot;)\n\n一定不要使用&#x3D;&#x3D;运算符检测两个字符串是否相等！这个运算符只能够确定两个字符串是否存放在同一个位置上。当然，如果字符串在同一个位置上，它们必然相等。但是，完全由可能将内容相同的多个字符串副本放置在不同的位置上。\nString greeting = &quot;Hello&quot;; //initialize greeting to a stringif (greeting == &quot;Hello&quot;)...    //probably trueif (greeting.substring(0,3) == &quot;Hel&quot;)...    //probably false\n\n如果虚拟机始终将相同的字符串共享，就可以使用&#x3D;&#x3D;运算符检测是否相等。但实际上只有字符串字面量是共享的，而+或substring等操作得到的字符串并不共享。因此，千万不要使用&#x3D;&#x3D;运算符测试字符串的相等性。\n","categories":["WEBbackend"],"tags":["Java"]},{"title":"MyBatis","url":"/2023/01/13/WebBackend/Java/MyBatis%E7%A0%94%E7%A9%B6/","content":"Preface记录知识是一个重要的习惯，尤其是对于一个技术框架来说，Mybatis虽然简单易用，但是为了更好地理解其基本概念和原理，我决定在2023年1月13日开始编写这篇笔记。这将不仅仅是使用API字典。在导师（项目经理）的指导下，我将自己的理解与导师的讲解相结合，当然我也References(借鉴)了网上一些优秀的文章，这样做不仅有助于我自己未来复习回顾，同时也希望对阅读这篇文章的人有所帮助。\nSynopsisMyBatis是一个开源、轻量级的持久层框架，它内部封装了JDBC，可以简化JDBC加载驱动、创建连接、创建statement等繁杂过程，使开发人员更专注于SQL语句本身。\n\nPS：MyBatis不是专门用于ORM映射，而是为了简化和优化JDBC操作而设计的，所以严格意义上来讲，MyBatis不是ORM框架。\n\n总结要点：\n\nMyBatis是一款优秀的持久层框架，主要通过XML或注解来配置和映射原始类型、接口和Java POJO（Plain Old Java Objects，普通老式Java对象）为数据库中的记录。它支持自定义SQL、存储过程以及高级映射，可以在实体类和SQL语句之间建立映射关系。\nMyBatis减少了大量的JDBC代码、设置参数和获取结果集的重复工作。并且连接池是可选的，默认使用的是PooledDataSource（Apache commons DBCP）连接池。\nMyBatis不同于Hibernate等全自动化ORM框架，它更多的是手动编写SQL，用来满足在追求性能和灵活性的同时对于开发者更好的掌握数据库操作。\n\n\nORM (Object Relational Mapping，对象关系映射) 是一种数据持久化技术，它在对象模型和关系型数据库之间建立起对应关系。ORM提供了一种机制，通过JavaBean对象去操作数据库表中的数据。 这样就可以避免编写大量的SQL语句和JDBC代码，提高开发效率。\n常见的ORM框架有：Hibernate、Entity Framework、SQLAlchemy、Sequelize\n\n构建方式普通构建：Mybatis安装方式有很多种，其中最简单一种就是直接下载MyBatis的jar包，然后导入到项目中。\n\n下载MyBatis jar包：可以从MyBatis官网或者Github上下载最新版本的jar包。\n将jar包导入到项目中：将下载下来的jar包文件导入到项目中即可。\n\nmaven构建：使用maven构建时，可以通过在pom.xml文件上添加下面的代码来添加MyBatis的依赖。需要注意的是，version应该填写最新版本号。\n&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;    &lt;version&gt;x.x.x&lt;/version&gt;&lt;/dependency&gt;\n\nMyBatis文件目录结构这是常用的目录结构，但是和Maven项目的目录结构会有所不同。\n\n\ndao：数据访问对象。用于存放与数据库交互的类，负责数据访问层的实现。\nfactory：工厂。用于存放工厂类，这些类用于创建其他对象。\nmapper：映射器。用于存放于数据库表之间的映射关系。\nmodel：模型。用于存放项目中的实体类，这些类用于表示数据库中的表。\ntest：测试。用于存放单元测试代码。\n\n主配置文件\n\n&lt;configuration&gt;是配置文件的根标签，里面包含了Mybatis的各种配置信息。\n&lt;properties&gt;标签用于配置Mybatis使用的属性文件。\n&lt;settings&gt;标签用于配置Mybatis的运行时设置。\n&lt;typeAliases&gt;标签用于配置类型别名。\n&lt;typeHandlers&gt;标签用于配置类型处理器。\n&lt;objectFactory&gt;标签用于配置对象工厂。\n&lt;plugins&gt;标签用于配置插件。\n&lt;environments&gt;标签用于配置环境变量(环境配置)，里面包含&lt;environment&gt;标签。\n&lt;environment&gt;标签用于配置单个环境变量，里面包含:\n&lt;transactionManager&gt;用于配置事物管理器。\n&lt;dataSource&gt;用于配置数据源。\n\n\n&lt;databaseIdProvider&gt;标签用于配置数据库厂商标识。\n&lt;mappers&gt;标签用于配置映射器。\n\n\nPS：除了这些重要标签，还有其他标签可用。具体方式可参考MyBatis官方文档。阅读官方文档是一个非常高效的学习方式。\n\n公共类\n构建sqlSessionFactory\n打开sqlSession会话，并执行sql\n\n\npublic class MybatisTest &#123;   public static void main(String[] args) throws Exception &#123;      // 指定全局配置文件      String resource = &quot;mybatis-config.xml&quot;;      // 读取配置文件      InputStream inputStream = Resources.getResourceAsStream(resource);      // 构建sqlSessionFactory      SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);      // 获取sqlSession      SqlSession sqlSession = sqlSessionFactory.openSession();      try &#123;         // 操作CRUD，第一个参数：指定statement，规则：命名空间+“.”+statementId         // 第二个参数：指定传入sql的参数：这里是用户id         User user = sqlSession.selectOne(&quot;MyMapper.selectUser&quot;, 1);         System.out.println(user);      &#125; finally &#123;         sqlSession.close();      &#125;   &#125;&#125;\n\nMapper.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper  PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;  &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- mapper:根标签，namespace：命名空间，随便写，一般保证命名空间唯一 --&gt;&lt;mapper namespace=&quot;MyMapper&quot;&gt;   &lt;!-- statement，内容：sql语句。id：唯一标识，随便写，在同一个命名空间下保持唯一      resultType：sql语句查询结果集的封装类型,tb_user即为数据库中的表    --&gt;   &lt;select id=&quot;selectUser&quot; resultType=&quot;com.zpc.mybatis.User&quot;&gt;      select * from tb_user where id = #&#123;id&#125;   &lt;/select&gt;&lt;/mapper&gt;\n\n执行\n\n查询多条数据\n插入修改删除\n动态SQL语句\n多表连接-一对多\n多表连接-一对一\n多表连接-动态SQL\n注解开发\nConclusionReferences[1] MyBatis 全网最通俗易懂的教程（2020年、非常详细） - B站狂神MyBatis\n[2] Mybatis - C语言中文网\n[3] MyBatis 教程 - 蝴蝶教程\n[4] MYBATIS 教程 - 奇客谷教程 💯\n[5] MyBatis中文网\n","tags":["Java","MyBatis"]},{"title":"Spring","url":"/2023/01/11/WebBackend/Java/Spring%E7%A0%94%E7%A9%B6/","content":"Preface当我第一次接触Spring框架时，我的导师(项目经理)以迅雷不及掩耳之势，在短短三天内讲完了整个Spring框架。尽管当时我对很多概念还有疑问，但我决定将我的学习过程记录下来，这就是这篇研究Spring框架的笔记。这篇文章于2023年1月11日开始编写。快过年了我可以摸几天鱼吗…\nSynopsisSpring是最受欢迎的企业级Java应用程序开发框架。它是一个开源的Java平台，轻量级且灵活，可以用于开发各种类型的Java应用程序。其中最常用的是基于Spring MVC构建Web应用程序。Spring框架的目标是使J2EE(企业版)开发变得更容易使用，通过启用基于POJO编程模型来促进良好的编程实践。\n\nPOJO 是 Plain Old Java Object 的缩写，意思是“纯粹的旧Java对象”。在Java中，POJO指的是没有任何特殊要求的Java类，也就是没有任何继承自特定父类或实现特定接口的类。\nSpring框架采用了POJO编程模型，它提供了一种简洁而直观的方式来管理应用程序对象之间的关系。使用POJO编程模型，开发人员可以将业务逻辑与框架相分离，使得应用程序更易于理解和维护。\n\n两大核心IoC和DIIoC：控制反转（Inversion of Control，IoC）是指将对象的实例化和管理的权限（反转）交给容器。即对象不在负责创建和管理自己的依赖，而是将这些工作委托给容器来完成。\nDI：依赖注入（Dependency Injection，DI）是一种从容器角度管理对象依赖关系的方式。容器自动将对象依赖的其他对象注入。例如：对象A在实例化过程中声明了一个B类型的属性，容器会在运行时自动将B对象注入到A中。\n区别：IoC和DI形成了类似”嵌套”的关系，其中IoC是一个更宽泛的概念，而DI是一种实现IoC的具体方式。IoC是一种范式，而DI是一种实现IOC的技术。简单来说，IoC是一个思想，而DI是一种实现IoC的具体方式。\n何为反转：如果对反转控制的概念还有疑惑，没关系。我们来举个例子。在传统的Java SE程序设计中，我们通常会直接在对象内使用new关键字创建对象，这是程序主动去创建依赖对象。而IoC则使用一个专门的容器来创建这些对象，容器控制了对象的创建，并主要控制了外部资源的获取。这种方式被称为反转，因为它与传统的程序设计相反。在传统方式中，我们自己在对象中主动控制直接获取依赖对象，这就是正转。而在IoC中，容器帮助创建和注入依赖对象，对象只是被动接受依赖对象，依赖对象的获取被反转了\n\nSpring是一种IoC容器：它使用依赖注入（DI）的方式管理对象之间的依赖关系，使得对象之间松耦合，方便管理。\nAOP概述：面向切面编程（Aspect-Oriented Programming，AOP）是一种编程思想，在不修改源代码的情况下，通过切面来统一管理公用行为。它可以将程序中与业务无关的功能，比如日志记录、性能监控、事务处理等抽离出来，通过配置或代码的方式组合到业务逻辑中。这样做有助于提高代码的可重用性和可维护性，同时提高开发效率。AOP在Spring框架中是一个重要的内容。\nAOP和OOP：AOP是OOP（Object-Oriented Programming）的延续。AOP主要用于解决OOP重复代码和横切关注点的问题。\n\nSpring 体系结构Spring框架是一个非常强大的框架，它提供了各种各样的功能和模块。在实际的应用开发中，我们并不需要使用所有的功能和模块，而是可以根据需要，选择适合自己项目的Spring模块进行使用。\n\nConclusionReferences[1] SPRING TUTORIAL spring-tutoria\n[2] Spring框架两大核心特征的基本理解_sandyLL0224的博客-CSDN博客_spring框架两大特性\n[3] IOC是什么意思！？- 动力节点在线\n[4] 浅谈IOC–说清楚IOC是什么\n[5] Aspect Oriented Programing - Introduction\n[6] Chapter 8. AspectJ weaving models - AspectJ in Action, Second Edition\n[7] Java Proxy和CGLIB动态代理原理 - CarpenterLee - 博客园\n[8] 來談談 AOP (Aspect-Oriented Programming) 的精神與各種主流實現模式的差異\n[9] What are the differences between Spring IOC and Spring MVC? - Quora\n[10] Spring IOC 原理深层解析-技术圈\n","categories":["WEBbackend"],"tags":["Java","Spring"]},{"title":"String、StringBuffer和StringBuilder","url":"/2022/11/30/WebBackend/Java/String%E3%80%81StringBuffer%E5%92%8CStringBuilder/","content":"String 是 Java 中基础且重要的类，被声明为 final class，是不可变字符串。\n所以如果要频繁操作一个字符串会使其性能降低，所以使用StringBuffer和StringBuilder “字符串缓冲区”；\n\n线程安全：StringBuffer：线程安全StringBuilder：线程不安全\n速度：一般情况下，速度从快到慢为 StringBuilder &gt; StringBuffer &gt; String，当然这是相对的，不是绝对的。\n使用环境：操作少量的数据使用 String。单线程操作大量数据使用 StringBuilder。多线程操作大量数据使用 StringBuffer。\n","categories":["WEBbackend"],"tags":["Java"]},{"title":"OkHttp WebSocket","url":"/2023/04/21/WebBackend/Java/OkHttp3/","content":"WebSocketWebSocket是一种网络传输协议，可在单个TCP连接上进行全双工通信，位于OSI模型的应用层。WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就可以创建持久性的连接，并进行双向数据传输123\n扩展阅读\nSpring Boot教程(15) – 使用WebSocket\n\n","categories":["WebBackend/Java"],"tags":["Java","Spring","Http"]},{"title":"Servlet","url":"/2023/01/10/WebBackend/Java/Servlet/","content":"简述\nServlet是一种基于组件的技术，它可以在多种Web服务器上运行，并且独立于平台。\nServlet可以访问整个Java API系列，包括JDBC用于访问企业数据库。\nServlet可以通过表单从用户那里收集输入，显示来自数据库或其他来源的记录，并动态创建网页。\nServlet通常认为是CGI程序的高效替代品。Servlet相比CGI有很多种优点，如更高的性能。\nServlet 是平台无关的，因为它们是用 Java 编写的。\nJava安全管理器强制执行限制以保护服务器资源，可以使用Java类库全部功能（依赖于容器和服务器支持的功能）。\nServlet需要运行在Servlet容器（如 Tomcat）上，然后才能在Web服务器上工作。\n\n\n环境Java Servlet是由支持Java Servlet规范的解释器（通常是Web容器）在服务器端运行的Java类。这些类可以使用 javax.servlet 和 javax.servlet.http包中的类来创建，这些包是Java企业版标准部分，可以支持大型开发项目。\nServlet的创建和编译基本上就像其他Java类一样，需要将Servlet包安装并添加到类路径中，然后可以使用JDK的Java编译器或其他编译器来编译Servlet。\n但是一般会使用一些构建工具来管理依赖，打包和发布项目。这样可以更加便捷的管理项目，常见构建工具有：Apache Maven、Gradle、Apache Ant\n本次使用环境：\n\nJava开发工具包（SDK）\nWeb服务器 - Tomcat\n\n应用\n处理和相应HTTP请求：Servlet通过实现HTTP协议相关的方法来响应客户端的请求，如get或post。\n维护状态信息：Servlet可以在会话期间维护状态信息，这在跨请求的操作中很有用，例如在网上购物车中存储物品。\n数据库交互：Servlet通过JDBC或其他数据库访问技术来访问数据库并执行查询和更新操作。\n生成动态内容：Servlet可以根据请求内容动态生成HTML、XML或其他格式的文档。\n访问远程组件：Servlet可以通过RMI或SOAP等协议访问远程组件。\n\n生命周期Servlet的生命周期可以定义为从创建到销毁的整个过程。在这个过程中，Servlet容器会调用Servlet的三个生命周期方法：init()、service()和destroy()。\ninit()Servlet的生命周期中有一个可选的方法叫做init(),它通常在Servlet第一次被请求时被调用一次。它可以用于进行一些初始化工作，如加载配置文件、建立数据库连接等。\n常见init()方法:\npublic void init() throws ServletException &#123;    // initialization code&#125;\n\n\n\n带ServletConfig 参数的init()方法:\npublic void init(ServletConfig config) throws ServletException &#123;    // initialization code&#125;\n\n\n\nservice()Servlet的生命周期中service()方法是执行实际任务的主要方法。当客户端（浏览器）发送请求到Servlet时，Servlet容器（即Web服务器）会生成一个新线程并调用service()方法来处理请求。\npublic void service(ServletRequest request, ServletResponse response) throws ServletException, IOException &#123;   // Service Code&#125;\n\ndoGet()public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;   // Servlet code&#125;\n\ndoPost()public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;   // Servlet code&#125;\n\n\n\ndestroy()Servlet生命周期结束时会调用一次destroy()方法。它可以进行关闭数据库连接、停止后台线程等。\npublic void destroy() &#123;   // Finalization code...&#125;\n\n\n\n参考学习Servlet - 教程\nServlet入门 - 廖雪峰的官方网站\n","categories":["WEBbackend"],"tags":["Java"]},{"title":"执行流程","url":"/2023/04/18/WebBackend/Java/%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/","content":"Web前端历史Web1.0时代在web1.0时代，没有前后端之分。页面由 JSP、PHP 等工程师在服务端生成，浏览器负责展现。基本上是服务端给什么浏览器就展现什么，展现的控制在 Web Server 层。\n\n这种架构的好处就是简单快捷。但是，缺点也非常明显：JSP代码难以维护\n为了让开发更加便捷，代码更易维护，前后端职责更清晰。便衍生出MVC开发模式和框架，前端展示以模板的形式出现。典型的框架就是Spring，Suructs、Hibernate。整体框架如图所示：\n\n使用这种分层架构，职责清晰，代码易于维护。但这里的MVC仅限于后端，前后端形成了一定的分离，前端只完成了后端开发的view层\nWeb2.0时代自从Gmail的出现，ajax技术开始风靡全球。有了ajax之后，前后端的职责就更加清晰了。因为前端可以通过Ajax与后端进行数据交互，因此，整体的架构图也变化成了下面这幅图：\n\nAjax 技术与后台服务器进行数据交换，可以使得前端开发人员只需要专注于页面内容的开发，数据可以由后台提供，从而分工更加明确，提高了开发效率。而且，使用 Ajax 技术可以实现页面的部分刷新，减少了服务器端负载和流量消耗，用户体验更佳。\n前后端分离后的架构演变-MVC、MVP和MVVMMVC前端的MVC与后端类似，具备View、Controller和Model。\nModel：负责保存应用数据，与后端数据进行同步\nController：负责业务逻辑，根据用户行为对Model数据进行修改\nView：负责视图展示，将model中的数据可视化出来\n三者形成了一个如图所示的模型：\n\n这样的模型，在理论上是可行的。但往往在实际开发中，并不会这样操作。因为开发过程并不灵活。例如，一个小小的事件操作，都必须经历这样的一个流程，那么开发就不再便捷了。\n在实际场景中，我们往往会看到另一种模式，如图：\n\n这种模式在开发中更加灵活，backbone.js框架就是这种的模式。\n但是，这种灵活可能导致严重的问题：\n1.数据流混乱：\n\n2.View比庞大，而Controller比较单薄：由于很多开发者就会在view中写一些逻辑代码，逐渐的就导致了view中的内容越来越庞大，而controller变得越来越单薄。\nMVPMVP模式虽然在前端开发并不常见，但是在安卓等原生开发中，开发者还是考虑到它\nMVP模式与MVC唯一不同的在于Presenter和Controller\n再MVC模式中我们使用观察者模式，来实现当Model层数据发生变化的时候，通知View层的更新，\n这样View和Model层耦合在一起，当项目逻辑变得复杂的时候，会造成代码的混乱\nMVP的模式通过使用Presenter来实现对View层和Model层的解耦。\nMVC中的Controller只知道Model的接口，因此它没有办法控制View层的更新，MVP模式中View层的接口暴露给了Presenter，因此我们可以在Presenter中将Model的变化和View的变化绑定在一起，以此来实现View和Model的同步更新，这就实现了对View和Model的解耦，Presenter还包含了其他的响应逻辑。\nMVP与MVC很接近，P指的是Presenter，presenter可以理解为一个中间人，它负责着View和Model之间的数据流动，防止View和Model之间直接交流。我们可以看一下图示：\n\n我们可以通过看到，presenter负责和Model进行双向交互，还和View进行双向交互。这种交互方式，相对于MVC来说少了一些灵活，view变成了被动视图，并且本身变得很小。虽然它分离了View和Model。但是应用逐渐变大之后，缺陷也会随之暴露。\n缺陷：\n由于大部分逻辑都需要presenter去进行管理，从而导致presenter的体积增大，难以维护。如果需要去解决这个问题，或许可以从MVVM的思想中找到答案。\nMVVM首先，何为MVVM呢？MVVM可以分解成(Model-View-VIewModel)。ViewModel可以理解为在presenter基础上的进阶版。废话不多说，先上图例：\n\n\n在这里View是ViewModel的外在显示，和ViewModel的数据是同步的。一旦View中的数据发生变化，会自动同步到ViewModel，然后ViewModel可以将变化的数据传给Model；反过来也是一样的，Model中的数据一旦发生改变，就会将值传给ViewModel，而ViewModel也会同步更新到view中。现在的框架实现这样的形式，各有各的不同。主要的三个框架angular2、vue、react都是实现了这样子的模式。\n这种的好处就是View和Model之间被分离开来。view不知道model的存在，viewmodel和model也觉察不到view。事实上，model也完全忽略viewmodel和view的存在。这是一个非常松散耦合的设计。\n但它也不是所用地方都适用的，例如，后端开发是适用的。因为网络资源成本过高，开发成本过高导致的。\n\nMVVM模式中的VM，指的是ViewModel，它和MVP的思想其实是相同的，不过它通过双向的数据绑定，将View和Model的同步更新给自动化了。当Model发生变化的时候，ViewModel就会自动更新，这样就将Presenter中的工作给自动化了\nMVVM执行流程MVVM 是一种基于前端的架构模式，它的执行流程如下：\n\n视图层 (View)：MVVM 模式的视图层通常由 HTML 和 CSS 组成，它负责用户界面的呈现和交互。在 Vue.js 中，视图层使用模板语法来描述 UI。\n模型层 (Model)：模型层是应用程序的数据模型，它负责处理数据的读写操作。在 Vue.js 中，模型层由 Vue 实例的数据属性组成。\n视图模型层 (ViewModel)：视图模型层是连接视图层和模型层的桥梁，它负责将模型层中的数据和方法绑定到视图层上。在 Vue.js 中，视图模型层由 Vue 实例的计算属性、方法和指令组成。\n数据绑定：MVVM 模式使用双向数据绑定机制，实现视图层和模型层之间的数据同步。当模型层数据发生变化时，视图层会自动更新，反之亦然。\n事件监听：视图层通常会触发各种事件，例如点击按钮、输入文本等。在 Vue.js 中，可以使用指令和事件监听器来处理这些事件，例如 v-on:click。\n视图更新：当模型层数据发生变化或用户事件触发时，视图模型层会自动更新视图层，反映最新的数据状态。\n\n总的来说，MVVM 模式的执行流程是：视图层通过指令和事件监听器与视图模型层进行交互，视图模型层通过计算属性、方法和指令将模型层的数据和方法绑定到视图层上，实现视图层和模型层之间的双向数据绑定和自动更新。这种模式能够提高应用程序的可维护性和可测试性，同时也可以减少开发人员的工作量，提高开发效率。\n后端架构B&#x2F;S架构、C&#x2F;S架构SSM框架（Spring + SpringMVC + MyBatis）中的Spring MVC是基于MVC设计模式的实现。因此，SSM框架可以看作是一种基于MVC设计模式的WEB应用程序开发的框架\n三层架构三层架构(3-tier architecture)基于**”高内聚低耦合”**设计思想。三层架构我们都听说过，要想知道SSN工作流程就必须知道三层架构，下面我来给它们一步一步分块解析。\n关于三层架构我不得不吐槽它们的大名：\n\n**表示层(UI、Presentation layer)**、视图层(View layer)、表现层、用户界面层、前端层、Web层等\n**业务逻辑层(BLL、Business Logic layer)**、应用层(Application)、服务层(Service layer)等\n**数据访问层(DAL、Data Access layer)**、数据持久层(Persistence layer)、DAO层(Data Access Object layer)等\n\n\n现在，它们的名字和之间的关系我们大概理解了。三层架构有表示层\n关于上述三个主要层次，还有一些相关的层次和模块：\n\n应用服务层（Application Service layer）：用于提供面向应用的服务接口。\n业务服务层（Business Service layer）：用于提供面向业务的服务接口。\n领域层（Domain layer）：用于定义业务领域对象和业务规则。\n数据库访问层（Database Access layer）：用于实现与数据库的交互。\n数据访问对象层（Data Access Object layer）：用于封装数据访问操作。\n模型层（Model layer）：实体类层、用于表示业务对象和业务规则。\n\nMVC架构工作流程\n\n用户发起 request 请求，请求被控制器（Controller）接收，并将用户请求的数据委托给模型（Model）进行处理。\n控制器通过模型处理数据，并得到处理结果。模型通常指业务逻辑。\n模型处理结果返回给控制器。\n控制器将模型数据传递给视图（View），视图通过控制器进行数据展示。在 Web 中，模型无法将数据直接在视图上显示，需要通过视图和控制器完成。如果在 C&#x2F;S 应用中，模型可以将数据在视图中展示。\n控制器将视图响应（response）给用户，通过视图展示给用户所需的数据或处理结果。\n\nView和Mode应用了观察者模式，当Model层发生改变的时候。它会通知有关View层更新页面\ncontroller层是View层和Model层的纽带，主要负责用户与应用的响应操作，它主要负责用户与应用程序的响应操作，当用户与页面发生交互的时候，Controller中的事件触发器就开始工作了，通过调用Model层，来完成对Model的修改，然后Model层再去通知View层更新。\n\n总结：\nMVC（Model-View-Controller）是一种常见的软件架构模式，它把应用程序分为三个核心组件：模型、视图和控制器，用于更好地组织代码、降低耦合度、提高可维护性。\nMVC 的工作流程如下：\n\n用户与视图交互，触发事件。\n视图将事件发送给控制器。\n控制器接收事件并进行处理，可能需要从模型中获取数据或者调用模型的方法进行业务逻辑处理。\n控制器将处理结果返回给视图。\n视图根据控制器返回的结果更新界面。\n\n具体来说，MVC 的三个组件的作用如下：\n\n模型（Model）：模型表示应用程序的数据和业务逻辑，负责对数据进行处理、存储和检索。它提供了数据接口，供控制器和视图使用。\n视图（View）：视图表示应用程序的用户界面，负责展示数据、接收用户输入、响应用户操作。它是用户与应用程序交互的窗口，可以是一个页面、一个组件或者一个控件。\n控制器（Controller）：控制器是模型和视图之间的中介，负责接收用户输入、处理业务逻辑、更新模型和更新视图。它负责协调和管理视图和模型之间的通信，将用户输入转换为对模型的操作，并将模型的更新通知视图更新界面。\n\n通过这种工作流程，MVC 可以实现代码的分离和解耦，使得代码更加清晰、可维护和可扩展。同时，MVC 的工作流程也提供了一种可重用的设计模式，能够在不同的应用程序中使用。\nSpring MVC工作流程\n\n用户发送请求至前端控制器 DispatcherServlet。\nDispatcherServlet 收到请求调用 HandlerMapping 处理器映射器。\n处理器映射器找到具体的处理器（可以根据 XML 配置、注解进行查找），生成处理器及处理器拦截器（如果有则生成并返回给 DispatcherServlet）。\nDispatcherServlet 调用 HandlerAdapter 处理器适配器。\nHandlerAdapter 经过适配调用具体的处理器（Controller，也叫后端控制器）。\nController 执行完成返回 ModelAndView。\nHandlerAdapter 将 Controller 执行结果 ModelAndView 返回给 DispatcherServlet。\nDispatcherServlet 将 ModelAndView 传给 ViewResolver 视图解析器。\nViewResolver 解析后返回具体 View。\nDispatcherServlet 根据 View 进行渲染视图（即将模型数据填充至视图中）。\nDispatcherServlet 响应用户。\n\nSpring MVC 是基于 MVC 模式的 Web 框架，用于构建 Web 应用程序。Spring MVC 的工作流程如下：\n\n用户发送请求：用户在浏览器中发送请求，请求会被发送到服务器端的 DispatcherServlet。\nDispatcherServlet 接收请求：DispatcherServlet 是 Spring MVC 中的核心组件，用于接收请求并将请求分发到相应的处理器。\n处理器映射器解析请求：处理器映射器（HandlerMapping）用于解析请求并确定请求对应的处理器，它会将请求映射到一个或多个处理器。\n处理器适配器调用处理器：处理器适配器（HandlerAdapter）会调用处理器对请求进行处理，处理器可以是一个控制器（Controller）、一个服务类（Service）或其他组件。\n处理器处理请求：处理器对请求进行处理，并生成相应的模型和视图对象。\n视图解析器解析视图：视图解析器（ViewResolver）用于解析视图，根据处理器返回的视图名称和视图类型确定最终的视图对象。\n视图渲染：视图将模型数据渲染到 HTML、JSON、XML 或其他类型的响应体中。\n响应结果发送给客户端：响应结果被发送回客户端，客户端接收到响应结果并显示在浏览器中。\n\n通过这个工作流程，Spring MVC 可以实现请求的处理、视图的渲染和响应的发送，实现了分离关注点，使得应用程序的开发更加模块化，代码也更加清晰和易于维护。同时，Spring MVC 提供了丰富的扩展点和定制选项，可以方便地满足不同应用程序的需求。\nSSM工作流程\n用户发送请求：用户在浏览器中发送请求，请求会被发送到服务器端的 DispatcherServlet。\nDispatcherServlet 接收请求：DispatcherServlet 是 Spring MVC 中的核心组件，用于接收请求并将请求分发到相应的处理器。\n处理器映射器解析请求：处理器映射器（HandlerMapping）用于解析请求并确定请求对应的处理器，它会将请求映射到一个或多个处理器。\n处理器适配器调用处理器：处理器适配器（HandlerAdapter）会调用处理器对请求进行处理，处理器可以是一个控制器（Controller）、一个服务类（Service）或其他组件。\n处理器处理请求：处理器对请求进行处理，可以通过调用服务类等方式获取业务数据并进行处理，生成相应的模型和视图对象。\nMyBatis 数据访问：MyBatis 是一个 ORM 框架，它可以将 Java 对象映射到数据库表中，使得开发人员可以通过对象的方式访问数据库。在 SSM 中，处理器可以通过调用 MyBatis DAO 层的方法来访问数据库，获取数据并进行处理。\n视图解析器解析视图：视图解析器（ViewResolver）用于解析视图，根据处理器返回的视图名称和视图类型确定最终的视图对象。\n视图渲染：视图将模型数据渲染到 HTML、JSON、XML 或其他类型的响应体中。\n响应结果发送给客户端：响应结果被发送回客户端，客户端接收到响应结果并显示在浏览器中。\n\n通过这个工作流程，SSM 框架可以实现请求的处理、数据库访问、视图的渲染和响应的发送，实现了分离关注点，使得应用程序的开发更加模块化，代码也更加清晰和易于维护。同时，SSM 框架提供了丰富的扩展点和定制选项，可以方便地满足不同应用程序的需求。\nVUE工作流程\n创建 Vue 实例：首先，我们需要通过创建 Vue 实例来启动应用程序。Vue 实例是 Vue.js 的核心，它包含了应用程序的数据和方法，以及用于将数据和方法绑定到视图上的指令。\n模板解析：Vue.js 使用基于 HTML 的模板语法，将模板解析成 Virtual DOM 树。\n数据绑定：Vue.js 使用双向数据绑定机制，可以将模型数据和视图保持同步。当模型数据发生变化时，视图会自动更新，反之亦然。\n编译模板：Vue.js 将模板编译成渲染函数，这个函数可以将 Virtual DOM 节点渲染成真正的 DOM 节点，并将模板中的指令转换为对应的 JavaScript 代码。\n渲染视图：Vue.js 使用 Virtual DOM 技术，将模板中的数据和方法渲染到真实的 DOM 上。\n监听事件：Vue.js 使用指令和事件处理器，可以实现用户交互的响应，例如点击按钮、输入文本等操作。\n更新数据：当用户交互或其他事件发生时，Vue.js 会自动更新模型数据，触发重新渲染视图。这个过程中，Vue.js 会根据依赖关系自动进行优化，只更新必要的组件，提高性能。\n\n通过这个工作流程，Vue.js 可以实现高效的视图渲染、双向数据绑定和组件化开发，使得应用程序的开发更加快速和灵活。同时，Vue.js 提供了丰富的插件和组件库，可以方便地扩展和定制应用程序，满足不同应用程序的需求。\n总结\n这三者都是框架模式，它们设计的目标都是为了解决Model和View的耦合问题。\nMVC模式出现较早主要应用在后端，如Spring MVC、ASP.NET MVC等，在前端领域的早期也有应用，如Backbone.js。。它的优点是分层清晰，缺点是数据流混乱，灵活性带来的维护性问题。\nMVP模式在是MVC的进化形式，Presenter作为中间层负责M通信，解决了两者耦合问题，但P层过于臃肿会导致维护问题。\nMWM模式在前端领域有广泛应用，它不仅解决MV耦合问题，还同时解决了维护两者映射关系的大量繁杂代码和DOM操作代码，在提高开发效率、可读性同时还保持了优越的性能表现。\n\nRe ferencesjava进阶之三层架构+MVC - 灰信网\nSpring, 3-Tier-Architecture\nmvc，mvp，mvvm 的区别\nWeb开发的历史发展技术演变-阿里云开发者社区\n前端框架模式的变迁\n","categories":["WebFrontend"],"tags":["Java"]},{"title":"目录结构实例","url":"/2023/04/18/WebBackend/Java/%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E5%AE%9E%E4%BE%8B/","content":"1标准的Java SSM（Spring + Spring MVC + MyBatis）项目：\n- src/main/java  - com.example.project    - controller      // Spring MVC控制器类    - dao             // MyBatis数据访问对象接口    - service         // Spring服务层接口      - impl          // Spring服务层实现类    - model           // 模型类和DTO（数据传输对象）  - resources    - mybatis         // MyBatis配置和映射文件    - spring          // Spring配置文件      - applicationContext.xml     // 应用程序上下文配置文件      - spring-mvc.xml             // Spring MVC配置文件    - log4j.properties // 日志配置文件    - db.properties    // 数据库配置文件  - webapp    - WEB-INF      - views         // 视图文件（JSP、Thymeleaf等）      - web.xml       // Web应用程序配置文件- pom.xml             // Maven项目配置文件\n\n其中，src/main/java目录包含Java源代码，src/main/resources目录包含资源文件，webapp目录包含Web应用程序的资源（例如静态资源、视图文件等）。\n在src/main/java目录中，通常会有controller、dao、service和model四个子目录。其中，controller目录包含Spring MVC控制器类，dao目录包含MyBatis数据访问对象接口，service目录包含Spring服务层接口和实现类，model目录包含模型类和DTO（数据传输对象）。\n在src/main/resources目录中，通常会有mybatis和spring两个子目录。其中，mybatis目录包含MyBatis配置和映射文件，spring目录包含Spring配置文件，如应用程序上下文配置文件、Spring MVC配置文件等。\n最后，webapp目录中包含Web应用程序的资源，例如静态资源和视图文件等，其中WEB-INF目录中通常包含views目录和web.xml配置文件。\n2Spring Boot框架\n- src/main/java  - com.example.project    - controller      // Spring MVC控制器类    - dao             // MyBatis数据访问对象接口    - service         // Spring服务层接口      - impl          // Spring服务层实现类    - model           // 模型类和DTO（数据传输对象）    - Application.java // Spring Boot应用程序入口- src/main/resources  - mybatis           // MyBatis配置和映射文件  - application.yml   // Spring Boot应用程序配置文件  - log4j.properties  // 日志配置文件- src/main/webapp  - WEB-INF    - views           // 视图文件（JSP、Thymeleaf等）- pom.xml             // Maven项目配置文件\n\n其中，src/main/java目录包含Java源代码，src/main/resources目录包含资源文件，src/main/webapp目录包含Web应用程序的资源（例如静态资源、视图文件等）。\n在src/main/java目录中，除了SSM项目中的controller、dao、service和model四个子目录之外，还需要添加一个名为Application.java的入口文件，用于启动Spring Boot应用程序。\n在src/main/resources目录中，除了SSM项目中的mybatis目录、log4j.properties日志配置文件之外，还需要添加一个名为application.yml（或application.properties）的Spring Boot应用程序配置文件。这个文件包含了应用程序的配置，如数据库配置、日志配置、端口配置等。\n在src/main/webapp目录中，与SSM项目相同，需要包含视图文件，但是通常不再使用JSP作为视图技术，而是使用Thymeleaf、FreeMarker等模板引擎。\n最后，pom.xml文件是Maven项目配置文件，包含了项目的依赖和构建信息。\nSpringMVC完整的执行流程：    浏览器发送请求，被DispatcherServlet处理，DispatcherServlet在处理请求时要找到请求对应的请求映射，这时候就分两种情况：存在或不存在，存在就可以找到相对应的请求映射，不存在就会找我们有没有配置默认的servlet（mvc:default-servlet-handler)，如果没有配置，则页面直接404，如果配置了的话，就交给默认的servlet进行处理，访问目标资源（一般为静态资源（js，css，HTML）），找不到也会404。\n若有这个请求映射，就通过HandlerMapping去匹配当前的控制器方法，匹配到控制器方法之后由HandlerAdapter调用执行控制器方法，在执行控制器方法之前，先执行拦截器的preHandler()方法（按照拦截器的顺序执行），然后开始调用执行控制器方法，执行之后调用拦截器的postHandler()方法，postHandler()执行之后，处理ModuleAndView来渲染视图。\n\n渲染视图之后执行拦截器的afterComoletion()方法，最终将结果响应到浏览器。\n","categories":["WebBackend"],"tags":["java","MyBatis","Spring"]},{"title":"npm 包管理器","url":"/2023/04/18/WebFrontend/Node.js/npm%20%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/","content":"包 package\nCommonJS的包规范允许我们将一组相关的模块组合到一起，形成一组完整的工具。\nCommonJS的包规范由包结构和包描述文件两个部分构成。\n包结构：用于组织包中的各种文件\n包描述文件：描述包的相关信息，以供外部读取分析\n\nNPM(Node Package Manager)\nCommonJS包规范是理论，NPM是其中一种实践。\n对于Node而言，NPM帮助其完成了第三方模块的发布、安装和依赖等。借助NPM，Node与第三方模块之间形成了很好的一个生态系统。\n\nNVM安装 (包版本控制工具)第一步下载nvm\n然后配置nvm的安装位置\nroot: D:\\64\\nvmpath: D:\\system64\\nodejsnode_mirror: https://npm.taobao.org/mirrors/node/npm_mirror: https://npm.taobao.org/mirrors/npm/\n\nNPM命令查看npm版本\nnpm -v\n\n查看所有模块的版本\nnpm version\n\n\n\n帮助说明\nnpm\n\n搜索模块包\nnpm search 包名\n\n在当前目录安装包\nnpm install 包名npm i 包名\n\n下载当前项目所依赖的包\nnpm install\n\n\n\n在当前目录安装包并添加到依赖中\nnpm install 包名 --save 安装包并添加到依赖中\n\n删除当前目录包\nnpm remove / r 包名\n\n全局模式安装包\nnpm install 包名 -g\n\n\n\n常用包jQuerypnpm i @rollup/plugin-inject jquery\n\nnpm i --save-dev @types/jquery\n","categories":["WebFrontend"],"tags":["npm"]},{"title":"BOM","url":"/2022/08/15/WebFrontend/JavaScript/BOM/","content":"\nBOM（Browser object Model）：浏览器对象模型\n其实就是操作浏览器的一些能力\n我们可以操作哪些内容\n获取一些浏览器的相关信息（窗口的大小）\n操作浏览器进行页面跳转\n获取当前浏览器地址栏的信息\n浏览器的信息（浏览器的版本）\n让浏览器出现一个弹出框（alert&#x2F;confirm&#x2F;prompt）\n…\n\n\nBOM的核心就是window对象\nwindow是浏览器内置的一个对象，里面包含着操作浏览器的方法\n\n重要事件\nonresize\n宽口大小发生改变的时候触发。\n\nonscroll\n页面滚动的时候触发，也可以用于某个元素节点上。\n\nonfocus onblur\n进入页面和离开页面时触发，也可以用于其他能获得焦点的元素节点上。\n\n打开与关闭窗口\nopen() close()\n\n\n重要对象\nlocation\n获取&#x2F;设置 URL相关的属性。\n\nhistory\n操作当前标签页的历史，类似于点击浏览器地址栏左侧的前进和后退按钮。\nhistory.go(number) – 前进或后退指定的页面数。\nhistory.back() – 后退一页。\nhistory.forward() – 前进一页。\n\nnavigator\n获取浏览器相关的信息。\n\nScreen\n获取用户显示屏幕的各种信息。\n.width .height 获取显示器分辨率。\n.availWidth .availHeight 获取除去任务栏的大小。\n\n\n各种尺寸获取可视区宽高\n窗口宽高\nwindow.innerWidth window.innerHeight\n包含了滚动条的宽度和浏览器本身的边框宽度（低版本IE不支持）。\n\n内容区宽高\ndocument.documentElement.clientWidth\ndocument.documentElement.clientHeight\n不包含滚动条等。\n\n\n元素的各种宽高\nclient\nclientWidth clientHeight\n宽(高)+padding。\n\noffset\noffsetWidth offssetHeight\n宽(高)+padding+border。\n\nscroll\nscrollWidth / scrollHeigh\n内容的实际高度，当内容没超出相当于client，当内容超出之后，会得到包括超出内容的实际高度，即使加了超出隐藏，也还是会得到内容所占的实际高度。\n\n\n元素的各种距离\noffset\noffsetLeft offsetTop\n获取左边（上边），到定位父级的左边（上边）的距离。\n\ngetBoundingClientRect\n返回一个对象，包含了元素各边到窗口的距离，返回的结构类似于：{top:100,left:20,bottom:500,right:890}。\n\n\n滚动距离\n页面滚动宽高\ndoucment.documentElement.scrollTop\ndocument.documentElement.scrollLeft\n页面的滚动宽（高）。此属性可以赋值，能让页面滚动到指定的位置。\n设置滚动距离也可以使用window.scrollTo()。\n\n元素滚动宽高\n元素节点.scrollTop 元素节点.scrollLeft\n\n\n","categories":["WebFrontend"],"tags":["javascript","bom"]},{"title":"DOM与数据交互(学习日志)","url":"/2022/09/26/WebFrontend/JavaScript/DOM%E4%B8%8E%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92(%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97)/","content":"day1-初识domdom是什么DOM就是一个编程接口，就是一套API。\nDOM是针对标记语言（HTML文档、XML等文档）的一套API。\nJS由的三个组成部分\n\nECMAscript (js的语法规范)\nDOM (文档对象模型)\nBOM (浏览器对象模型)\n\n\n注：\n\napi：学习浏览器向我们提供的操作页面和操作浏览器的api\n\nDOM：不是js提供的方法，而是html向js提供的api\nDOM树页面渲染完成以后，所有页面中的内容都会被抽象成一个树形结构\n\n\n\nDOM 基本名词\n\n文档：一个HTML页面就叫做一个文档\n节点：网页中所有内容都是一个节点（标签，元素，文本，注释节点）\n元素：元素中的标签节点\n属性：标签的属性\n\napi分类\n\n节点获取\n节点操作（修改节点内容的api）\n用户交互行为 - 事件\n\n页面中的元素都是有内置的类创建的\nHTMLElement 类 所有html元素的根类\n\nHTMLBodyElement\nHTMLInputElement\n\nconsole.log(document.body.constructor.name) //HTMLBodyElementconsole.log(document.body instanceof HTMLBodyElement) //trueconsole.log(document.body instanceof Element) //trueconsole.log(document.body instanceof Node) //trueconsole.log(document.body instanceof Text) //false//log 和 dir 的区别, log展示元素,dir是以树形结构展示元素console.log(document.body)console.dir(document.body)\n\nDOM 与 HTMLHTML文档是树状结构，根为html；\nDOM Tree也是树状结构，根为window或document对象。\nhtml通过DOM API来解析生成DOM Tree\n\nDOM与其他技术的联系JavaScript 可以通过DOM来访问和操作HTML文档所有的元素。\nJavaScript是一种脚本语言，DOM是用来获得和操作HTML文档的节点属性。\nJavaScript通常是通过DOM来获得和操作HTML属性的。这就是二者的区别与联系。\n&lt;script&gt;function test() &#123;    window.alert(&#x27;成功&#x27;);&#125;&lt;/script&gt;&lt;input type = button value = &#x27;提交&#x27; onClick = &#x27;test()&#x27;/&gt;\n\n第1，2，4，5行是javaScript代码。\n第3行是DOM代码（此行一定不要混淆成是JavaScript代码）。这就是JavaScript调用DOM的例子。\n第6行是html代码。\nDOM的级别Level\nDOM0：不是W3C规范。\nDOM1：开始是W3C规范。专注于HTML文档和XML文档。\nDOM2：对DOM1增加了样式表对象模型\nDOM3：对DOM2增加了内容模型 (DTD 、Schemas) 和文档验证。\n\n\nDOM节点类型DOM（文档对象模型）是针对 HTML和 XML文档的一个API（应用程序编程接口）。\nDOM描绘了一个层次化的节点树，允许开发人员添加、移除和修改页面的某一部分。\nDOM将整个页面映射为一个由层次节点组成的文件。有1级、2级、3级共三个级别。\n节点分类\ndom一级有一个Node类,这个类里面存储了所有节点类型\nNode类中有个方法叫nodeType 专门用于检测节点的类型，返回时一个数值:\n\ndocument - dom的入口节点 9\n元素节点 - html标签 1\n文本节点 - 页面中的文字 3\n注释节点 - 注释节点 8\n\nlet ele = document.body //获取到body标签console.log(ele.nodeType) //1元素节点let son = ele.firstChildconsole.log(son.nodeType) //8注释节点//nodeName(所有节点都能访问的属性) 和 tagName (元素节点独有的属性)console.log(ele.nodeName) //节点名称 BODYconsole.log(ele.tagName)  //节点名称 BODYconsole.log(son.tagName) //undefinedconsole.log(som.nodeName) //#comment\n\n获取节点获取元素的节点\nEs5获取元素的api：\ngetElementById(str) //str是元素的id名getElementById(str) //str是元素的id名getElementsByTagName(str) //str是元素的标签名称\n\n\n\nH5获取元素的方式:\nquerySelector(str) 获取满足str选择器的单个元素querySelectorAll(str) 获取满足str选择器的所有元素\n\n\n\n通过id名获取 通过id名获取满足条件的第一个元素：\nlet oApp = document.getElementById(&#x27;app&#x27;)\n\n\n\n通过class名获取，获取到的是一个类数组，保存的是满足条件的所有元素：\nlet aFirst = document.getElementsByClassName(&#x27;first&#x27;)\n\n\n\n通过标签名获取元素：\nlet aP = document.getElementsByTagName(&#x27;p&#x27;)\n\n\n\nH5的方式获取元素：\nlet p = &#x27;p&#x27;\n\n获取单个元素\nlet oP = document.querySelector(p)let oP = document.querySelector(&#x27;p.first&#x27;)let oP = document.querySelector(&#x27;p[class=&quot;first&quot;]&#x27;)\n\n获取多个元素\nlet aPP = document.querySelectorAll(&#x27;p&#x27;)\n\n\n\n特殊标签获取：\nlet html = document.documentElementlet body = document.bodylet head = document.headet title = document.title //获取到网页的标题document.title = &#x27;123&#x27; //修改标签\n\n\n\nget系列获取标签和query系列获取标签的区别：\nget系列获取到的所有的节点都是动态节点（实时集合），当页面节点更新的时候get元素也会动态更新。\nquery系列获取到的是一个静态集合，不会实时更新。\n获取节点属性元素的属性和特性：\n\n属性：指的就是在节点下存储的键值对。\n特性：指的就是获取到元素，元素本身自带（合法标签属性）的标签属性的描述。\n\nlet oImg = document.querySelector(&#x27;img&#x27;)let oDiv = document.querySelector(&#x27;div&#x27;)\n\n把节点对象当普通对象使用\n//&lt;img src=&quot;https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fc-ssl.duitang.com%2Fuploads%2Fblog%2F202105%2F09%2F20210509225323_2c0c6.thumb.1000_0.jpeg&amp;refer=http%3A%2F%2Fc-ssl.duitang.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1664979662&amp;t=f772af80870fbc53ff44e52ce83ba3cc&quot; alt=&quot;我要睡觉了&quot; title=&quot;睡觉.png&quot; id=&quot;img&quot; class=&quot;sleep&quot; is-ok=&quot;false&quot; width=&quot;300&quot;&gt;//&lt;div id=&quot;div&quot; width=&quot;123&quot;&gt;123&lt;/div&gt;oImg.xixi = &#x27;xixixixi&#x27;oImg.sayName = function()&#123;      alert(this.tagName)    &#125;oImg.isDown = trueconsole.dir(oImg.xixi)// oImg.sayName()console.log(oImg.width)console.log(oImg.src)//无法获取自定义的标签属性console.log(oDiv.width) //undefinedconsole.log(oDiv.width) //undefined//class名的获取console.log(oImg.className) //获取class名称\n\n","categories":["WebFrontend"],"tags":["javascript","dom"]},{"title":"DOM","url":"/2022/08/21/WebFrontend/JavaScript/DOM/","content":"初识DOM\nDOM（Document Object Model）文档对象模型，是W3C组织推荐的处理可扩展置标语言的标准编程接口。\n\n获取节点DOM为我们提供了一个全局内置对象document，要操作HTML标签，我们可以调用document对象中的各种方法来获取页面中的标签（在js中我们可以称之为 元素 或者 节点）：\n\n通过ID获取\neg：document.getElementById(&quot;ID&quot;)\n\n通过name获取\neg:  document.getElementsByName(&quot;Name&quot;)\n\n通过选择器获取\neg：document.querySelector(&quot;#main .nav&quot;)\neg：document.querySelectorAll(#banner li)\n\n通过class名获取\neg：document.getElementsByClassName(&quot;className&quot;)\n\n通过标签名获取\neg：document.getElementsByTagName(&quot;tagName&quot;)\n\n特殊标签的获取\n获取html标签 document.documentElement\n获取head标签 document.hea\n获取body标签 document.body\n获取title标签 document.title\n\n\n一般情况下，推荐使用 ID获取 或者 选择器获取 ，比较方便。\n操作HTML内容节点.innerHTML 获取&#x2F;修改 元素的HTML内容，\n节点.innerText 获取&#x2F;修改 元素的文本内容（老版本FF不支持这个属性，使用 .textContent 代替）。\n监听事件\n事件种类\n鼠标事件： onclick 左键单击 ondblclick 左键双击 onmouseover onmouseenter 鼠标移入 onmouseout onmouseleave鼠标移出 onmousedown 鼠标按下 onmousmove 鼠标移动 onmouseup 鼠标抬起 oncontextmenu 右键单击\n键盘事件：onkeydown onkeypress 键按下 onkeyup 键抬起\n系统事件： onload 加载完成后 onerror 加载出错后 onresize 窗口调整大小时 onscroll 滚动时\n表单事件： onfocus 获取焦点后 onblur 失去焦点后 onchange 改变内容后 onreset 重置后 onselect 选择后 onsubmit 提交后\n\n监听事件写法\n节点.事件 = 函数。\neg：document.getElementById(&quot;main&quot;).onclick = function()&#123;alert(1)&#125;;\n这里的函数称之为 事件函数，事件函数不会自执行，而是当事件触发时执行。\n\n事件函数this指向\n在事件函数中，关键词 this 就表示触发事件的这个节点对象。\n\n\n操作节点的标签属性\n合法标签属性\n直接使用 节点.属性 的方式。eg：console.log(节点.id); 节点.title = &quot;新的title&quot;。\nclass名字不能 .class ，而是使用 .className 代替。\n\n自定义的标签属性\n不能直接使用 . 操作。\n设置setAttribute 获取getAttribute 移除removeAttribute 。\n\n\n操作样式\n修改样式\n元素样式由css控制，JavaScript想要改变元素的样式，那么就相当于要改变css。\n元素css样式的书写位置有三种：外部样式表、内部样式表、行内样式。js来操作样式时，本质上就相当于要操作这三种位置的css。\n\n外部样式表 ：前端的 js 不能修改一个外部的文件，所以无法通过直接修改外部样式来改变元素。\n内部样式表：内部样式放置到style标签中，而style又在当前页面中，所以能够被js控制。但是操作来比较麻烦，所以不推荐。\n行内样式：直接写在标签中，并且优先级最高。js操作样式的最常用方式。\n\n节点.style.属性 来控制单个的行内样式。\n节点.style.cssText 来控制节点的所有行内样式。\n当单个标签操作的样式比较多时，使用 改变class来改变样式 的形式会方便很多。\n\n获取样式\n.style 只能获取行内样式，要获取元素的最终显示样式使用 getComputedStyle(节点)。\n\n\n类名的操作使用 .className 可以来操作标签的类名，但是需要新加一个类名，或者去掉某个类名时，使用.className较为麻烦。所以推荐使用新API.classList 来操作类名。\n添加：节点.classList.add(&quot;类名&quot;)\n移除：节点.classList.remove(&quot;类名&quot;)\n切换（有则删，无则加）：节点.classList.toggle(&quot;类名&quot;)\n是否有某个类名（得到布尔值）：节点.classList.contain(&quot;类名&quot;)\nDOM节点\nDOM 的节点我们一般分为常用的三大类 元素节点&#x2F;文本节点&#x2F;属性节点\n什么是分类，比如我们在获取元素的时候，通过各种方法获取到的我们叫做元素节点（标签节点）\n比如我们标签里面写的文字，那么就是文本节点\n写在每一个标签上的属性，就是属性节点\n\n\n\n\n节点类型\nchildNodes\n获取一个元素的所有子节点……\n\n节点类型\nDOM包含了多种节点，我们通常获取的标签，只是节点中的一种：\n\n\n\n\n\n节点名称\nnodeType\n\n\n\n元素节点\n1\n\n\n属性节点\n2\n\n\n文本节点\n3\n\n\nCDATA节点\n4\n\n\n实体引用名称节点\n5\n\n\n实体名称节点\n6\n\n\n处理指令节点\n7\n\n\n注释节点\n8\n\n\n文档节点\n9\n\n\n文档类型节点\n10\n\n\n文档片段节点\n11\n\n\nDTD声明节点\n12\n\n\n重点理解前三种节点。\n每个节点有nodeName属性，文本节点和属性节点的nodeValue属性。\n\n常见的节点获取API\n常用：children parentNode offsetParent\n不常用：firstElementChild &#x2F; firstChild lastElementChild &#x2F; lastChild nextElementSibling &#x2F; nextSibling previousElementSibling &#x2F; previouSibling\n\n\n创建、添加、删除节点\n创建节点\ncreateElement 创建一个元素节点；\ncreateTextNode 创建一个文本节点；\ncreateDocumentFragment 创建一个文档碎片，先将多个节点整合到这里面再统一添加。\n\n添加节点\nappendChild 元素最后添加一个子节点；\ninsertBefore 在元素某个子节点之前添加新子节点，第一个参数为新节点，第二个参数为已存在的子节点。\n\n替换节点\nreplaceChild 用新节点替换某个子节点，第一个参数为新节点，第二个参数为已存在的某个子节点。\n\n删除节点\nremoveChild 删除元素的某个子节点。\n\n\n","categories":["WebFrontend"],"tags":["javascript","dom"]},{"title":"JS 正则表达式","url":"/2022/10/17/WebFrontend/JavaScript/JS%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","content":"正则表达式正则表达式（regular expression）是一个描述字符模式的对象。JavaScript的RegExp类表示正则表达式。\n创建正则表达式的对象构造函数创建：\nvar 变量 = new RegExp(&quot;正则表达式&quot;,&quot;匹配模式&quot;);\n\n\n\n字面量方式创建：\nvar 变量 = /正则表达式/匹配模式;\n\n\n\n\n匹配模式参数:\n参数：i 忽略大小写g 全局匹配模式m 执行多行匹配\n\nvar reg = new RegExp(&quot;a&quot;); //匹配任何含有“a”的字符串var reg = new RegExp(&quot;a$&quot;); //匹配任何以“a”结束的字符串var reg = new RegExp(&quot;a&quot;,&quot;i&quot;); //匹配任何含有“a”的字符串并不区分大小写var reg = /a/i; //匹配任何含有“a”的字符串并不区分大小写（字面量方式创建）\n\n\n\n直接量字符JavaScript正则表达式语法也支持非字母的字符匹配，这些字符需要通过反斜线（\\）作为前缀进行转义。\n\n\n\n字符、字母和数字字符\n匹配自身\n\n\n\n\\o\nNUL字符（\\u0000）\n\n\n\\t\n制表符 (\\u0009)\n\n\n\\n\n换行符（\\u000A）\n\n\n\\v\n垂直制表符（\\u000B）\n\n\n\\f\n换页符（\\u000C）\n\n\n\\r\n回车符（\\u000D）\n\n\n\\xnn\n由十六进制数nn指定的拉丁字符，例如: \\x0A 等价于 \\n\n\n\n\\uxxxx\n由十六进制数xxxx指定的Unicode字符，例如：\\u0009 等价于 \\t\n\n\n\\cX\n控制字符^X，例如：\\cJ等价于换行符\\n\n\n\n\n注：在正则表示中，许多标点符号具有特殊含义，它们是：\n^ $ . * + ? &#x3D; ! : | \\ &#x2F; ( ) [ ] { }\n\n字符类正则表达式的字符类：\n\n\n\n元字符\n匹配\n\n\n\n[…]\n方括号内的任意字符\n\n\n[^…]\n不在方括号内的任意字符\n\n\n.\n除换行符和其他Unicode行终止符之外的任意字符\n\n\n\\w\n任何ASCII字符组成的单词，等价于[a-zA-Z0-9]\n\n\n\\W\n任何不是ASCII字符组成的单词，等价于[a-zA-Z0-9]\n\n\n\\s\n任何Unicode空白符\n\n\n\\S\n任何非Unicode空白符的字符\n\n\n\\d\n任何ASCII数字，等价于[0-9]\n\n\n\\D\n除了ASCII数字之外的任何字符，等价于[^0-9]\n\n\n[\\b]\n退格直接量（特例）\n\n\n例子：\nvar reg = /[abc]/; //匹配任意含有字母“a”、“b”、“c”的字符串var reg = /[^abc]/; //匹配任意不含有字母“a”、“b”、“c”的字符串var reg = /[a-z]/; //匹配拉丁字母表中的小写字母var reg = /[a-zA-Z0-9]/; //匹配拉丁字母表中任何字母和数字var reg = /[\\s\\d]/;\t//匹配任意空白符或者数字var reg = /[\\b]/; //匹配退格符\n\n\n\n量词&#x2F;重复量词也称重复。掌握&#123;m,n&#125;的准确含义后，只需要记住一些简写形式。\n由于某些重复种类非常常用，因此就有一些专门用于表示这种情况的特殊字符。\n\n\n\n字符\n含义\n\n\n\n{n,m}\n匹配n-m次，优先匹配m次\n\n\n{n,}\n匹配n-∞次，优先匹配∞次\n\n\n{n}\n匹配n次\n\n\n?\n匹配0次或1次，优先匹配1次，等价于{0,1}\n\n\n+\n匹配1-n次，优先匹配n次，等价于{1,}\n\n\n*\n匹配0-n次，优先匹配n次，等价于{0,}\n\n\n例子：\nvar reg = /\\d&#123;2,4&#125;/;  //匹配2~4个数字var reg = /\\w&#123;3&#125;\\d?/;  //精确匹配三个单词和一个可选的数字var reg = /\\s+java\\s+/; //匹配前后带有一个或多个空格的字符串“java”var reg = /[^(]*/\t//匹配一个或多个非左括号的字符\n\n\n 注：在使用 “*” 和 “?” 时要注意，由于这些字符可能匹配0个字符，因为它们允许什么都不匹配。例如，正则表达式/a*/实际上与字符串”bbbb”匹配，因为这个字符串含有0个a\n\n贪婪模式&#x2F;惰性模式贪婪模式——在匹配成功的前提下，尽可能多的去匹配\n惰性模式——在匹配成功的前提下，尽可能少的去匹配\n\n\n\n{n,m}?\n尽量匹配n次，但不能超过m次\n\n\n\n{n}?\n尽量匹配n次\n\n\n{n,}?\n尽量匹配n次或者更多次\n\n\n??\n尽量匹配，满足限定条件也可能最多匹配1次，相当于 {0,1}?\n\n\n+?\n尽量匹配1次，但是为了满足限定条件也可能匹配任意次，相当于 {1,}?\n\n\n*?\n尽量不匹配，但是为了满足限定条件也可能匹配任意次，相当于 {0,}?\n\n\n使用字符串方法在 JavaScript 中，正则表达式常用于两个字符串方法：search() 和 replace()。\nsearch() 方法使用表达式来搜索匹配，然后返回匹配的位置。\nconst regex = /\\d&#123;2&#125;a/;const str = &quot;Hello54 How 64aare you&quot;;console.log(str.split(regex)) // [&quot;Hello54 How &quot;, &quot;are you&quot;]\n\n\n\nreplace() 方法返回模式被替换处修改后的字符串。\nconst str = &#x27;JavaScript&#x27;;const newStr = str.replace(&quot;ava&quot;, &quot;-&quot;);console.log(newStr);// J-Script\n\n\n\ntext()使用这个方法可以用来检查一个字符串是否符合正则表达式的规则，符合返回true，否则返回false\nvar result = reg.test(str);\n\n\n\ntest()字符串匹配到正则表达式时，改方法会提取匹配项\nvar result = reg.match(str);\n\n","categories":["WebFrontend"],"tags":["javascript"]},{"title":"jQuery","url":"/2022/12/27/WebFrontend/JavaScript/jQuery/","content":"初识jQuery什么是jQuery\n一个优秀的JS函数库（封装BOM和DOM）\n使用jQuery的网站超过90%（18年统计）\n中大型WEB项目开发首选\nWrite Less，Do More!!!\n\nJavaScript and jQuery我们知道Javascript以Netscape公司开发的一种脚本语言（scripting language）。Javascript存在3个弊端，即复杂的文档对象模型（DOM），不一致的浏览器实现和缺乏便捷的开发、调试工具。\n正当JavaScript从开发者的视线中渐渐隐去时，一种新型的基于Javascript的Web技术——Ajax（Asynchronous Javascript And XML，异步的Javascript和XML）诞生了，是JavaScript不再是一种仅仅用于制作Web页面的简单脚本。\n为了简化JavaScript的开发，一些JavaScript库诞生了。JavaScript库封装了很多预定义的对象和实用函数。\n这里主要写jQuery库，jQuery同样是一个轻量级的库，拥有强大的选择器，出色的DOM操作，可靠的事件处理、完善的兼容性和链式操作等功能。\njQuery代码的编写jQuery环境配置jQuery不需要安装，把下载的jQuery放到网站上的一个公共的位置，想要在某个页面上使用jQuery时，只需要在相关的HTML文档中引入该库文件的位置即可。\n在页面引入jQuery把jQuery放在目录script下，然后在编写的页面代码中&lt;head&gt;标签内引入jQuery库后，就可以使用jQuery库了，程序如下：\n&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;utf-8&quot;&gt;        &lt;!-- 在head标签内 引入jQuery --&gt;        &lt;script src = &quot;./scripts/jquery-1.10.2.js&quot; type = &quot;text/javascript&quot;&gt;&lt;/script&gt;        &lt;!-- Staticfile CDN引入 --&gt;        &lt;script src=&quot;https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js&quot;&gt;&lt;/script&gt;    &lt;head&gt;\t\t&lt;title&gt;&lt;/title&gt;\t&lt;/head&gt;\t&lt;body&gt;\t&lt;/body&gt;&lt;/html&gt;\n\n编写简单的jQuery代码在jQuery库中，$就是jQuery的一个简写形式，例如$(“#foo”)和jQuery(“#foo”)是等价的，$.ajax和jQuery.ajax是等价的。\n第一个jQuery程序。\n&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;utf-8&quot; /&gt;\t\t&lt;title&gt;&lt;/title&gt;\t\t&lt;script src=&quot;https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js&quot;&gt;&lt;/script&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;script type=&quot;text/javascript&quot;&gt;\t\t\t$(document).ready(function()&#123;\t\t\t\talert(&quot;Hello World!&quot;);\t\t\t&#125;);\t\t&lt;/script&gt;\t&lt;/body&gt;&lt;/html&gt;\n\n\n$(document).ready(function&#123;//...&#125;);\n\n这段代码的作用类似于传统JavaScript中的window.onload方法，但有些区别;\n\njQuery代码风格如果能统一jQuery代码编码风格，对日后代码的维护是非常有利的。\n项目需求是做一个导航栏，点击不同章节名称连接，显示相应的内容，同时高亮显示当前选择的章节\n&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;utf-8&quot; /&gt;\t\t&lt;title&gt;&lt;/title&gt;\t\t&lt;script src=&quot;https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js&quot;&gt;&lt;/script&gt;\t\t&lt;style type=&quot;text/css&quot;&gt;\t\t\t#menu &#123; \t\t\t\twidth: 300px;\t\t\t&#125;\t\t\t.has_children&#123;\t\t\t\tbackground: #555;\t\t\t\tcolor: #fff;\t\t\t\tcursor: pointer;\t\t\t&#125;\t\t\t.highlight&#123;\t\t\t\tcolor: #fff;\t\t\t\tbackground: green;\t\t\t&#125;\t\t\tdiv &#123;\t\t\t\tpadding: 0;\t\t\t\tmargin: 10px 0;\t\t\t&#125;\t\t\tdiv a &#123;\t\t\t\tbackground: #888;\t\t\t\tdisplay: none;\t\t\t\tfloat: left;\t\t\t\twidth: 300px;\t\t\t&#125;\t\t&lt;/style&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;div id=&quot;menu&quot;&gt;\t\t\t&lt;div class=&quot;has_children&quot;&gt;\t\t\t\t&lt;span&gt;第1章-认识jQuery&lt;/span&gt;\t\t\t\t&lt;a&gt;什么是jQuery&lt;/a&gt;\t\t\t\t&lt;a&gt;Javascript and jQuery&lt;/a&gt;\t\t\t\t&lt;a&gt;jQuery代码的编写&lt;/a&gt;\t\t\t\t&lt;a&gt;在页面进入jQuery&lt;/a&gt;\t\t\t\t&lt;a&gt;编写简单的jQuery代码&lt;/a&gt;\t\t\t\t&lt;a&gt;jQuery代码风格&lt;/a&gt;\t\t\t&lt;/div&gt;\t\t\t&lt;div class=&quot;has_children&quot;&gt;\t\t\t\t&lt;span&gt;第1章-认识jQuery&lt;/span&gt;\t\t\t\t&lt;a&gt;什么是jQuery&lt;/a&gt;\t\t\t\t&lt;a&gt;Javascript and jQuery&lt;/a&gt;\t\t\t\t&lt;a&gt;jQuery代码的编写&lt;/a&gt;\t\t\t\t&lt;a&gt;在页面进入jQuery&lt;/a&gt;\t\t\t\t&lt;a&gt;编写简单的jQuery代码&lt;/a&gt;\t\t\t\t&lt;a&gt;jQuery代码风格&lt;/a&gt;\t\t\t&lt;/div&gt;\t\t\t&lt;div class=&quot;has_children&quot;&gt;\t\t\t\t&lt;span&gt;第1章-认识jQuery&lt;/span&gt;\t\t\t\t&lt;a&gt;什么是jQuery&lt;/a&gt;\t\t\t\t&lt;a&gt;Javascript and jQuery&lt;/a&gt;\t\t\t\t&lt;a&gt;jQuery代码的编写&lt;/a&gt;\t\t\t\t&lt;a&gt;在页面进入jQuery&lt;/a&gt;\t\t\t\t&lt;a&gt;编写简单的jQuery代码&lt;/a&gt;\t\t\t\t&lt;a&gt;jQuery代码风格&lt;/a&gt;\t\t\t&lt;/div&gt;\t\t&lt;/div&gt;\t\t&lt;script type=&quot;text/javascript&quot;&gt;\t\t\t$(&quot;.has_children&quot;).click(function()&#123;\t\t\t\t$(this).addClass(&quot;highlight&quot;).children(&quot;a&quot;).show().end().siblings().removeClass(&quot;highlight&quot;).children(&quot;a&quot;).hide();\t\t\t&#125;);\t\t&lt;/script&gt;\t&lt;/body&gt;&lt;/html&gt;\n\n这段代码的作用是，当鼠标单击到class中含有has_children的元素上的时候，给其添加一个名为highlight的class，然后将其内部&lt;a&gt;子元素都显示出来，并且被单击的class中含有has_children元素的同辈元素都去掉一个名为highlight的class，同时同辈元素内部的&lt;a&gt;子元素全部隐藏\n\n这就是jQuery强大的链式操作，一行代码就完成了导航栏的功能\n","categories":["WebFrontend"],"tags":["jQuery"]},{"title":"Promise 笔记","url":"/2022/10/17/WebFrontend/JavaScript/Promise%E7%AC%94%E8%AE%B0/","content":"Promise介绍promise是一个异步编程的一种解决方式，专门用于解决回调函数出现的回调地狱情况。\n抽象表达：\n\nPromise是一门新的技术（ES6规范）\nPromise是JS中进行异步编程的新解决方法（旧方案是单纯使用回调函数）\n\n具体表达：\n\n从语法上来说：Promise是一个构造函数\n从功能上来说：promise对象用来封装一个异步操作并可以获取成功&#x2F;失败的结果值\n\n\nfs 文件操作\nrequire(&#x27;fs&#x27;).readFile(&#x27;./index.html&#x27;,(err,data)=&gt;&#123;&#125;)\n\n数据库操作\nAJAX\n$.get(&#x27;/server&#x27;,(data)=&gt;&#123;&#125;)\n\n定时器\nsetTimeout(()=&gt;&#123;&#125;,2000);\n\nPromise 初体验使用回调函数：\n&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;utf-8&quot;&gt;\t\t&lt;title&gt;&lt;/title&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;div class=&quot;container&quot;&gt;\t\t\t&lt;h2 class=&quot;pape-header&quot;&gt;Promise 初体验&lt;/h2&gt;\t\t\t&lt;button class=&quot;btn butn-primary&quot; id=&quot;btn&quot;&gt;点击抽奖&lt;/button&gt;\t\t&lt;/div&gt;\t\t&lt;script type=&quot;text/javascript&quot;&gt;\t\t\t//生成随机数\t\t\tfunction rand(m,n)&#123;\t\t\t\treturn Math.ceil(Math.random() * (n-m+1)) + m -1\t\t\t&#125;\t\t\t/*  点击按钮，2s后显示是否中奖（30%概率中奖）\t\t\t *  容易中奖弹出 恭喜恭喜，奖品为10万RMB劳斯莱斯优惠卷\t\t\t *  若未中奖弹出 再接再厉\t\t\t */\t\t\t//获取元素对象\t\t\tconst btn = document.querySelector(&#x27;#btn&#x27;);\t\t\t//绑定单击事件\t\t\tbtn.addEventListener(&#x27;click&#x27;, function()&#123;\t\t\t\t//定时器\t\t\t\tsetTimeout(() =&gt; &#123;\t\t\t\t\t//30% 1-100 1 2 30\t\t\t\t\t//获取从 1 - 100的一个随机数\t\t\t\t\tlet n = rand(1,100);\t\t\t\t\tif(n &lt;= 30)&#123;\t\t\t\t\t\talert(&quot;恭喜恭喜，奖品为10万RMB劳斯莱斯优惠卷&quot;);\t\t\t\t\t&#125;else&#123;\t\t\t\t\t\talert(&quot;再接再厉&quot;);\t\t\t\t\t&#125;\t\t\t\t&#125;,1000);\t\t\t&#125;);\t\t\t\t\t&lt;/script&gt;\t&lt;/body&gt;&lt;/html&gt;\nPromise方法：\n&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;utf-8&quot;&gt;\t\t&lt;title&gt;&lt;/title&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;div class=&quot;container&quot;&gt;\t\t\t&lt;h2 class=&quot;pape-header&quot;&gt;Promise 初体验&lt;/h2&gt;\t\t\t&lt;button class=&quot;btn butn-primary&quot; id=&quot;btn&quot;&gt;点击抽奖&lt;/button&gt;\t\t&lt;/div&gt;\t\t&lt;script type=&quot;text/javascript&quot;&gt;\t\t\t//生成随机数\t\t\tfunction rand(m,n)&#123;\t\t\t\treturn Math.ceil(Math.random() * (n-m+1)) + m -1\t\t\t&#125;\t\t\t/*  点击按钮，2s后显示是否中奖（30%概率中奖）\t\t\t *  容易中奖弹出 恭喜恭喜，奖品为10万RMB劳斯莱斯优惠卷\t\t\t *  若未中奖弹出 再接再厉\t\t\t */\t\t\t//获取元素对象\t\t\tconst btn = document.querySelector(&#x27;#btn&#x27;);\t\t\t//绑定单击事件\t\t\tbtn.addEventListener(&#x27;click&#x27;, function()&#123;\t\t\t\t\t\t\t\t//Promise 形式实现\t\t\t\tconst p = new Promise((resolve,reject) =&gt; &#123;\t\t\t\t\tsetTimeout(() =&gt; &#123;\t\t\t\t\t\t//30% 1-100 1 2 30\t\t\t\t\t\t//获取从 1 - 100的一个随机数\t\t\t\t\t\tlet n = rand(1,100);\t\t\t\t\t\tif(n &lt;= 30)&#123;\t\t\t\t\t\t\tresolve();\t\t\t\t\t\t&#125;else&#123;\t\t\t\t\t\t\treject();\t\t\t\t\t\t&#125;\t\t\t\t\t&#125;,1000);\t\t\t\t&#125;);\t\t\t\t\t\t\t\t// 调用 then 方法\t\t\t\tp.then(() =&gt; &#123;\t\t\t\t\talert(&quot;恭喜恭喜，奖品为10万RMB劳斯莱斯优惠卷&quot;);\t\t\t\t&#125;,() =&gt; &#123;\t\t\t\t\talert(&quot;再接再厉&quot;);\t\t\t\t&#125;);\t\t\t&#125;);\t\t\t\t\t&lt;/script&gt;\t&lt;/body&gt;&lt;/html&gt;\n\nfs读取文件","categories":["WebFrontend"],"tags":["javascript"]},{"title":"Web学习日志(office)","url":"/2022/08/25/WebFrontend/JavaScript/Web%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97(office)/","content":"Day1input,button标签,实现简单加法计算器&lt;input size = &quot;6&quot; id = &quot;input1&quot;/&gt;+&lt;input size = &quot;6&quot; id = &quot;input2&quot;/&gt;&lt;button&gt;=&lt;/button&gt;&lt;input size = &quot;6&quot; / id = &quot;input3&quot;/&gt;\n\n\n\nsize ：可以调输入框的长度\nid ：id属性具有唯一值\n\n在script标签写入脚本，推荐使用type属性：\nfunction sum()&#123;    var firstNum = document.getElementById(&quot;input1&quot;).value; //获取input输入值    var secondNum = document.getElementById(&quot;input2&quot;).value;    //输入的值会被转换成字符串类型，所以我们要从字符串类型转换为数值,也可以使用隐式转换    firstNum = Number(firstNum);    secondNum = Number(secondNum);        document.getElementById(&quot;input3&quot;).value = firestNum + secondNum;&#125;\n\n\nvar ：variable的缩写\nvalue：设置或者返回文本域的默认值\n\n点击按钮切换图片，按钮触发事件&lt;!DOCTYPE html&gt;&lt;!-- 标签 --&gt;&lt;!-- 一对标签  空标签  属性--&gt;&lt;html&gt;\t&lt;!-- html css js --&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;utf-8&quot; /&gt;\t\t&lt;title&gt;切换图片&lt;/title&gt;\t\t&lt;/head&gt;\t&lt;body&gt;\t\t\t\t&lt;img src=&quot;img/7.jpg&quot; width=&quot;300px&quot; height=&quot;186px&quot; id=&quot;img_7&quot;/&gt;\t\t&lt;br /&gt;\t\t&lt;img src=&quot;img/10.jpg&quot; width=&quot;300px&quot; height=&quot;186px&quot; id=&quot;img_10&quot;/&gt;&lt;br /&gt;\t\t&lt;button onclick=&quot;changeImage()&quot; id=&quot;btn&quot;&gt;切换图片&lt;/button&gt;\t\t\t\t&lt;script type=&quot;text/javascript&quot;&gt;\t\t\t/* 事件名或方法名  小驼峰 15个字符以内 */\t\t\t/* function 功能 ;document 文件；Element 元素*/\t\t\tfunction changeImage()&#123;\t\t\t\t//通过id从页面文件中获取指定元素。修改这个元素的属性来实现效果变化\t\t\t\tx=document.getElementById(&quot;img_7&quot;).src;\t\t\t\t/* alert(x); */\t\t\t\tif(x==&quot;http://127.0.0.1:8848/Day8.22/img/7.jpg&quot;)&#123;\t\t\t\t\tdocument.getElementById(&quot;img_7&quot;).src=&quot;img/10.jpg&quot;;\t\t\t\t\tdocument.getElementById(&quot;img_10&quot;).src=&quot;img/7.jpg&quot;;\t\t\t\t\tdocument.getElementById(&quot;btn&quot;).innerText=&quot;切换回去&quot;;\t\t\t\t&#125;\t\t\t\tif(x==&quot;http://127.0.0.1:8848/Day8.22/img/10.jpg&quot;)&#123;\t\t\t\t\tdocument.getElementById(&quot;img_7&quot;).src=&quot;img/7.jpg&quot;;\t\t\t\t\tdocument.getElementById(&quot;img_10&quot;).src=&quot;img/10.jpg&quot;;\t\t\t\t\tdocument.getElementById(&quot;btn&quot;).innerText=&quot;切换图片&quot;;\t\t\t\t&#125;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t&#125;\t\t\t\t\t&lt;/script&gt;\t\t\t&lt;/body&gt;&lt;/html&gt; \n\nDay2使用函数实现加法计算器&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;utf-8&quot;&gt;\t\t&lt;title&gt;&lt;/title&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;input id=&quot;input1&quot;/&gt;\t\t&lt;button onclick=&quot;add()&quot;&gt;+&lt;/button&gt;\t\t&lt;button onclick=&quot;sum()&quot;&gt;=&lt;/button&gt;\t\t\t\t&lt;script type=&quot;text/javascript&quot;&gt;\t\t\tlet firstNum;\t\t\tfunction add()&#123;\t\t\t\tfirstNum = document.getElementById(&quot;input1&quot;).value;\t\t\t\tdocument.getElementById(&quot;input1&quot;).value = &quot;&quot;;\t\t\t&#125;\t\t\tfunction sum()&#123;\t\t\t\tlet secondNum = document.getElementById(&quot;input1&quot;).value;\t\t\t\tdocument.getElementById(&quot;input1&quot;).value = +firstNum+ +secondNum;\t\t\t&#125;\t\t&lt;/script&gt;\t&lt;/body&gt;&lt;/html&gt;\n\n计算机进阶,加减计算器&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;utf-8&quot; /&gt;\t\t&lt;title&gt;&lt;/title&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;input id=&quot;input1&quot;/&gt;\t\t&lt;button onclick=&quot;add()&quot;&gt;+&lt;/button&gt;\t\t&lt;button onclick=&quot;sub()&quot;&gt;-&lt;/button&gt;\t\t&lt;button onclick=&quot;sum()&quot;&gt;=&lt;/button&gt;\t\t&lt;script type=&quot;text/javascript&quot;&gt;\t\t\t//局部变量  全局变量\t\t\t//声明一个变量，命名为x；并且把10赋值给x\t\t\tvar firstNum;//声明全局变量\t\t\tvar sign;\t\t\tfunction add()&#123;\t\t\t\tfirstNum=document.getElementById(&quot;input1&quot;).value;\t\t\t\tdocument.getElementById(&quot;input1&quot;).value=&quot;&quot;;\t\t\t\tsign=&quot;+&quot;;\t\t\t&#125;\t\t\tfunction sub()&#123;\t\t\t\tfirstNum=document.getElementById(&quot;input1&quot;).value;\t\t\t\tdocument.getElementById(&quot;input1&quot;).value=&quot;&quot;;\t\t\t\tsign=&quot;-&quot;;\t\t\t&#125;\t\t\tfunction sum()&#123;\t\t\t\tvar secondNum=document.getElementById(&quot;input1&quot;).value;\t\t\t\tsecondNum=Number(secondNum);\t\t\t\tfirstNum=Number(firstNum);\t\t\t\tif(sign==&quot;+&quot;)&#123;\t\t\t\t\tdocument.getElementById(&quot;input1&quot;).value=firstNum+secondNum;\t\t\t\t&#125;else&#123;\t\t\t\t\tdocument.getElementById(&quot;input1&quot;).value=firstNum-secondNum;\t\t\t\t&#125;\t\t\t\t&#125;\t\t&lt;/script&gt;\t&lt;/body&gt;&lt;/html&gt; \n\n\nonclick ：方法，按钮的点击事件触发函数调用\n\nDay3小技巧：\ntable&gt;tr*7&gt;td*7 //快速生成,输入之后输入tap键\n\n\n\ntable表格显示(正)字&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;utf-8&quot;&gt;\t\t&lt;title&gt;&lt;/title&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;style&gt;\t\t\ttable&#123;\t\t\t\twidth: 500px;\t\t\t\theight: 500px;\t\t\t\tborder: 1px; /* 边框 */\t\t\t&#125;\t\t&lt;/style&gt;\t\t&lt;table border=&quot;1px&quot;&gt;\t\t\t&lt;tr id=&quot;1&quot;&gt;\t\t\t\t&lt;td colspan=&quot;7&quot; bgcolor=&quot;red&quot;&gt;&lt;/td&gt;\t\t\t&lt;/tr&gt;\t\t\t&lt;tr id=&quot;2&quot;&gt;\t\t\t\t&lt;td&gt;&lt;/td&gt;\t\t\t\t&lt;td&gt;&lt;/td&gt;\t\t\t\t&lt;td&gt;&lt;/td&gt;\t\t\t\t&lt;td rowspan=&quot;5&quot; bgcolor=&quot;red&quot;&gt;&lt;/td&gt;\t\t\t\t&lt;td&gt;&lt;/td&gt;\t\t\t\t&lt;td&gt;&lt;/td&gt;\t\t\t\t&lt;td&gt;&lt;/td&gt;\t\t\t&lt;/tr&gt;\t\t\t&lt;tr id=&quot;3&quot;&gt;\t\t\t\t&lt;td&gt;&lt;/td&gt;\t\t\t\t&lt;td&gt;&lt;/td&gt;\t\t\t\t&lt;td&gt;&lt;/td&gt;\t\t\t\t&lt;td&gt;&lt;/td&gt;\t\t\t\t&lt;td&gt;&lt;/td&gt;\t\t\t\t&lt;td&gt;&lt;/td&gt;\t\t\t&lt;/tr&gt;\t\t\t&lt;tr id=&quot;4&quot;&gt;\t\t\t\t&lt;td&gt;&lt;/td&gt;\t\t\t\t&lt;td&gt;&lt;/td&gt;\t\t\t\t&lt;td&gt;&lt;/td&gt;\t\t\t\t&lt;td colspan=&quot;3&quot; bgcolor=&quot;red&quot;&gt;&lt;/td&gt;\t\t\t&lt;/tr&gt;\t\t\t&lt;tr id=&quot;5&quot;&gt;\t\t\t\t&lt;td&gt;&lt;/td&gt;\t\t\t\t&lt;td rowspan=&quot;2&quot; bgcolor=&quot;red&quot;&gt;&lt;/td&gt;\t\t\t\t&lt;td&gt;&lt;/td&gt;\t\t\t\t&lt;td&gt;&lt;/td&gt;\t\t\t\t&lt;td&gt;&lt;/td&gt;\t\t\t\t&lt;td&gt;&lt;/td&gt;\t\t\t&lt;/tr&gt;\t\t\t&lt;tr id=&quot;6&quot;&gt;\t\t\t\t&lt;td&gt;&lt;/td&gt;\t\t\t\t&lt;td&gt;&lt;/td&gt;\t\t\t\t&lt;td&gt;&lt;/td&gt;\t\t\t\t&lt;td&gt;&lt;/td&gt;\t\t\t\t&lt;td&gt;&lt;/td&gt;\t\t\t&lt;/tr&gt;\t\t\t&lt;tr id=&quot;7&quot;&gt;\t\t\t\t&lt;td colspan=&quot;7&quot; bgcolor=&quot;red&quot;&gt;&lt;/td&gt;\t\t\t&lt;/tr&gt;\t\t&lt;/table&gt;\t&lt;/body&gt;&lt;/html&gt;\n\n\nDay4实现简单前端验证码&lt;body&gt;\t&lt;input /&gt;\t&lt;button onclick=&quot;sendCode()&quot; id=&quot;but1&quot;&gt;发送验证码&lt;/button&gt;\t&lt;script type=&quot;text/javascript&quot;&gt;\t\tvar x = 60;\t\tvar timer = null;\t\tfunction sendCode() &#123;\t\t\ttimer = window.setInterval(change, 100);\t\t&#125;\t\tfunction change() &#123;\t\t\tx--;\t\t\tdocument.getElementById(&quot;but1&quot;).innerText = &quot;重新发送(&quot; + x + &quot;)&quot;\t\t\tif (x == 0) &#123;\t\t\t\t//1.清除定时器\t\t\t\twindow.clearInterval(timer);\t\t\t\t//2.把按钮上的文字改回“发送验证码”\t\t\t\tdocument.getElementById(&quot;but1&quot;).innerText = &quot;发送验证码&quot;;\t\t\t\t//3.把相关的值重置\t\t\t\tx = 60;\t\t\t\ttimer = null;\t\t\t&#125;\t\t&#125;\t&lt;/script&gt;&lt;/body&gt;\n\n总结：\n\n代码使用驼峰命名法，事件名，方法命名是小驼峰\nctar+shift+&#x2F; 注释\nonclick 点击事件\nfunction 功能\ndocumet 文件\nElement 元素\nInterval 间隔、间隙\n\nDay5产生指定范围随机整数&lt;script type=&quot;text/javascript&quot;&gt;\t//[10,60]  [25,77]\tvar x = Math.random(); //[0,1)\tvar y = x * 51 + 10; //[0,51)-&gt;[10,61)\tvar z = Math.floor(y); //[10,60]\tvar a = Math.random(); //[0,1)\tvar b = a * 53 + 25; //[0,53)-&gt;[25,78) \tvar c = Math.floor(b); //[25,77]\tvar i = Math.floor(Math.random() * 53 + 25);&lt;/script&gt;\n\n\nMath.random产生随机数\nMath.floor 取整\n\nDay6随机滚动数据小练习(添加按钮)&lt;body&gt;\t&lt;span id = &quot;span1&quot;&gt;00&lt;/span&gt;\t&lt;br&gt;\t&lt;button onclick=&quot;startRoll()&quot;&gt;开始滚动&lt;/button&gt;\t&lt;button onclick=&quot;stopRoll()&quot;&gt;停止滚动&lt;/button&gt;\t&lt;script type=&quot;text/javascript&quot;&gt;\t\tvar timer = null;\t\tfunction startRoll()&#123;\t\t\tif (timer == null)&#123;\t\t\t\ttimer = window.setInterval(&quot;change()&quot;,100); &lt;!-- 里面填change或&quot;change()&quot;，不能填change() --&gt;\t\t\t&#125;\t\t&#125;\t\tfunction change()&#123;\t\t\tvar x = Math.floor(Math.random()*100+1);\t\t\tif(x&lt;10)&#123;\t\t\t\tx=&quot;0&quot;+x;\t\t\t&#125;\t\t\tdocument.getElementById(&quot;span1&quot;).innerText = x;\t\t&#125;\t\tfunction stopRoll()&#123;\t\t\twindow.clearInterval(timer);\t\t\ttimer = null;\t\t&#125;\t&lt;/script&gt;&lt;/body&gt;\n\n\n定时随机滚动小练习&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;utf-8&quot;&gt;\t\t&lt;title&gt;&lt;/title&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;span id=&quot;span1&quot;&gt;00&lt;/span&gt;\t\t&lt;script type=&quot;text/javascript&quot;&gt;\t\t\tvar timer = window.setInterval(&quot;change()&quot;,100); //间隔一定时间执行\t\t\twindow.setTimeout(  //5秒后执行，一次\t\t\tfunction ()&#123;\t\t\t\twindow.clearInterval(timer);//清除定时器\t\t\t&#125;\t\t\t,5000);\t\t\tfunction change()&#123;\t\t\t\tvar x = Math.floor(Math.random()*100+10);\t\t\t\tif(x&lt;10)&#123;\t\t\t\t\tx = &quot;0&quot;+x;\t\t\t\t&#125;\t\t\t\tdocument.getElementById(&quot;span1&quot;).innerText = x;\t\t\t&#125;\t\t&lt;/script&gt;\t&lt;/body&gt;&lt;/html&gt;\n\n\nDay7作业：定时随机滚动小练习(添加按钮)&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;utf-8&quot; /&gt;\t\t&lt;title&gt;&lt;/title&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;span id=&quot;span1&quot;&gt;00&lt;/span&gt;\t\t&lt;br /&gt;\t\t&lt;button onclick=&quot;startRoll()&quot;&gt;开始滚动&lt;/button&gt;\t\t&lt;script type=&quot;text/javascript&quot;&gt;\t\t\tvar timer = null;\t\t\tfunction startRoll() &#123;\t\t\t\tif (timer == null) &#123;\t\t\t\t\ttimer = window.setInterval(change, 500);\t\t\t\t\twindow.setTimeout(\t\t\t\t\t\tfunction() &#123;\t\t\t\t\t\t\twindow.clearInterval(timer);\t\t\t\t\t\t\ttimer = null;\t\t\t\t\t\t&#125;, 5000);\t\t\t\t&#125;\t\t\t&#125;\t\t\tfunction change() &#123;\t\t\t\tvar x = Math.floor(Math.random() * 100 + 1);\t\t\t\tdocument.getElementById(&quot;span1&quot;).innerText = x;\t\t\t&#125;\t\t&lt;/script&gt;\t&lt;/body&gt;&lt;/html&gt;\n\n\nDay8随机算数题&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;utf-8&quot;&gt;\t\t&lt;title&gt;算术题&lt;/title&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;span id=&quot;span1&quot;&gt;00&lt;/span&gt;\t\t&lt;label&gt;-&lt;/label&gt;\t\t&lt;span id=&quot;span2&quot;&gt;00&lt;/span&gt;\t\t&lt;label&gt;=&lt;/label&gt;\t\t&lt;input size=&quot;5&quot; id=&quot;input1&quot; /&gt;\t\t&lt;button onclick=&quot;submit()&quot;&gt;提交&lt;/button&gt;\t\t&lt;script type=&quot;text/javascript&quot;&gt;\t\t\tvar x, y;\t\t\tvar timer = window.setInterval(\t\t\t\tfunction() &#123;\t\t\t\t\tx = Math.floor(Math.random() * 100 + 1);\t\t\t\t\ty = Math.floor(Math.random() * 100 + 1);\t\t\t\t\tdocument.getElementById(&quot;span1&quot;).innerText = x;\t\t\t\t\tdocument.getElementById(&quot;span2&quot;).innerText = y;\t\t\t\t&#125;, 3000);\t\t\tfunction submit() &#123;\t\t\t\tvar num = document.getElementById(&quot;input1&quot;).value;\t\t\t\tif (x - y == num) &#123;\t\t\t\t\twindow.clearInterval(timer);\t\t\t\t&#125;\t\t\t&#125;\t\t&lt;/script&gt;\t&lt;/body&gt;&lt;/html&gt;\n\nDay9猜大小游戏&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;utf-8&quot;&gt;\t\t&lt;title&gt;猜大小&lt;/title&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;label&gt;猜大小&lt;/label&gt;\t\t&lt;br /&gt;\t\t&lt;button onclick=&quot;start()&quot;&gt;开始游戏&lt;/button&gt;\t\t&lt;br /&gt;\t\t&lt;span&gt;生成随机数为: &lt;/span&gt;\t\t&lt;span id = &quot;span&quot;&gt;&lt;/span&gt;\t\t&lt;br /&gt;\t\t&lt;input size=&quot;4&quot; id = &quot;input1&quot;/&gt;\t\t&lt;button onclick=&quot;guess()&quot;&gt;猜数&lt;/button&gt;\t\t&lt;span id = &quot;span2&quot;&gt;&lt;/span&gt;\t\t&lt;br /&gt;\t\t&lt;span&gt;竞猜结果：&lt;/span&gt;\t\t&lt;script type=&quot;text/javascript&quot;&gt;\t\t\tvar num,x;\t\t\tfunction start()&#123;\t\t\t\tdocument.getElementById(&quot;span&quot;).innerText = &quot;**&quot;;\t\t\t\tx = parseInt(Math.random()*100+1);\t\t\t&#125;\t\t\tfunction guess()&#123;\t\t\t\tnum = document.getElementById(&quot;input1&quot;).value;\t\t\t\tif(num == x)&#123;\t\t\t\t\tdocument.getElementById(&quot;span2&quot;).innerText = &quot;猜对了&quot;;\t\t\t\t&#125;\t\t\t\telse if (num &gt; x)&#123;\t\t\t\t\tdocument.getElementById(&quot;span2&quot;).innerText = &quot;猜大了&quot;;\t\t\t\t&#125;\t\t\t\telse if (num &lt; x)&#123;\t\t\t\t\tdocument.getElementById(&quot;span2&quot;).innerText = &quot;猜小了&quot;;\t\t\t\t&#125;\t\t\t&#125;\t\t&lt;/script&gt;\t&lt;/body&gt;&lt;/html&gt;\n\n余数计算器&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;utf-8&quot;&gt;\t\t&lt;title&gt;&lt;/title&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;label&gt;判断数据是否能被2整除还能被3整除&lt;/label&gt;\t\t&lt;br /&gt;\t\t&lt;input id = &quot;input1&quot;/&gt;\t\t&lt;button onclick=&quot;start()&quot;&gt;校验&lt;/button&gt;\t\t&lt;br /&gt;\t\t&lt;span&gt;检测结果：&lt;/span&gt;\t\t&lt;span id=&quot;span2&quot;&gt;&lt;/span&gt;\t\t&lt;script type=&quot;text/javascript&quot;&gt;\t\t\tvar x,y,z;\t\t\tfunction start()&#123;\t\t\t\tx = document.getElementById(&quot;input1&quot;).value\t\t\t\ty = x%3;\t\t\t\tz = x%2;\t\t\t\tif(y == 0 &amp;&amp; z == 0)&#123;\t\t\t\t\tdocument.getElementById(&quot;span2&quot;).innerText = &quot;是&quot;;\t\t\t\t&#125;\t\t\t\telse&#123;\t\t\t\t\tdocument.getElementById(&quot;span2&quot;).innerText = &quot;否&quot;;\t\t\t\t&#125;\t\t\t&#125;\t\t&lt;/script&gt;\t&lt;/body&gt;&lt;/html&gt;\n\n&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;utf-8&quot;&gt;\t\t&lt;title&gt;&lt;/title&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;script type=&quot;text/javascript&quot;&gt;\t\t\t/弱类型的语言   强类型的语言\t\t\tvar x; //声明一个变量，命名为x，并且把10赋值给x\t\t\t//alert(typeof x);//undefined 未定义的\t\t\tx = 10;\t\t\t//alert(typeof x);//number  数值型\t\t\tvar y = &quot;1.5&quot;; //声明一个变量，命名为y，并且把&quot;20&quot;赋值给y\t\t\tx = x / y;\t\t\t//x=x+y;   10+&quot;20&quot;=&quot;1020&quot;  10+1.5=11.5\t\t\t//&#x27;+&#x27; 两边都是数值型，做加法运算；如果有一边是字符串类型，就是连接符\t\t\t//x=y-x;   &quot;220.9&quot;-10=210.9   &quot;张三&quot;-10=NaN\t\t\t//&#x27;-&#x27; 隐式的数据类型转换  只要两边能转换成number类型，就能做正常减法；\t\t\t//    如果转换不成数值，强制做减法，结果为NaN(not a number)\t\t\t//x=x*y;   10*&quot;220.9&quot;=2209    10*&quot;张三&quot;=NaN\t\t\t//&#x27;*&#x27; 隐式的数据类型转换  只要两边能转换成number类型，就能做正常乘法；\t\t\t//    如果转换不成数值，强制做乘法，结果为NaN(not a number)\t\t\t//x=x/y;   10/&quot;1.5&quot;=6.666666666667  10/&quot;张三&quot;=NaN\t\t\t//&#x27;/&#x27; 隐式的数据类型转换  只要两边能转换成number类型，就能做正常除法；\t\t\t//    如果转换不成数值，强制做除法，结果为NaN(not a number)\t\t\t//alert(typeof x);//string 字符串类型\t\t\talert(x);\t\t&lt;/script&gt;\t&lt;/body&gt;&lt;/html&gt;\n\nDay10体重健康计算器&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;utf-8&quot;&gt;\t\t&lt;title&gt;计算BMI&lt;/title&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;!-- bmi=体重/(身高*身高)  计算时体重单位kg，身高m --&gt;\t\t&lt;!-- 小于18.5  偏瘦；18.5~24  正常； 24~28  偏胖；28以上  肥胖 --&gt;\t\t&lt;label&gt;你的身高：&lt;/label&gt;\t\t&lt;input size=&quot;8&quot; id=&quot;input1&quot; /&gt;\t\t&lt;label&gt;单位：厘米cm&lt;/label&gt;\t\t&lt;br /&gt;\t\t&lt;label&gt;你的体重：&lt;/label&gt;\t\t&lt;input size=&quot;8&quot; id=&quot;input2&quot; /&gt;\t\t&lt;label&gt;单位：千克kg&lt;/label&gt;\t\t&lt;br /&gt;\t\t&lt;button onclick=&quot;calculate()&quot;&gt;计算BMI&lt;/button&gt;\t\t&lt;br /&gt;\t\t&lt;span&gt;你的身体状况为：&lt;/span&gt;&lt;span id=&quot;span1&quot;&gt;&lt;/span&gt;\t\t&lt;script type=&quot;text/javascript&quot;&gt;\t\t\tfunction calculate() &#123;\t\t\t\tvar height = document.getElementById(&quot;input1&quot;).value;\t\t\t\tvar weight = document.getElementById(&quot;input2&quot;).value;\t\t\t\theight = height / 100;\t\t\t\tvar bmi = weight / (height * height);\t\t\t\tvar spanObject = document.getElementById(&quot;span1&quot;);\t\t\t\t//number  string  undefined  object 对象类型\t\t\t\tif (bmi &lt; 18.5) &#123;\t\t\t\t\tspanObject.innerText = &quot;偏瘦&quot;;\t\t\t\t&#125; else if (bmi &lt;= 24) &#123;\t\t\t\t\tspanObject.innerText = &quot;正常&quot;;\t\t\t\t&#125; else if (bmi &lt; 28) &#123;\t\t\t\t\tspanObject.innerText = &quot;偏胖&quot;;\t\t\t\t&#125; else &#123;\t\t\t\t\tspanObject.innerText = &quot;肥胖&quot;;\t\t\t\t&#125;\t\t\t&#125;\t\t&lt;/script&gt;\t&lt;/body&gt;&lt;/html&gt;\n\n\n\n输入框排序练习（答案）&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;utf-8&quot;&gt;\t\t&lt;title&gt;计算BMI&lt;/title&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;!-- bmi=体重/(身高*身高)  计算时体重单位kg，身高m --&gt;\t\t&lt;!-- 小于18.5  偏瘦；18.5~24  正常； 24~28  偏胖；28以上  肥胖 --&gt;\t\t&lt;label&gt;你的身高：&lt;/label&gt;\t\t&lt;input size=&quot;8&quot; id = &quot;input1&quot;/&gt;\t\t&lt;label&gt;单位：厘米cm&lt;/label&gt;\t\t&lt;br /&gt;\t\t&lt;label&gt;你的体重：&lt;/label&gt;\t\t&lt;input size=&quot;8&quot; id = &quot;input2&quot;/&gt;\t\t&lt;label&gt;单位：千克kg&lt;/label&gt;\t\t&lt;br /&gt;\t\t&lt;button onclick=&quot;button()&quot;&gt;计算BMI&lt;/button&gt;\t\t&lt;br /&gt;\t\t&lt;span&gt;你的身体状况为：&lt;/span&gt;\t\t&lt;span id = &quot;span&quot;&gt;&lt;/span&gt;\t\t\t\t&lt;script type=&quot;text/javascript&quot;&gt;\t\t\tfunction button()&#123;\t\t\t\tlet height = document.getElementById(&quot;input1&quot;).value;\t\t\t\theight = height/100;\t\t\t\tlet weight = document.getElementById(&quot;input2&quot;).value;\t\t\t\tlet bmi = weight/(height*height);\t\t\t\tconsole.log(bmi)\t\t\t\tif (bmi &gt;= 18.5 &amp;&amp; bmi &lt; 24)&#123;\t\t\t\t\tdocument.getElementById(&quot;span&quot;).innerText = &quot;偏瘦&quot;;\t\t\t\t&#125;\t\t\t\telse if (bmi &gt;= 24 &amp;&amp; bmi &lt;= 28)&#123;\t\t\t\t\tdocument.getElementById(&quot;span&quot;).innerText = &quot;正常&quot;;\t\t\t\t&#125;\t\t\t\telse if (bmi &gt; 28)&#123;\t\t\t\t\tdocument.getElementById(&quot;span&quot;).innerText = &quot;肥胖&quot;;\t\t\t\t&#125;\t\t\t&#125;;\t\t&lt;/script&gt;\t&lt;/body&gt;&lt;/html&gt;\n\n输入框排序练习（提交）&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;utf-8&quot;&gt;\t\t&lt;title&gt;&lt;/title&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;input id = &quot;input1&quot;/&gt;\t\t&lt;input id = &quot;input2&quot;/&gt;\t\t&lt;input id = &quot;input3&quot;/&gt;\t\t&lt;button onclick=&quot;button1()&quot;&gt;排序&lt;/button&gt;\t\t&lt;br /&gt;\t\t&lt;input id = &quot;input1_1&quot;/&gt; &lt;\t\t&lt;input id = &quot;input2_2&quot;/&gt; &lt;\t\t&lt;input id = &quot;input3_3&quot;/&gt;\t\t\t\t&lt;script type=&quot;text/javascript&quot;&gt;\t\t\tfunction button1()&#123;\t\t\t\tlet input1 = document.getElementById(&quot;input1&quot;).value;\t\t\t\tlet input2 = document.getElementById(&quot;input2&quot;).value;\t\t\t\tlet input3 = document.getElementById(&quot;input3&quot;).value;\t\t\t\t\t\t\t\tvar points = [];\t\t\t\tpoints.push(input1);\t\t\t\tpoints.push(input2);\t\t\t\tpoints.push(input3);\t\t\t\t\t\t\t\tpoints.sort(function(a, b)&#123;return a - b&#125;); \t\t\t\t\t\t\t\tdocument.getElementById(&quot;input1_1&quot;).value = points[0];\t\t\t\tdocument.getElementById(&quot;input2_2&quot;).value = points[1];\t\t\t\tdocument.getElementById(&quot;input3_3&quot;).value = points[2];\t\t\t\t\t\t\t&#125;\t\t&lt;/script&gt;\t&lt;/body&gt;&lt;/html&gt;\n\nDay11找出1~1000所有含6的值&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;utf-8&quot; /&gt;\t\t&lt;title&gt;for循环&lt;/title&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;script type=&quot;text/javascript&quot;&gt;\t\t\t//[0,1) [0,41) [10,51) 666\t\t\tlet count = 0;\t\t\tfor(let i=1;i&lt;=1000;i++)&#123;\t\t\t\tlet b = parseInt(i %1000 /100)\t\t\t\tlet s = parseInt(i %100 /10)\t\t\t\tlet g = parseInt(i %10 /1)\t\t\t\tif (b == 6 || s == 6 || g ==6)&#123;\t\t\t\t\tcount ++;\t\t\t\t    document.write(i + &quot;&lt;br/&gt;&quot;); \t\t\t\t&#125;\t\t\t&#125;\t\t\tdocument.write(count + &quot;&lt;br /&gt;&quot;); //271\t\t&lt;/script&gt;\t&lt;/body&gt;&lt;/html&gt;\n\n查看数组添加&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;utf-8&quot;&gt;\t\t&lt;title&gt;&lt;/title&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;input id=&quot;input1&quot;/&gt;\t\t&lt;button onclick=&quot;add()&quot;&gt;添加&lt;/button&gt;\t\t&lt;button onclick=&quot;check()&quot;&gt;查看所有&lt;/button&gt;\t\t&lt;script type=&quot;text/javascript&quot;&gt;\t\t\tlet arr = new Array();\t\t\t\t\t\tfunction add()&#123;\t\t\t\tx = document.getElementById(&quot;input1&quot;).value;\t\t\t\tarr.push(x);\t\t\t\tdocument.getElementById(&quot;input1&quot;).value = &quot;&quot;;\t\t\t&#125;\t\t\tfunction check()&#123;\t\t\t\talert(arr);\t\t\t&#125;\t\t\t\t\t&lt;/script&gt;\t&lt;/body&gt;&lt;/html&gt;\n\nDay12找出最小值，并计算和&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;utf-8&quot; /&gt;\t\t&lt;title&gt;&lt;/title&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;script type=&quot;text/javascript&quot;&gt;\t\t\t//找出数组中的最小值，并计算除所有数据的和\t\t\tvar arr = [11, 22, 55, 3, 67, 99, 10, 78]; //数组名[下标]\t\t\t//arr.length 数组的长度 \t\t\tvar min = arr[0];\t\t\tvar sum = 0;\t\t\tfor (var i = 0; i &lt; arr.length; i++) &#123;\t\t\t\tsum = sum + arr[i]; //sum += arr[i]   \t\t\t\tif (arr[i] &lt; min) &#123;\t\t\t\t\tmin = arr[i];\t\t\t\t&#125;\t\t\t&#125;\t\t\talert(&quot;数组最小值为&quot; + min);\t\t\talert(&quot;数组数据总和为&quot; + sum);\t\t&lt;/script&gt;\t&lt;/body&gt;&lt;/html&gt;\n\n按钮添加数值查看最大值&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;utf-8&quot;&gt;\t\t&lt;title&gt;&lt;/title&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;input size=&quot;5&quot; id=&quot;input1&quot; /&gt;\t\t&lt;button onclick=&quot;add()&quot;&gt;添加&lt;/button&gt;\t\t&lt;button onclick=&quot;showMax()&quot;&gt;查看最大值&lt;/button&gt;\t\t&lt;script type=&quot;text/javascript&quot;&gt;\t\t\t//用户在页面中输入任意数量整数，返回添加数字的最大值\t\t\tvar arr = new Array(); //声明一个空数组\t\t\tfunction add() &#123;\t\t\t\tvar x = document.getElementById(&quot;input1&quot;).value;\t\t\t\tx = Number(x);\t\t\t\tarr.push(x);\t\t\t\talert(&quot;添加成功&quot;);\t\t\t\tdocument.getElementById(&quot;input1&quot;).value = &quot;&quot;;\t\t\t&#125;\t\t\tfunction showMax() &#123;\t\t\t\tvar max = arr[0];\t\t\t\tfor (var i = 0; i &lt; arr.length; i++) &#123;\t\t\t\t\tif (arr[i] &gt; max) &#123;\t\t\t\t\t\tmax = arr[i];\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t\talert(&quot;最大值为&quot; + max);\t\t\t&#125;\t\t&lt;/script&gt;\t&lt;/body&gt;&lt;/html&gt;\n\nDAY13查找质数&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;utf-8&quot; /&gt;\t\t&lt;title&gt;&lt;/title&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;script type=&quot;text/javascript&quot;&gt;\t\t\t//查找1~100之间所有的质数，并统计个数\t\t\t//质数（素数）只能被1和自身整除的数\t\t\tlet primeNum = 0;\t\t\tfor (let i = 1; i &lt;= 100; i++) &#123;\t\t\t\tlet count = 0;\t\t\t\tfor (let j = 1; j &lt;= i; j++) &#123;\t\t\t\t\tif (i % j == 0) &#123;\t\t\t\t\t\tcount++;\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t\tif (count == 2) &#123;\t\t\t\t\tdocument.write(i + &quot;&lt;br /&gt;&quot;);\t\t\t\t\tprimeNum ++;\t\t\t\t&#125;\t\t\t&#125;\t\t\tdocument.write(&quot;1~100之间所有的质数个数为：&quot;+ primeNum);\t\t&lt;/script&gt;\t&lt;/body&gt;&lt;/html&gt;\n\n查找完数&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;utf-8&quot;&gt;\t\t&lt;title&gt;&lt;/title&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;script type=&quot;text/javascript&quot;&gt;\t\t\t//找到1000以内所有的完数，并统计个数\t\t\t//完数(完全数或完美数)，所有的因子之和等于本身\t\t\tlet count = 0;\t\t\tfor (let i = 1; i &lt;= 1000; i++) &#123;\t\t\t\tcount = 0;\t\t\t\tfor (let j = 1; j &lt;= i/2; j++) &#123;\t\t\t\t\tif (i % j == 0) &#123;\t\t\t\t\t\tcount = count + j;\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t\tif (count == i) &#123;\t\t\t\t\tdocument.write(count + &quot;&lt;br /&gt;&quot;);\t\t\t\t\tcount = 0;\t\t\t\t&#125;\t\t\t&#125;\t\t&lt;/script&gt;\t&lt;/body&gt;&lt;/html&gt;\n\n九九乘法表&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;utf-8&quot;&gt;\t\t&lt;title&gt;&lt;/title&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;script type=&quot;text/javascript&quot;&gt;\t\t\tvar num = 0;\t\t\tfor (let i = 1; i &lt;= 9; i++) &#123;\t\t\t\tfor (let j = 1; j &lt;= i; j++) &#123;\t\t\t\t\tnum = i * j;\t\t\t\t\t//如果乘积是一位数，则前面添加两个空格保持队列\t\t\t\t\tif (num / 10 &lt; 1) &#123;\t\t\t\t\t\tnum = i * j + &quot;  &quot;;\t\t\t\t\t&#125;\t\t\t\t\t//如果乘积是一位数，则前面添加两个空格保持队列\t\t\t\t\tdocument.write(j + &quot;x&quot; + i + &quot;=&quot; + num + &quot;    &quot;);\t\t\t\t&#125;\t\t\t\tdocument.write(&quot;&lt;br /&gt;&quot;);\t\t\t&#125;\t\t&lt;/script&gt;\t&lt;/body&gt;&lt;/html&gt;\n\n冒泡排序&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;utf-8&quot;&gt;\t\t&lt;title&gt;&lt;/title&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;script type=&quot;text/javascript&quot;&gt;\t\t\t//已知数组[33,55,22,77,66,99,11],从大到小排序显示到页面上\t\t\tlet arr = [33, 55, 22, 77, 66, 99, 11];\t\t\tfor(let j = 0;j &lt; arr.length;j++)&#123;\t\t\t\tfor (let i = 0; i &lt; arr.length; i++) &#123;\t\t\t\t\tif (arr[i] &lt; arr[i + 1]) &#123;\t\t\t\t\t\t//交换位置\t\t\t\t\t\tconst temp = arr[i];\t\t\t\t\t\tarr[i] = arr[i + 1];\t\t\t\t\t\tarr[i + 1] = temp;\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t&#125;\t\t\tdocument.write(arr);\t\t&lt;/script&gt;\t&lt;/body&gt;&lt;/html&gt;\n\n生成指定范围不重复的整数&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;utf-8&quot;&gt;\t\t&lt;title&gt;&lt;/title&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;script type=&quot;text/javascript&quot;&gt;\t\t\t//随机生成六个1-33之间不重复的整数\t\t\tlet arr = new Array;\t\t\tfor(let i =1;i &lt;= 6;i++)&#123;\t\t\t\tlet number = Math.floor(Math.random()*32 + 1);\t\t\t\tif(arr.indexOf(number)== -1)&#123;\t\t\t\t\tarr.push(number);\t\t\t\t&#125;else&#123;\t\t\t\t\ti--;\t\t\t\t&#125;\t\t\t&#125;\t\t\tdocument.write(arr);\t\t\t\t\t&lt;/script&gt;\t&lt;/body&gt;&lt;/html&gt;\n\nDAY14使用按钮给数组添加值，并进行排序&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;utf-8&quot; /&gt;\t\t&lt;title&gt;&lt;/title&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;input size=&quot;5&quot; id=&quot;input1&quot; /&gt;\t\t&lt;button onclick=&quot;add()&quot;&gt;添加&lt;/button&gt;\t\t&lt;button onclick=&quot;show()&quot;&gt;查看&lt;/button&gt;\t\t&lt;script type=&quot;text/javascript&quot;&gt;\t\t\tvar arr = new Array();\t\t\tfunction add() &#123;\t\t\t\tvar x = document.getElementById(&quot;input1&quot;).value;\t\t\t\tx = Number(x);\t\t\t\tarr.push(x);\t\t\t\talert(&quot;添加成功&quot;);\t\t\t\tdocument.getElementById(&quot;input1&quot;).value = &quot;&quot;;\t\t\t&#125;\t\t\tfunction show() &#123;\t\t\t\tfor (var i = 0; i &lt; arr.length; i++) &#123;\t\t\t\t\tfor (var j = i; j &lt; arr.length; j++) &#123;\t\t\t\t\t\tif (arr[i] &gt; arr[j]) &#123;\t\t\t\t\t\t\tvar y = arr[i];\t\t\t\t\t\t\tarr[i] = arr[j];\t\t\t\t\t\t\tarr[j] = y;\t\t\t\t\t\t&#125;\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t\talert(arr);\t\t\t&#125;\t\t&lt;/script&gt;\t&lt;/body&gt;&lt;/html&gt;\n\n使用按钮给数组添加值，并添加删除键&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;utf-8&quot;&gt;\t\t&lt;title&gt;&lt;/title&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;input size=&quot;5&quot; id=&quot;input1&quot; /&gt;\t\t&lt;button onclick=&quot;add()&quot;&gt;添加&lt;/button&gt;\t\t&lt;button onclick=&quot;del()&quot;&gt;删除&lt;/button&gt;\t\t&lt;br /&gt;\t\t&lt;span&gt;已添加的数据：&lt;/span&gt;&lt;span id=&quot;span1&quot;&gt;&lt;/span&gt;\t\t&lt;script type=&quot;text/javascript&quot;&gt;\t\t\tvar arr = new Array();\t\t\tfunction add() &#123;\t\t\t\tvar x = document.getElementById(&quot;input1&quot;).value;\t\t\t\tx = Number(x);\t\t\t\tarr.push(x);\t\t\t\tdocument.getElementById(&quot;span1&quot;).innerText = arr;\t\t\t\tdocument.getElementById(&quot;input1&quot;).value = &quot;&quot;;\t\t\t&#125;\t\t\tfunction del() &#123;\t\t\t\tarr.splice(arr.length - 1); //splice(下标值)\t\t\t\tdocument.getElementById(&quot;span1&quot;).innerText = arr;\t\t\t&#125;\t\t&lt;/script&gt;\t&lt;/body&gt;&lt;/html&gt;\n\n\n使用按钮给数组添加值，并添加删除键（进行数组排序，并删除最近值）&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;utf-8&quot;&gt;\t\t&lt;title&gt;&lt;/title&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;input size=&quot;5&quot; id=&quot;input1&quot; /&gt;\t\t&lt;button onclick=&quot;add()&quot;&gt;添加&lt;/button&gt;\t\t&lt;button onclick=&quot;del()&quot;&gt;删除&lt;/button&gt;\t\t&lt;br /&gt;\t\t&lt;span&gt;已添加的数据：&lt;/span&gt;&lt;span id=&quot;span1&quot;&gt;&lt;/span&gt;\t\t&lt;script type=&quot;text/javascript&quot;&gt;\t\t\tvar arr1 = new Array();\t\t\tvar arr2;\t\t\tfunction add() &#123;\t\t\t\tvar x = document.getElementById(&quot;input1&quot;).value;\t\t\t\tx = Number(x);\t\t\t\tarr1.push(x);\t\t\t\tarray();\t\t\t\tdocument.getElementById(&quot;input1&quot;).value = &quot;&quot;;\t\t\t&#125;\t\t\tfunction del() &#123;\t\t\t\tarr1.splice(arr1.length - 1);\t\t\t\tarray();\t\t\t&#125;\t\t\tfunction array() &#123;\t\t\t\tarr2 = new Array();\t\t\t\tfor (var a = 0; a &lt; arr1.length; a++) &#123;\t\t\t\t\tarr2.push(arr1[a]);\t\t\t\t&#125;\t\t\t\tarr2.sort(); //返回从小到大排序好的数组\t\t\t\tdocument.getElementById(&quot;span1&quot;).innerText = arr2;\t\t\t&#125;\t\t&lt;/script&gt;\t&lt;/body&gt;&lt;/html&gt;\n\n\n作业：双色球&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;utf-8&quot;&gt;\t\t&lt;title&gt;&lt;/title&gt;\t\t&lt;style&gt;\t\t\tspan1 &#123;\t\t\t\twidth: 100px;\t\t\t\theight: 70px;\t\t\t\tborder: 1px solid rgb(48, 32, 189);\t\t\t&#125;\t\t\tspan2 &#123;\t\t\t\twidth: 100px;\t\t\t\theight: 70px;\t\t\t\tborder: 1px solid #a00101;\t\t\t&#125;\t\t&lt;/style&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;span&gt;双色球选号&lt;/span&gt;\t\t&lt;br /&gt;\t\t&lt;button onclick=&quot;ball(1)&quot;&gt;机选一注&lt;/button&gt;\t\t&lt;br&gt;\t\t&lt;span&gt;红球号码：&lt;/span&gt;\t\t&lt;span id=&quot;redBallNum1&quot;&gt;&lt;/span&gt;\t\t&lt;br /&gt;\t\t&lt;span&gt;蓝球号码：&lt;/span&gt;\t\t&lt;span id=&quot;blueBallNum1&quot;&gt;&lt;/span&gt;\t\t&lt;br /&gt;&lt;br /&gt;\t\t&lt;button onclick=&quot;ball(2)&quot;&gt;开奖&lt;/button&gt;\t\t&lt;br /&gt;\t\t&lt;span&gt;红球号码：&lt;/span&gt;\t\t&lt;span id=&quot;redBallNum2&quot;&gt;&lt;/span&gt;\t\t&lt;br /&gt;\t\t&lt;span&gt;蓝球号码：&lt;/span&gt;\t\t&lt;span id=&quot;blueBallNum2&quot;&gt;&lt;/span&gt;\t\t&lt;br /&gt;&lt;br /&gt;\t\t&lt;span&gt;历史记录：&lt;/span&gt;\t\t&lt;br /&gt;\t\t&lt;span id=&quot;history&quot;&gt;&lt;/span&gt;\t\t&lt;script type=&quot;text/javascript&quot;&gt;\t\t\t&quot;use strict&quot;\t\t\t//生成不重复随机数组\t\t\tfunction randomNum(x, y, z) &#123;\t\t\t\tlet arr = new Array();\t\t\t\tfor (let i = 1; i &lt;= z; i++) &#123;\t\t\t\t\tlet number = Math.floor(Math.random() * (y - x + 1) + x);\t\t\t\t\t//去重\t\t\t\t\tif (arr.indexOf(number) == -1) &#123;\t\t\t\t\t\tarr.push(number);\t\t\t\t\t&#125; else &#123;\t\t\t\t\t\ti--;\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t\treturn arr;\t\t\t&#125;\t\t\t//冒泡排序\t\t\tfunction sort(x, y, z) &#123;\t\t\t\tlet arr = [] = randomNum(x, y, z);\t\t\t\tfor (let j = 0; j &lt; arr.length; j++) &#123;\t\t\t\t\tfor (let i = 0; i &lt; arr.length; i++) &#123;\t\t\t\t\t\tif (arr[i] &gt; arr[i + 1]) &#123;\t\t\t\t\t\t\t//交换位置\t\t\t\t\t\t\tconst temp = arr[i];\t\t\t\t\t\t\tarr[i] = arr[i + 1];\t\t\t\t\t\t\tarr[i + 1] = temp;\t\t\t\t\t\t&#125;\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t\treturn arr;\t\t\t&#125;\t\t\t\t\t\tlet timer = null;\t\t\tlet arr_red_ball1 = new Array();\t\t\tlet arr_red_ball2 = new Array();\t\t\tlet arr_bluer_ball1 = new Array();\t\t\tlet arr_bluer_ball2 = new Array();\t\t\t//机选一注 开奖 ,添加计时器\t\t\tfunction ball(x) &#123;\t\t\t\tif (timer == null) &#123;\t\t\t\t\ttimer = window.setInterval(\t\t\t\t\t\tfunction() &#123;\t\t\t\t\t\t\tif (x == 1) &#123;\t\t\t\t\t\t\t\tarr_red_ball1 = sort(1, 33, 6);\t\t\t\t\t\t\t\tdocument.getElementById(`redBallNum$&#123;x&#125;`).innerText = arr_red_ball1.join(&quot;-&quot;);\t\t\t\t\t\t\t\tarr_bluer_ball1 = sort(1, 16, 1);\t\t\t\t\t\t\t\tdocument.getElementById(`blueBallNum$&#123;x&#125;`).innerText = arr_bluer_ball1.join(&quot;-&quot;);\t\t\t\t\t\t\t&#125;\t\t\t\t\t\t\telse if (x == 2 &amp;&amp; arr_bluer_ball1.length != 0) &#123;\t\t\t\t\t\t\t\tarr_red_ball2 = sort(1, 33, 6);\t\t\t\t\t\t\t\tdocument.getElementById(`redBallNum$&#123;x&#125;`).innerText = arr_red_ball2.join(&quot;-&quot;);\t\t\t\t\t\t\t\tarr_bluer_ball2 = sort(1, 16, 1);\t\t\t\t\t\t\t\tdocument.getElementById(`blueBallNum$&#123;x&#125;`).innerText = arr_bluer_ball2.join(&quot;-&quot;);\t\t\t\t\t\t\t&#125;\t\t\t\t\t\t\tif (arr_red_ball1.length == 0) &#123;\t\t\t\t\t\t\t\talert(&quot;请点击机选一注后再开奖&quot;);\t\t\t\t\t\t\t\twindow.clearInterval(timer);\t\t\t\t\t\t\t\ttimer = null;\t\t\t\t\t\t\t&#125;\t\t\t\t\t\t&#125;, 100);\t\t\t\t\t//设置5秒定时器,并在结束时进行数值判断,防止刷新\t\t\t\t\tif(x == 1 ||(x == 2 &amp;&amp; arr_bluer_ball1.length != 0))&#123;\t\t\t\t\t\twindow.setTimeout(\t\t\t\t\t\t\tfunction() &#123;\t\t\t\t\t\t\t\twindow.clearInterval(timer);\t\t\t\t\t\t\t\ttimer = null;\t\t\t\t\t\t\t\t//执行历史记录方法\t\t\t\t\t\t\t\thistory(x);\t\t\t\t\t\t\t\tjudge(x);\t\t\t\t\t\t\t&#125;, 5000\t\t\t\t\t\t);\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t&#125;\t\t\t//中奖判断\t\t\tfunction judge(x) &#123;\t\t\t\tlet arr1 = new Array();\t\t\t\tlet arr2 = new Array();\t\t\t\tlet judge = &quot;&quot;;\t\t\t\t//let arr_length_red = 0,arr_length_bluer = 0;\t\t\t\t//红球判断\t\t\t\tfor (let i = 0; i &lt; arr_red_ball1.length; i++) &#123;\t\t\t\t\tfor (let j = 0; j &lt; arr_red_ball2.length; j++) &#123;\t\t\t\t\t\tif (arr_red_ball1[i] == arr_red_ball2[j]) &#123;\t\t\t\t\t\t\tarr1.push(arr_red_ball1[i]);\t\t\t\t\t\t&#125;\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t\t//篮球判断\t\t\t\tfor (let i = 0; i &lt; arr_bluer_ball1.length; i++) &#123;\t\t\t\t\tfor (let j = 0; j &lt; arr_bluer_ball2.length; j++) &#123;\t\t\t\t\t\tif (arr_bluer_ball1[i] == arr_bluer_ball2[j]) &#123;\t\t\t\t\t\t\tarr2.push(arr_bluer_ball1[i]);\t\t\t\t\t\t&#125;\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t\t//2+1/1+1/0+1   5元\t\t\t\tif ((arr1.length == 2 &amp;&amp; arr2.length == 1) || (arr1.length == 1 &amp;&amp; arr2.length == 1) || (arr1.length == 0 &amp;&amp; arr2\t\t\t\t\t\t.length == 1)) &#123;\t\t\t\t\tjudge = &quot;5元&quot;;\t\t\t\t&#125;\t\t\t\t//4+0/3+1    10元\t\t\t\telse if ((arr1.length == 4 &amp;&amp; arr2.length == 0) || (arr1.length == 3 &amp;&amp; arr2.length == 1)) &#123;\t\t\t\t\tjudge = &quot;10元&quot;;\t\t\t\t&#125;\t\t\t\t//5+0/4+1   200元\t\t\t\telse if ((arr1.length == 5 &amp;&amp; arr2.length == 0) || (arr1.length == 4 &amp;&amp; arr2.length == 1)) &#123;\t\t\t\t\tjudge = &quot;200元&quot;;\t\t\t\t&#125;\t\t\t\t//5+1   3000元\t\t\t\telse if ((arr1.length == 5 &amp;&amp; arr2.length == 1)) &#123;\t\t\t\t\tjudge = &quot;3000元&quot;;\t\t\t\t&#125;\t\t\t\t//6+0   100万\t\t\t\telse if ((arr1.length == 6 &amp;&amp; arr2.length == 0)) &#123;\t\t\t\t\tjudge = &quot;100万元&quot;;\t\t\t\t&#125;\t\t\t\t//6+1    500万\t\t\t\telse if ((arr1.length == 6 &amp;&amp; arr2.length == 1)) &#123;\t\t\t\t\tjudge = &quot;500万元&quot;;\t\t\t\t&#125; else &#123;\t\t\t\t\tjudge = &quot;未中奖&quot;;\t\t\t\t&#125;\t\t\t\t//更改空数组\t\t\t\tif (arr1.length == 0) &#123;\t\t\t\t\tarr1 = &quot;无&quot;;\t\t\t\t&#125;\t\t\t\tif (arr2.length == 0) &#123;\t\t\t\t\tarr2 = &quot;无&quot;;\t\t\t\t&#125;\t\t\t\tif (x == 2 &amp;&amp; arr_bluer_ball1.length != 0)&#123;\t\t\t\t\tdocument.getElementById(&quot;history&quot;).innerHTML += &quot;中奖结果：&quot; + judge + &quot;&lt;br/ &gt;&quot; + &quot;匹配红球：&quot; + arr1 + &quot;&lt;br /&gt;&quot; + &quot;匹配篮球：&quot; + arr2 + &quot;&lt;br/ &gt;&quot;+ &quot;&lt;br /&gt;&quot;;\t\t\t\t&#125;\t\t\t&#125;\t\t\t//历史记录\t\t\tfunction history(x) &#123;\t\t\t\tif (x == 1) &#123;\t\t\t\t\tdocument.getElementById(&quot;history&quot;).innerHTML += &quot;&lt;span1&gt;&quot; + &quot;双色球选号：&quot; + &quot;&lt;/span1&gt;&quot; + &quot;&lt;br /&gt;&quot;;\t\t\t\t\tdocument.getElementById(&quot;history&quot;).innerHTML += &quot;红球号码：&quot; + arr_red_ball1.join(&quot;-&quot;) + &quot;&lt;br /&gt;&quot;;\t\t\t\t\tdocument.getElementById(&quot;history&quot;).innerHTML += &quot;蓝球号码：&quot; + arr_bluer_ball1.join(&quot;-&quot;) + &quot;&lt;br /&gt;&quot; + &quot;&lt;br /&gt;&quot;;\t\t\t\t&#125;\t\t\t\tif (x == 2) &#123;\t\t\t\t\tdocument.getElementById(&quot;history&quot;).innerHTML += &quot;&lt;span2&gt;&quot; + &quot;双色球开奖：&quot; + &quot;&lt;/span1&gt;&quot; + &quot;&lt;br /&gt;&quot;;\t\t\t\t\tdocument.getElementById(&quot;history&quot;).innerHTML += &quot;红球号码：&quot; + arr_red_ball2.join(&quot;-&quot;) + &quot;&lt;br /&gt;&quot;;\t\t\t\t\tdocument.getElementById(&quot;history&quot;).innerHTML += &quot;蓝球号码：&quot; + arr_bluer_ball2.join(&quot;-&quot;) + &quot;&lt;br /&gt;&quot;;\t\t\t\t&#125;\t\t\t&#125;\t\t&lt;/script&gt;\t&lt;/body&gt;&lt;/html&gt;\n\n\nDAY15三道简单for循环题&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;utf-8&quot; /&gt;\t\t&lt;title&gt;&lt;/title&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;script type=&quot;text/javascript&quot;&gt;\t\t\t//1.有一堆桃子i，猴子每天吃一半再多一个 ，吃到第五天j时发现只剩下1个桃子，问原来一共有多少桃子？\t\t\tlet peach = 1;\t\t\tfor(let i = 0;i &lt; 4;i++)&#123;\t\t\t\tpeach = (peach + 1) * 2;\t\t\t&#125;\t\t\tconsole.log(`共吃了$&#123;peach&#125;个桃子`,)\t\t\t//2.小球从100米高空落下，每次弹起是原高度一半，求第10次落地时，小球所经过的米数\t\t\tlet q = 100;\t\t\tlet q2 = 100;\t\t\tfor (let i = 10; i &gt;= 0; i--) &#123;\t\t\t\tq = q / 2; //小球高度一半的距离 \t\t\t\tq2 += q * 2;\t\t\t&#125;\t\t\tconsole.log(&quot;小球所经过的米数为:&quot; + q2)\t\t\t//一个人很倒霉，不小心打碎了一篮子鸡蛋。\t\t\t//每次拿2个则剩1个，\t\t\t//每次拿3个则剩2个，\t\t\t//每次拿5个则剩4个，\t\t\t//问原先篮子中最少有多少枚鸡蛋？\t\t\tlet g = 0;\t\t\tfor (i = 1; g == 0; i++) &#123;\t\t\t\tif ((i % 2 == 1) &amp;&amp; (i % 3 == 2) &amp;&amp; (i % 5 == 4)) &#123;\t\t\t\t\tg = 1;\t\t\t\t\tconsole.log(`一共有个$&#123;i&#125;鸡蛋`);\t\t\t\t&#125;\t\t\t&#125;\t\t&lt;/script&gt;\t&lt;/body&gt;&lt;/html&gt;\n\n倒三角生成&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;utf-8&quot; /&gt;\t\t&lt;title&gt;&lt;/title&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;span&gt;倒三角的行数：&lt;/span&gt;\t\t&lt;input type=&quot;text&quot; id=&quot;input1&quot; /&gt;\t\t&lt;button onclick=&quot;button1()&quot;&gt;生成&lt;/button&gt;\t\t&lt;br /&gt;\t\t&lt;span id = &quot;span1&quot;&gt;&lt;/span&gt;\t\t&lt;script type=&quot;text/javascript&quot;&gt;\t\t\tfunction button1() &#123;\t\t\t\tlet inpt_value = Number(document.getElementById(&quot;input1&quot;).value);\t\t\t\tfor (let i = inpt_value; i &gt; 0; i--) &#123;\t\t\t\t\tfor (let j = 1; j &lt;= i; j++) &#123;\t\t\t\t\t\tdocument.getElementById(&quot;span1&quot;).innerHTML += &quot;-&quot;;\t\t\t\t\t&#125;\t\t\t\t\tdocument.getElementById(&quot;span1&quot;).innerHTML += &quot;&lt;br /&gt;&quot;;\t\t\t\t&#125;\t\t\t&#125;\t\t&lt;/script&gt;\t&lt;/body&gt;&lt;/html&gt;\n\n\n等腰三角形生成&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;utf-8&quot;&gt;\t\t&lt;title&gt;&lt;/title&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;span&gt;等腰三角的行数：&lt;/span&gt;\t\t&lt;input type=&quot;text&quot; id=&quot;input1&quot; /&gt;\t\t&lt;button onclick=&quot;button1()&quot;&gt;生成&lt;/button&gt;\t\t&lt;br /&gt;\t\t&lt;span id=&quot;span1&quot;&gt;&lt;/span&gt;\t\t&lt;script type=&quot;text/javascript&quot;&gt;\t\t\tfunction button1() &#123;\t\t\t\tlet inpt_value = Number(document.getElementById(&quot;input1&quot;).value)\t\t\t\tfor (let i = 0; i &lt; inpt_value; i++) &#123;\t\t\t\t\tfor (let x = 0; x &lt; inpt_value - i; x++) &#123;\t\t\t\t\t\tdocument.getElementById(&quot;span1&quot;).innerHTML += &#x27; &#x27;;\t\t\t\t\t&#125;\t\t\t\t\tfor (let j = 0; j &lt;= i; j++) &#123;\t\t\t\t\t\tdocument.getElementById(&quot;span1&quot;).innerHTML += &#x27;*&#x27; + &#x27; &#x27;;\t\t\t\t\t&#125;\t\t\t\t\tdocument.getElementById(&quot;span1&quot;).innerHTML += &#x27;&lt;br /&gt;&#x27;;\t\t\t\t&#125;\t\t\t&#125;\t\t&lt;/script&gt;\t&lt;/body&gt;&lt;/html&gt;\n\n\nDAY16轮播图（练习）&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;utf-8&quot; /&gt;\t\t&lt;title&gt;&lt;/title&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t\t\t&lt;img src=&quot;img/0.webp&quot; id=&quot;img1&quot; width=&quot;300&quot; height=&quot;250&quot;&gt;\t\t&lt;br /&gt;\t\t&lt;button onclick=&quot;last()&quot;&gt;上一张&lt;/button&gt;\t\t&lt;button onclick=&quot;next()&quot;&gt;下一张&lt;/button&gt;\t\t&lt;script type=&quot;text/javascript&quot;&gt;\t\t\t&quot;use strict&quot;\t\t\tlet x = 0;\t\t\tlet timer = window.setInterval(next,2000);\t\t\tdocument.getElementById(&quot;img1&quot;).onmouseover = function ()&#123;\t\t\t\twindow.clearInterval(timer);\t\t\t&#125;\t\t\tdocument.getElementById(&quot;img1&quot;).onmouseout = function ()&#123;\t\t\t\ttimer = window.setInterval(next,1500);\t\t\t&#125;\t\t\tfunction next() &#123;\t\t\t\tx++;\t\t\t\tif (x &gt;= 6) &#123;\t\t\t\t\tx = 0;\t\t\t\t&#125;\t\t\t\tdocument.getElementById(&quot;img1&quot;).src = `img/$&#123;x&#125;.webp`;\t\t\t&#125;\t\t\tfunction last() &#123;\t\t\t\tx--;\t\t\t\tif (x &lt; 0) &#123;\t\t\t\t\tx = 5;\t\t\t\t&#125;\t\t\t\tdocument.getElementById(&quot;img1&quot;).src = `img/$&#123;x&#125;.webp`;\t\t\t&#125;\t\t&lt;/script&gt;\t&lt;/body&gt;&lt;/html&gt;\n\n广告弹窗（练习）&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;utf-8&quot;&gt;\t\t&lt;title&gt;&lt;/title&gt;\t\t&lt;style type=&quot;text/css&quot;&gt;\t\t\t.expdiv &#123;\t\t\t\tposition: absolute;\t\t\t\ttop:0px;\t\t\t\tright:0px;\t\t\t\twidth: 300px;\t\t\t\theight: 200px;\t\t\t\tborder: 1px solid #c8c8c8;\t\t\t\tz-index: 0;\t\t\t\tdisplay: none;\t\t\t&#125;\t\t\t.expimg &#123;\t\t\t\tposition: fixed;\t\t\t\twidth: 300px;\t\t\t\theight: 200px;\t\t\t\tz-index: 1;\t\t\t&#125;\t\t\t.expbtn &#123;\t\t\t\tposition: absolute;\t\t\t\ttop:0px;\t\t\t\tright:0px;/* \t\t\t\tpadding: 10px;\t\t\t\twidth: 80px; */\t\t\t\tbackground-color: #efefef;\t\t\t\tz-index: 2;\t\t\t&#125;\t\t&lt;/style&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;div class=&quot;expdiv&quot; id = &quot;expdiv&quot;&gt;\t\t\t&lt;img src=&quot;./img/0.webp&quot; class=&quot;expimg&quot;&gt;\t\t\t&lt;button onclick=&quot;show()&quot; class=&quot;expbtn&quot;&gt;关闭&lt;/button&gt;\t\t&lt;/div&gt;\t\t&lt;script type=&quot;text/javascript&quot;&gt;\t\t\twindow.setTimeout(function() &#123;\t\t\t\tdocument.getElementById(&quot;expdiv&quot;).style = &quot;display: block&quot;;\t\t\t&#125;, 3000)\t\t\tfunction show() &#123;\t\t\t\tdocument.getElementById(&quot;expdiv&quot;).style = &quot;display: none&quot;;\t\t\t&#125;\t\t&lt;/script&gt;\t&lt;/body&gt;&lt;/html&gt;\n\n鼠标停留变颜色（练习）&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;utf-8&quot;&gt;\t\t&lt;title&gt;&lt;/title&gt;\t\t&lt;style type=&quot;text/css&quot;&gt;\t\t&lt;/style&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;div id=&quot;spans&quot;&gt;\t\t\t&lt;span id=&quot;span1&quot;&gt;变&lt;/span&gt;\t\t\t&lt;span id=&quot;span2&quot;&gt;颜&lt;/span&gt;\t\t\t&lt;span id=&quot;span3&quot;&gt;色&lt;/span&gt;\t\t&lt;/div&gt;\t\t&lt;style&gt;\t\t\tspan &#123;\t\t\t\tfont-size: 40px;\t\t\t&#125;\t\t&lt;/style&gt;\t\t&lt;script type=&quot;text/javascript&quot;&gt;\t\t\tarr1 = [\t\t\t\t&quot;color: DarkCyan;&quot;,\t\t\t\t&quot;color: red;&quot;,\t\t\t\t&quot;color: blue;&quot;,\t\t\t\t&quot;color: green;&quot;,\t\t\t\t&quot;color: #00FF00;&quot;,\t\t\t\t&quot;color: #db25ff;&quot;,\t\t\t\t&quot;color: #ff4cc7;&quot;,\t\t\t\t&quot;color: #ff4197;&quot;,\t\t\t\t&quot;color: #fff88b;&quot;,\t\t\t]\t\t\tlet timer = null;\t\t\t//鼠标移入，循环调用color函数\t\t\tdocument.getElementById(&quot;spans&quot;).onmouseover = function() &#123;\t\t\t\ttimer = window.setInterval(color, 100);\t\t\t&#125;\t\t\t//鼠标移除，清除timer方法，以及循环重置颜色\t\t\tdocument.getElementById(&quot;spans&quot;).onmouseout = function() &#123;\t\t\t\twindow.clearInterval(timer);\t\t\t\tfor (let i = 1;i &lt;= 3;i++)&#123;\t\t\t\t\tdocument.getElementById(`span$&#123;i&#125;`).style = &quot;color: #000000;&quot;\t\t\t\t&#125;\t\t\t&#125;\t\t\t//color函数，dom选择器颜色更改\t\t\tfunction color() &#123;\t\t\t\tfor(let i = 1;i &lt;= 3;i++)&#123;\t\t\t\t\tx = random();\t\t\t\t\tdocument.getElementById(`span$&#123;i&#125;`).style = arr1[x];\t\t\t\t&#125;\t\t\t&#125;\t\t\t//随机数调用\t\t\tfunction random() &#123;\t\t\t\tlet x = Math.floor(Math.random() * 8);\t\t\t\treturn x;\t\t\t&#125;\t\t&lt;/script&gt;\t&lt;/body&gt;&lt;/html&gt;\n\nCSS+滚动数值综合（练习）&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;utf-8&quot;&gt;\t\t&lt;title&gt;&lt;/title&gt;\t\t&lt;style type=&quot;text/css&quot;&gt;\t\t\tdiv &#123;\t\t\t\twidth: 300px;\t\t\t\theight: 300px;\t\t\t\ttext-align: center;\t\t\t\tbackground-color: #002e9b;\t\t\t\tcolor: rgb(245, 223, 77);\t\t\t\tfont-size: 80px;\t\t\t\tfont-weight: bold;\t\t\t\tline-height: 300px;\t\t\t\tborder-radius: 50px;\t\t\t\tposition: absolute;\t\t\t\tleft: 40%;\t\t\t\ttop: 30%;\t\t\t\tdisplay: none;\t\t\t&#125;\t\t&lt;/style&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;input id = &quot;input1&quot; size=&quot;6&quot;&gt;\t\t&lt;button onclick=&quot;info()&quot;&gt;录入&lt;/button&gt;\t\t&lt;button onclick=&quot;change()&quot;&gt;开始滚动&lt;/button&gt;\t\t&lt;div id =&quot;div1&quot;&gt;&lt;/div&gt;\t&lt;/body&gt;\t&lt;script type=&quot;text/javascript&quot;&gt;\t\tlet arr = new Array();\t\tfunction info()&#123;\t\t\tif(document.getElementById(&quot;input1&quot;).value != &quot; &quot;)&#123;\t\t\t\tarr.push(document.getElementById(&quot;input1&quot;).value);\t\t\t&#125;\t\t\tdocument.getElementById(&quot;input1&quot;).value = &quot; &quot;;\t\t&#125;\t\tfunction change()&#123;\t\t\tdocument.getElementById(&quot;div1&quot;).style = &quot;display: block&quot;;\t\t\t//五秒清除定时器\t\t\twindow.setTimeout(function()&#123;\t\t\t\twindow.clearInterval(timer)\t\t\t&#125;,5000)\t\t\tlet timer = window.setInterval(function()&#123;\t\t\t\tx = random();\t\t\t\tdocument.getElementById(&quot;div1&quot;).innerText = arr[x];\t\t\t&#125;,100)\t\t&#125;\t\t//随机数调用\t\tfunction random() &#123;\t\t\tlet x = Math.floor(Math.random() * arr.length);\t\t\treturn x;\t\t&#125;\t&lt;/script&gt;&lt;/html&gt;\n\n轮播图（答案）&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;utf-8&quot; /&gt;\t\t&lt;title&gt;轮播图&lt;/title&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt; img src=&quot;img/1.jpg&quot; id=&quot;img1&quot; width=&quot;400px&quot; height=&quot;250px&quot; /&gt;\t\t&lt;br /&gt;\t\t&lt;button onclick=&quot;last()&quot;&gt;上一张&lt;/button&gt;\t\t&lt;button onclick=&quot;next()&quot;&gt;下一张&lt;/button&gt;\t\t&lt;script type=&quot;text/javascript&quot;&gt;\t\t\tvar arr = [&quot;img/1.jpg&quot;, &quot;img/2.jpg&quot;, &quot;img/8.jpg&quot;,\t\t\t\t&quot;img/9.jpg&quot;, &quot;img/向日葵.jpg&quot;, &quot;img/小松鼠.jpg&quot;\t\t\t];\t\t\tvar index = 0;\t\t\tvar timer = window.setInterval(next, 1000);\t\t\tdocument.getElementById(&quot;img1&quot;).onmouseover = function() &#123;\t\t\t\twindow.clearInterval(timer);\t\t\t&#125;\t\t\tdocument.getElementById(&quot;img1&quot;).onmouseout = function() &#123;\t\t\t\ttimer = window.setInterval(next, 1000);\t\t\t&#125;\t\t\tfunction next() &#123;\t\t\t\tindex++;\t\t\t\tif (index == 6) &#123;\t\t\t\t\tindex = 0;\t\t\t\t&#125;\t\t\t\tdocument.getElementById(&quot;img1&quot;).src = arr[index];\t\t\t&#125;\t\t\tfunction last() &#123;\t\t\t\tindex--;\t\t\t\tif (index == -1) &#123;\t\t\t\t\tindex = 5;\t\t\t\t&#125;\t\t\t\tdocument.getElementById(&quot;img1&quot;).src = arr[index];\t\t\t&#125;\t\t&lt;/script&gt;\t&lt;/body&gt;&lt;/html&gt;\n\n鼠标停留变颜色（练习）&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;utf-8&quot;&gt;\t\t&lt;title&gt;鼠标停留文字变色&lt;/title&gt;\t\t&lt;style&gt;\t\t\t/* 标签选择器 */\t\t\tspan &#123;\t\t\t\tfont-size: 60px;\t\t\t&#125;\t\t&lt;/style&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;span id=&quot;span1&quot; onmouseover=&quot;changeColor()&quot; onmouseout=&quot;leave()&quot;&gt;变&lt;/span&gt;\t\t&lt;span id=&quot;span2&quot; onmouseover=&quot;changeColor()&quot; onmouseout=&quot;leave()&quot;&gt;颜&lt;/span&gt;\t\t&lt;span id=&quot;span3&quot; onmouseover=&quot;changeColor()&quot; onmouseout=&quot;leave()&quot;&gt;色&lt;/span&gt;\t\t&lt;script type=&quot;text/javascript&quot;&gt;\t\t\tvar arr = [&quot;red&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;green&quot;, &quot;pink&quot;, &quot;tan&quot;, &quot;orange&quot;, &quot;purple&quot;, &quot;glod&quot;, &quot;gray&quot;];\t\t\tvar timer = null;\t\t\tfunction changeColor() &#123;\t\t\t\ttimer = window.setInterval(\t\t\t\t\tfunction() &#123;\t\t\t\t\t\tvar x = Math.floor(Math.random() * arr.length);\t\t\t\t\t\tvar y = Math.floor(Math.random() * arr.length);\t\t\t\t\t\tvar z = Math.floor(Math.random() * arr.length);\t\t\t\t\t\tdocument.getElementById(&quot;span1&quot;).style.color = arr[x];\t\t\t\t\t\tdocument.getElementById(&quot;span2&quot;).style.color = arr[y];\t\t\t\t\t\tdocument.getElementById(&quot;span3&quot;).style.color = arr[z];\t\t\t\t\t&#125;, 100);\t\t\t&#125;\t\t\tfunction leave() &#123;\t\t\t\twindow.clearInterval(timer);\t\t\t\tdocument.getElementById(&quot;span1&quot;).style.color = &quot;black&quot;;\t\t\t\tdocument.getElementById(&quot;span2&quot;).style.color = &quot;black&quot;;\t\t\t\tdocument.getElementById(&quot;span3&quot;).style.color = &quot;black&quot;;\t\t\t&#125;\t\t&lt;/script&gt;\t&lt;/body&gt;&lt;/html&gt;\n\nCSS+滚动数值综合（练习）&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;utf-8&quot;&gt;\t\t&lt;title&gt;&lt;/title&gt;\t\t&lt;style&gt;\t\t\tdiv &#123;\t\t\t\twidth: 300px;\t\t\t\theight: 300px;\t\t\t\tborder-radius: 50px;\t\t\t\tbackground-color: #002e9b;\t\t\t\tposition: absolute;\t\t\t\tleft: 40%;\t\t\t\ttop: 30%;\t\t\t\tcolor: rgb(245, 223, 77);\t\t\t\tfont-size: 50px;\t\t\t\tfont-weight: bold;\t\t\t\ttext-align: center;\t\t\t\tline-height: 300px;\t\t\t\tdisplay: none;\t\t\t&#125;\t\t&lt;/style&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;input size=&quot;6&quot; id=&quot;input1&quot; /&gt;\t\t&lt;button onclick=&quot;enter()&quot;&gt;录入&lt;/button&gt;\t\t&lt;button onclick=&quot;startRoll()&quot;&gt;开始滚动&lt;/button&gt;\t\t&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;\t\t&lt;script type=&quot;text/javascript&quot;&gt;\t\t\tvar arr = new Array();\t\t\tvar timer = null;\t\t\tfunction enter() &#123;\t\t\t\tvar name = document.getElementById(&quot;input1&quot;).value;\t\t\t\tarr.push(name);\t\t\t\talert(&quot;录入成功！&quot;);\t\t\t\tdocument.getElementById(&quot;input1&quot;).value = &quot;&quot;;\t\t\t&#125;\t\t\tfunction startRoll() &#123;\t\t\t\tdocument.getElementById(&quot;div1&quot;).style.display = &quot;block&quot;;\t\t\t\tif (timer == null) &#123;\t\t\t\t\ttimer = window.setInterval(\t\t\t\t\t\tfunction() &#123;\t\t\t\t\t\t\tvar index = Math.floor(Math.random() * arr.length);\t\t\t\t\t\t\tdocument.getElementById(&quot;div1&quot;).innerText = arr[index];\t\t\t\t\t\t&#125;, 100);\t\t\t\t\twindow.setTimeout(\t\t\t\t\t\tfunction() &#123;\t\t\t\t\t\t\twindow.clearInterval(timer);\t\t\t\t\t\t\ttimer = null;\t\t\t\t\t\t&#125;, 5000);\t\t\t\t&#125;\t\t\t&#125;\t\t&lt;/script&gt;\t&lt;/body&gt;&lt;/html&gt;\n\nDAY17双色球抽奖（练习）&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;utf-8&quot;&gt;\t\t&lt;title&gt;&lt;/title&gt;\t\t&lt;style type=&quot;text/css&quot;&gt;\t\t\t#div1 &#123;\t\t\t\twidth: 300px;\t\t\t\theight: 300px;\t\t\t\ttext-align: center;\t\t\t\tbackground-color: #002e9b;\t\t\t\tcolor: rgb(245, 223, 77);\t\t\t\tfont-size: 80px;\t\t\t\tfont-weight: bold;\t\t\t\tline-height: 300px;\t\t\t\tborder-radius: 50px;\t\t\t\tposition: absolute;\t\t\t\tleft: 40%;\t\t\t\ttop: 30%;\t\t\t\tdisplay: none;\t\t\t&#125;\t\t\t#prize3,\t\t\t#prize2,\t\t\t#prize1 &#123;\t\t\t\tdisplay: none;\t\t\t&#125;\t\t&lt;/style&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;input id=&quot;input1&quot; size=&quot;6&quot;&gt;\t\t&lt;button onclick=&quot;info()&quot; id=&quot;info&quot;&gt;录入&lt;/button&gt;\t\t&lt;button onclick=&quot;change()&quot; id=&quot;change&quot;&gt;开始滚动&lt;/button&gt;\t\t&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;\t\t&lt;br /&gt;\t\t&lt;span id=&quot;prize3&quot;&gt;三等奖：&lt;/span&gt;\t\t&lt;br /&gt;\t\t&lt;span id=&quot;prize2&quot;&gt;二等奖：&lt;/span&gt;\t\t&lt;br /&gt;\t\t&lt;span id=&quot;prize1&quot;&gt;一等奖：&lt;/span&gt;\t\t&lt;/div&gt;\t&lt;/body&gt;\t&lt;script type=&quot;text/javascript&quot;&gt;\t\tlet arr1 = new Array();\t\tlet arr2 = new Array();\t\t//录入button\t\tfunction info() &#123;\t\t\talert(&quot;添加成功&quot;);\t\t\tif (document.getElementById(&quot;input1&quot;).value != &quot; &quot;) &#123;\t\t\t\tarr1.push(document.getElementById(&quot;input1&quot;).value);\t\t\t&#125;\t\t\tdocument.getElementById(&quot;input1&quot;).value = &quot; &quot;;\t\t&#125;\t\t//开始滚动button\t\tlet g;\t\tfunction change() &#123;\t\t\tdocument.getElementById(&quot;div1&quot;).style = &quot;display: block&quot;;\t\t\tdocument.getElementById(&quot;info&quot;).disabled = &quot;true&quot;;\t\t\tlet timer = window.setInterval(function() &#123;\t\t\t\t//随机生成0~arr.length长度单位的随机数\t\t\t\tg = random(arr1.length, 0);\t\t\t\tdocument.getElementById(&quot;div1&quot;).innerText = arr1[g];\t\t\t&#125;, 100)\t\t\t//定时器\t\t\twindow.setTimeout(function() &#123;\t\t\t\twindow.clearInterval(timer);\t\t\t\ttimeout();\t\t\t&#125;, 5000)\t\t&#125;\t\t//随机数调用，扩展\t\tfunction random(x, y) &#123;\t\t\tlet random = Math.floor(Math.random() * (y - x) + x);\t\t\treturn random;\t\t&#125;\t\t//奖项判断，三等奖3人，二等奖2人，一等奖1人\t\tlet i = 0\t\t//定时器结束时运行，防止浪费资源\t\tfunction timeout() &#123;\t\t\t//arr2.push(Number(document.getElementById(&quot;div1&quot;).innerText));\t\t\tarr2.push(arr1[g])\t\t\t//三等奖\t\t\tif (i &lt; 3) &#123;\t\t\t\tdocument.getElementById(&quot;prize3&quot;).style = &quot;display: block&quot;;\t\t\t\tdocument.getElementById(&quot;prize3&quot;).innerText += arr2[i] + &quot;;&quot;;\t\t\t&#125;\t\t\t//二等奖\t\t\telse if (i &gt; 2 &amp;&amp; i &lt; 5) &#123;\t\t\t\tdocument.getElementById(&quot;prize2&quot;).style = &quot;display: block&quot;;\t\t\t\tdocument.getElementById(&quot;prize2&quot;).innerText += arr2[i] + &quot;;&quot;;\t\t\t&#125;\t\t\t//一等奖\t\t\telse if (i == 5) &#123;\t\t\t\tdocument.getElementById(&quot;prize1&quot;).style = &quot;display: block&quot;;\t\t\t\tdocument.getElementById(&quot;prize1&quot;).innerText += arr2[i] + &quot;;&quot;;\t\t\t&#125;\t\t\telse&#123;\t\t\t\talert(&quot;请勿重复点击&quot;);\t\t\t\tdocument.getElementById(&quot;change&quot;).disabled = &quot;true&quot;;\t\t\t&#125;\t\t\tarr1.splice(g,1);\t\t\ti++;\t\t&#125;\t&lt;/script&gt;&lt;/html&gt;\n\n双色球抽奖（答案）&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;utf-8&quot; /&gt;\t\t&lt;title&gt;&lt;/title&gt;\t\t&lt;style type=&quot;text/css&quot;&gt;\t\t\tdiv&#123;\t\t\t\twidth: 300px;\t\t\t\theight: 300px;\t\t\t\tbackground-color: blue;\t\t\t\tborder-radius: 50px;\t\t\t\tposition: absolute;\t\t\t\tleft: 40%;\t\t\t\ttop: 30%;\t\t\t\tcolor: yellow;\t\t\t\tfont-size: 50px;\t\t\t\tfont-weight: bold;\t\t\t\ttext-align: center;\t\t\t\tline-height: 300px;\t\t\t\tdisplay: none;\t\t\t&#125;\t\t\tspan&#123;\t\t\t\tdisplay: none;\t\t\t&#125;\t\t&lt;/style&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;input size=&quot;6&quot; id=&quot;input1&quot;/&gt;\t\t&lt;button onclick=&quot;enter()&quot; id=&quot;btn1&quot;&gt;录入&lt;/button&gt;\t\t&lt;button onclick=&quot;rolling()&quot; id=&quot;btn2&quot;&gt;开始滚动&lt;/button&gt;&lt;br /&gt;\t\t&lt;span id=&quot;third_1&quot;&gt;三等奖&lt;/span&gt;&lt;span id=&quot;third_2&quot;&gt;&lt;/span&gt;&lt;br /&gt;\t\t&lt;span id=&quot;second_1&quot;&gt;二等奖&lt;/span&gt;&lt;span id=&quot;second_2&quot;&gt;&lt;/span&gt;&lt;br /&gt;\t\t&lt;span id=&quot;first_1&quot;&gt;一等奖&lt;/span&gt;&lt;span id=&quot;first_2&quot;&gt;&lt;/span&gt;&lt;br /&gt;\t\t&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;\t\t\t\t&lt;script type=&quot;text/javascript&quot;&gt;\t\t\tvar arr=new Array();\t\t\tvar count=0;\t\t\tfunction enter()&#123;\t\t\t\tvar name=document.getElementById(&quot;input1&quot;).value;\t\t\t\tarr.push(name);\t\t\t\talert(&quot;录入成功&quot;);\t\t\t\tdocument.getElementById(&quot;input1&quot;).value=&quot;&quot;;\t\t\t&#125;\t\t\tfunction rolling()&#123;\t\t\t\tdocument.getElementById(&quot;btn1&quot;).disabled=&quot;false&quot;;\t\t\t\tdocument.getElementById(&quot;btn2&quot;).disabled=&quot;false&quot;;\t\t\t\tdocument.getElementById(&quot;div1&quot;).style.display=&quot;block&quot;;\t\t\t\tvar index;\t\t\t\tvar timer=window.setInterval(\t\t\t\tfunction ()&#123;\t\t\t\t\tindex=Math.floor(Math.random()*arr.length);\t\t\t\t\tdocument.getElementById(&quot;div1&quot;).innerText=arr[index];\t\t\t\t&#125;\t\t\t\t,100);\t\t\t\twindow.setTimeout(\t\t\t\tfunction ()&#123;\t\t\t\t\tcount++;\t\t\t\t\twindow.clearInterval(timer);\t\t\t\t\tdocument.getElementById(&quot;btn2&quot;).disabled=&quot;&quot;;\t\t\t\t\tif(count&lt;=3)&#123;\t\t\t\t\t\tdocument.getElementById(&quot;third_1&quot;).style.display=&quot;block&quot;;\t\t\t\t\t\tdocument.getElementById(&quot;third_2&quot;).style.display=&quot;block&quot;;\t\t\t\t\t\tdocument.getElementById(&quot;third_2&quot;).innerText=document.getElementById(&quot;third_2&quot;).innerText+arr[index]+&quot;;&quot;;\t\t\t\t\t&#125;else if(count&lt;=5)&#123;\t\t\t\t\t\tdocument.getElementById(&quot;second_1&quot;).style.display=&quot;block&quot;;\t\t\t\t\t\tdocument.getElementById(&quot;second_2&quot;).style.display=&quot;block&quot;;\t\t\t\t\t\tdocument.getElementById(&quot;second_2&quot;).innerText=document.getElementById(&quot;second_2&quot;).innerText+arr[index]+&quot;;&quot;;\t\t\t\t\t&#125;else&#123;\t\t\t\t\t\tdocument.getElementById(&quot;first_1&quot;).style.display=&quot;block&quot;;\t\t\t\t\t\tdocument.getElementById(&quot;first_2&quot;).style.display=&quot;block&quot;;\t\t\t\t\t\tdocument.getElementById(&quot;first_2&quot;).innerText=document.getElementById(&quot;first_2&quot;).innerText+arr[index]+&quot;;&quot;;\t\t\t\t\t\tdocument.getElementById(&quot;btn2&quot;).disabled=&quot;false&quot;;\t\t\t\t\t&#125;\t\t\t\t\tarr.splice(index,1);\t\t\t\t\t\t\t\t\t&#125;\t\t\t\t,4000);\t\t\t\t\t\t\t\t\t\t&#125;\t\t&lt;/script&gt;\t\t\t&lt;/body&gt;&lt;/html&gt;\n\nDAY18随机数滚动&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;utf-8&quot;&gt;\t\t&lt;title&gt;随机数滚动&lt;/title&gt;\t\t&lt;style&gt;\t\t\t/* 标签选择器  */\t\t\tdiv &#123;\t\t\t\twidth: 300px;\t\t\t\theight: 300px;\t\t\t\tbackground-color: blue;\t\t\t\tborder-radius: 150px;\t\t\t\ttext-align: center;\t\t\t\tline-height: 300px;\t\t\t\tfont-size: 100px;\t\t\t\tcolor: yellowgreen;\t\t\t\tfont-weight: bold;\t\t\t&#125;\t\t&lt;/style&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;div id=&quot;div1&quot;&gt;00&lt;/div&gt;\t\t&lt;button onclick=&quot;start()&quot; id=&quot;btn1&quot;&gt;开始&lt;/button&gt;\t\t&lt;script type=&quot;text/javascript&quot;&gt;\t\t\tfunction start() &#123;\t\t\t\tdocument.getElementById(&quot;btn1&quot;).disabled = &quot;false&quot;;\t\t\t\tvar timer = window.setInterval(\t\t\t\t\tfunction() &#123;\t\t\t\t\t\tvar x = Math.floor(Math.random() * 99 + 1);\t\t\t\t\t\tdocument.getElementById(&quot;div1&quot;).innerText = x;\t\t\t\t\t\tif (x &lt; 10) &#123;\t\t\t\t\t\t\tdocument.getElementById(&quot;div1&quot;).innerText = &quot;0&quot; + x;\t\t\t\t\t\t&#125;\t\t\t\t\t&#125;, 100);\t\t\t\twindow.setTimeout(\t\t\t\t\tfunction() &#123;\t\t\t\t\t\twindow.clearInterval(timer);\t\t\t\t\t\tdocument.getElementById(&quot;btn1&quot;).disabled = &quot;&quot;;\t\t\t\t\t&#125;, 3000);\t\t\t&#125;\t\t&lt;/script&gt;\t&lt;/body&gt;&lt;/html&gt;\n\n秒表&#x2F;定时器（练习）&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;\t&lt;meta charset=&quot;utf-8&quot;&gt;\t&lt;title&gt;秒表&lt;/title&gt;\t&lt;style type=&quot;text/css&quot;&gt;\t\t#div1 &#123;\t\t\twidth: 200px;\t\t\theight: 50px;\t\t\tbackground-color: black;\t\t\tborder-radius: 20px;\t\t\tcolor: greenyellow;\t\t\ttext-align: center;\t\t\tline-height: 50px;\t\t\tfont-size: 30px;\t\t\tdisplay: table-cell;\t\t&#125;\t&lt;/style&gt;&lt;/head&gt;&lt;body&gt;\t&lt;div id=&quot;div1&quot;&gt;00:00:00:00&lt;/div&gt;\t&lt;br /&gt;\t&lt;button onclick=&quot;but_start()&quot;&gt;当前时间&lt;/button&gt;\t&lt;button onclick=&quot;but_start2()&quot;&gt;计时器&lt;/button&gt;\t&lt;button onclick=&quot;time_stop()&quot;&gt;暂停&lt;/button&gt;\t&lt;button onclick=&quot;time_reset()&quot;&gt;重置&lt;/button&gt;\t&lt;script type=&quot;text/javascript&quot;&gt;\t\t//当前时间\t\tlet timer = null;\t\tfunction but_start() &#123;\t\t\tif (timer == null) &#123;\t\t\t\ttimer = window.setInterval(function () &#123;\t\t\t\t\tms++;\t\t\t\t\tlet date = new Date();\t\t\t\t\tdocument.getElementById(&quot;div1&quot;).innerText = date.toLocaleTimeString() + &quot;:&quot; + showNum(ms);\t\t\t\t&#125;, 10)\t\t\t&#125;\t\t&#125;\t\t//计时器\t\tfunction but_start2() &#123;\t\t\tif (timer == null) &#123;\t\t\t\twatch_ms();\t\t\t\ttimer = window.setInterval(function () &#123;\t\t\t\t\tdocument.getElementById(&quot;div1&quot;).innerText = watch();\t\t\t\t&#125;, 10)\t\t\t&#125;\t\t&#125;\t\t//暂停\t\tfunction time_stop() &#123;\t\t\twindow.clearInterval(timer);\t\t\ttimer = null;\t\t\tms = null;\t\t&#125;\t\t//重置\t\tfunction time_reset() &#123;\t\t\tdocument.getElementById(&quot;div1&quot;).innerText = &quot;00:00:00:00&quot;;\t\t\twindow.clearInterval(timer);\t\t\twindow.clearInterval(time_ms);\t\t\ttimer = null;\t\t\ttime_ms = null;\t\t\ts = 0;\t\t\tmin = 0;\t\t\th = 0;\t\t\tms = 0;\t\t&#125;\t\tlet ms = 0; //毫秒\t\tlet s = 0; //秒\t\tlet min = 0; //分\t\tlet h = 0; //时\t\t//毫秒计时器\t\tlet time_ms = null;\t\tfunction watch_ms() &#123;\t\t\tif (time_ms == null) &#123;\t\t\t\ttime_ms = window.setInterval(function () &#123;\t\t\t\t\tms++;\t\t\t\t&#125;, 10)\t\t\t&#125;\t\t&#125;\t\t//秒表计数\t\tfunction watch() &#123;\t\t\tif (ms &gt;= 99) &#123;\t\t\t\ts++;\t\t\t\tms = 0;\t\t\t&#125;\t\t\tif (s == 60) &#123;\t\t\t\tmin++;\t\t\t\ts = 0;\t\t\t&#125;\t\t\tif (min == 60) &#123;\t\t\t\th++;\t\t\t\tmin = 0;\t\t\t&#125;\t\t\treturn showNum(h) + &quot;:&quot; + showNum(min) + &quot;:&quot; + showNum(s) + &quot;:&quot; + showNum(ms);\t\t&#125;\t\t//封装\t\tfunction showNum(i) &#123;\t\t\tif (i &lt; 10) &#123;\t\t\t\treturn &quot;0&quot; + i;\t\t\t&#125;\t\t\t//判断为毫秒数\t\t\tif (i &gt;= 99) &#123;\t\t\t\tms = 0;\t\t\t&#125;\t\t\treturn i;\t\t&#125;\t&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n简单前端验证码（练习）&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;utf-8&quot;&gt;\t\t&lt;title&gt;&lt;/title&gt;\t\t&lt;style type=&quot;text/css&quot;&gt;\t\t&lt;/style&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;input id=&quot;input1&quot; size=&quot;12&quot;/&gt;\t\t&lt;button id = &quot;btn1&quot; onclick=&quot;btn1()&quot;&gt;发送&lt;/button&gt;\t\t&lt;script type=&quot;text/javascript&quot;&gt;\t\t\tlet x = 10;\t\t\tlet code = null;\t\t\tfunction btn1()&#123;\t\t\t\tdocument.getElementById(&quot;btn1&quot;).disabled = &quot;false&quot;;\t\t\t\twindow.setTimeout(function()&#123;\t\t\t\t\tcode = showNum(random(0,999999));\t\t\t\t\talert(code)\t\t\t\t&#125;,5000);\t\t\t\tlet timer = window.setInterval(function()&#123;\t\t\t\t\tx--;\t\t\t\t\tdocument.getElementById(&quot;btn1&quot;).innerText = &quot;重新发送：&quot; + x;\t\t\t\t\tif(x == 0)&#123;\t\t\t\t\t\twindow.clearInterval(timer);\t\t\t\t\t\tdocument.getElementById(&quot;btn1&quot;).innerText = &quot;发送&quot;;\t\t\t\t\t\tdocument.getElementById(&quot;btn1&quot;).disabled = &quot;&quot;;\t\t\t\t\t\tcode = showNum(random(0,999999));\t\t\t\t\t\tx = 20;\t\t\t\t\t&#125;\t\t\t\t&#125;,1000)\t\t\t\t\t\t\t&#125;\t\t\t//随机数调用\t\t\tfunction random(max,min) &#123;\t\t\t\treturn Math.floor(Math.random() * (max - min) + min);\t\t\t&#125;\t\t\t//回车事件\t\t\tdocument.onkeydown = function(e)&#123;\t\t\t\tlet ev = document.all ? window.event : e;\t\t\t\tif(ev.keyCode == 13 &amp;&amp; code != null)&#123;\t\t\t\t\tif(code == document.getElementById(&quot;input1&quot;).value)&#123;\t\t\t\t\t\talert(&quot;验证码正确&quot;)\t\t\t\t\t&#125;\t\t\t\t\telse&#123;\t\t\t\t\t\talert(&quot;验证码错误&quot;)\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t&#125;\t\t\t//封装\t\t\tfunction showNum(i)&#123;\t\t\t\tif (i &lt;100000)&#123;\t\t\t\t\treturn &quot;0&quot; + i;\t\t\t\t&#125;\t\t\t\tif (i &lt;10000)&#123;\t\t\t\t\treturn &quot;00&quot; + i;\t\t\t\t&#125;\t\t\t\tif (i &lt;1000)&#123;\t\t\t\t\treturn &quot;000&quot; + i;\t\t\t\t&#125;\t\t\t\tif (i &lt;100)&#123;\t\t\t\t\treturn &quot;0000&quot; + i;\t\t\t\t&#125;\t\t\t\tif (i &lt;10)&#123;\t\t\t\t\treturn &quot;00000&quot; + i;\t\t\t\t&#125;\t\t\t\treturn i;\t\t\t&#125;\t\t&lt;/script&gt;\t&lt;/body&gt;&lt;/html&gt;\n\n获取当前系统时间（答案）万鹏:&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;utf-8&quot;&gt;\t\t&lt;title&gt;获取当前系统时间&lt;/title&gt;\t\t&lt;style&gt;\t\t\tdiv&#123;\t\t\t\twidth: 200px;\t\t\t\theight: 50px;\t\t\t\tbackground-color: black;\t\t\t\tborder-radius: 30px;\t\t\t\tcolor: yellow;\t\t\t\ttext-align: center;\t\t\t\tline-height: 50px;\t\t\t\tfont-size: 30px;\t\t\t&#125;\t\t&lt;/style&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;div id=&quot;div1&quot;&gt;00:00:00&lt;/div&gt;\t\t&lt;br /&gt;\t\t&lt;button onclick=&quot;stop()&quot; &gt;暂停&lt;/button&gt;\t\t&lt;button onclick=&quot;start()&quot; id=&quot;btn1&quot;&gt;开始&lt;/button&gt;\t\t&lt;script type=&quot;text/javascript&quot;&gt;\t\t\tdocument.getElementById(&quot;btn1&quot;).disabled=&quot;false&quot;;\t\t\tfunction timeChange()&#123;\t\t\t\tvar myDate=new Date();\t\t\t\tvar hour=myDate.getHours();\t\t\t\tvar minute=myDate.getMinutes();\t\t\t\tvar second=myDate.getSeconds();\t\t\t\tif(hour&lt;10)&#123;\t\t\t\t\thour=&quot;0&quot;+hour;\t\t\t\t&#125;\t\t\t\tif(minute&lt;10)&#123;\t\t\t\t\tminute=&quot;0&quot;+minute;\t\t\t\t&#125;\t\t\t\tif(second&lt;10)&#123;\t\t\t\t\tsecond=&quot;0&quot;+second;\t\t\t\t&#125;\t\t\t\tdocument.getElementById(&quot;div1&quot;).innerText=hour+&quot;:&quot;+minute+&quot;:&quot;+second;\t\t\t&#125;\t\t\tvar timer=window.setInterval(timeChange,1000);\t\t\tfunction stop()&#123;\t\t\t\twindow.clearInterval(timer);\t\t\t\tdocument.getElementById(&quot;btn1&quot;).disabled=&quot;&quot;;\t\t\t&#125;\t\t\tfunction start()&#123;\t\t\t\ttimer=window.setInterval(timeChange,1000);\t\t\t&#125;\t\t\t\t\t&lt;/script&gt;\t&lt;/body&gt;&lt;/html&gt;\n\nPS:2022年9月27日00点23分完毕,其实四天前就完事了，不小心鸽了&#x3D; &#x3D;\n","categories":["WebFrontend"],"tags":["office","javascript","html","css"]},{"title":"Hybrid技术-Flutter介绍","url":"/2022/08/13/WebFrontend/%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8/Hybrid%E6%8A%80%E6%9C%AF-Flutter%E4%BB%8B%E7%BB%8D/","content":"Hybrid技术\nhybrid译为中文是“混合”的意思，是一种原生APP和HTML5混合开发的技术。\n\n 在前端移动端开发中，到现在阶段主要有三大潮流\n\n原生APP开发(以Android和iOS为主导)\nHTML5 WebAPP开发\n原生APP和HTML5混合开发，也就是hybrid技术\n\nHybrid主要分为三类：\n\nH5 + 原生：Cordova，lonic，微信小程序\nJavaScript开发+原生渲染：React Native、Wex、快应用\n自绘UI + 原生：QT for mobile，Flutter\n\n\n\n什么是原生开发?原生应用程序是指某一个移动平台（比如iOS或者Android）所特有的应用，使用相应平台支持的开发工具和语言，并直接调用系统提供的SDK API。比如Android原生应用是指使用Java或者Kotlin语言直接调用Android SDK开发的应用程序；而iOS原生应用就是指通过Objective-C或Swift语言直接调用iOS SDK开发的应用程序\nFlutter介绍Flutter是Google推出并开源的移动应用开发UI框架，主打跨平台、高保真、高性能。开发者可以通过Dart语言开发App，一套代码同时运行在多个平台。Flutter提供了丰富的组件、接口，开发者可以很快地为Flutter添加Native扩展\nJIT和AOTJIT既Just-in-time，动态（即时）编译，边运行边编译。\n优点：\n\n\n可以根据当前硬件情况实时编译生成最优机器指令\n可以根据当前程序的运行情况生成最优的机器指令序列\n当程序需要支持支持动态链接时，只能使用JIT\n可以根据进程中内存的实际情况调整代码，使内存能够更充分的利用\n\n\n缺点：\n\n\n编译需要占用运行时资源，会导致进程卡顿\n由于编译时间需要占用运行时间，对于某些代码的编译优化不能完全支持，需要在程序流畅和编译时间之间做权衡\n在编译准备和识别频繁使用的方法需要占用时间，使得初始编译不能达到最高性能\n\n\nAOT即Ahead Of Time，指运行前编译。\n优点：\n\n\n在程序运行前编译，可以避免在运行时的编译性能消耗和内存消耗\n可以在程序运行初期就达到最高性能\n可以显著的加快程序的启动\n\n\n缺点：\n\n\n在程序运行前编译会使程序安装的时间增加\n牺牲Java的一致性\n将提前编译的内容保存会占用更多的外\n\n\n关于DartDart是由谷歌开发的计算机编程语言，可以用于web、服务器、移动程序和物联网领域的开发。\nDart诞生于2011年，号称要取代JavaScript。但是过去几年中一直不温不火。直到Flutter的出现被人们重新重视起来，要学Flutter必须的会Dart\n开发效率高Dart运行时和编译器支持Flutter的两个关键特性的组合：\n\n基于JIT的快速开发周期；\n基于AOT的发布包\n\n高性能Flutter提供流畅、高保真的UI体验。\n快速内存分配Flutter框架使用函数式流，这使得它在很大程度上依赖于低层的内存分配器。\n类型安全和空安全由于Dart是类型安全的语言，且2.12版本后也支持了空安全特性，所以Dart支持静态类型检测，可以在编译前发现一些类型的错误，并排除潜在问题。\n","categories":["WebFrontend"],"tags":["hybrid"]},{"title":"js解构赋值","url":"/2022/08/18/WebFrontend/JavaScript/js%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/","content":"解构赋值结构赋值:ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构\n一. 数组的结构赋值1. 理解解构赋值非常有用,特别在数据交互,ajax的时候,非常完美.\n在ES 5中,我们想定义多个变量,同时各这些变量赋值我们可以多次声明,也可以一次声明\n// 多次声明var a = 12;var b = 5;var c = 6;// 一次声明过个变量var a = 12,\tb = 5,\tc = 6;\n\n在ES 6中,我们也可以采用一次声明多个变量\nlet a = 12,\tb = 5,\tc = 6;console.log(a,b,b);\n\n但是你会发现很散,不够整齐划一,有的时候 我们需要把值存在数组中.\nlet arr = [12,5,6];console.log(arr[0],arr[1],arr[2])// 你会发现不好用,还不如console a,b,c呢// 我就想console.log(a,b,c);怎么办let [a,b,c] = [12,5,6];  //右边是你的数据,左边是你的结构console.log(a,b,c);    // 12,5,6\n\n这就是解构赋值.\n本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。\n\n注意:\n左右两边,结构格式要保持一致\n\n\n比如:\nlet [a,b,c] = [12,[5,6]];  //右边是你的数据,左边是你的解构console.log(a,b,c);   // 此时结构不对,a就是12 b是一个数组[5,6], c没有解构到值就是undefined//如果希望数据对应,则需要结构一样let [a,[b,c]] = [12,[5,6]];console.log(a,b,c);   //12 5 6let [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3let [ , , third] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];third // &quot;baz&quot;let [x, , y] = [1, 2, 3];x // 1y // 3\n\n2. 不成功的解构赋值如果解构不成功，变量的值就等于undefined。\nlet [foo] = [];let [bar, foo] = [1];//foo 都是undefined\n\n需要被赋值的数量少于接收值的变量\n3. 不完全解构另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。\nlet [x, y] = [1, 2, 3];x // 1y // 2let [a, [b], d] = [1, [2, 3], 4];a // 1b // 2d // 4//上面两个例子，都属于不完全解构，但是可以成功。\n\n简单理解,就是要被赋值的值数量多于接收值变量的数量\n4. 如果模式不匹配,那么会报错// 报错let [foo] = 1;let [foo] = false;let [foo] = NaN;let [foo] = undefined;let [foo] = null;let [foo] = &#123;&#125;;\n\n5. 默认值我们刚说过,我们如果定义的变量比较多,而又没有给这个变量赋值,那么这个变量就是undefined,但是有的时候我们不希望他是undefined,我们希望他是一个值\n解构赋值允许指定默认值。\n正常靠谱的后台都会给值,但是就怕不靠谱的后台,怎么办,所有我想要定义一个默认值,后台有用后台的值,没有,用默认值,\nlet [a,b,c = &quot;暂无数据&quot;] = [&quot;aa&quot;,&quot;bb&quot;];  console.log(a,b,c);    //aa bb 暂无数据// 发现此时c就是默认值&quot;暂无数据&quot;// 如果有值,就使用后台的值let [a,b,c = &quot;暂无数据&quot;] = [&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;];  console.log(a,b,c);    // aa bb cc// 如果后台穿过来的是undefined,还是表示没有值,用默认值,let [a,b,c = &quot;暂无数据&quot;] = [&quot;aa&quot;,&quot;bb&quot;,undefined];  console.log(a,b,c);    //aa bb 暂无数据// 如果后台传过来的是一个null,表示有值,null表示一个空对象let [a,b,c = &quot;暂无数据&quot;] = [&quot;aa&quot;,&quot;bb&quot;,null];  console.log(a,b,c);    //aa bb null\n\n注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格等于undefined，默认值是不会生效的。\n5.1 如果默认值是一个表达式如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。\nfunction f() &#123;  console.log(&#x27;aaa&#x27;);&#125;let [x = f()] = [1];//等价于let x;if ([1][0] === undefined) &#123;  x = f();&#125; else &#123;  x = [1][0];&#125;\n\n5.2 默认值可以引用解构赋值的其他变量,前提是该变量必须是已经声明的\nlet [x = 1, y = x] = [];     // x=1; y=1let [x = 1, y = x] = [2];    // x=2; y=2let [x = 1, y = x] = [1, 2]; // x=1; y=2let [x = y, y = 1] = [];     // ReferenceError//上面最后一个表达式之所以会报错，是因为x用到默认值y时，y还没有声明\n\n6. 利用解构赋值交换两个值交换两个值的位置\nlet a = 12;let b = 5;[a,b] = [b,c];console.log(a,b);  //5 12// 这里利用数组有序的特性和解构赋值的方式,交互两个数\n\n二. 对象的结构赋值1. 对象解构赋值解构不仅可以用于数组，还可以用于对象。\nlet json = &#123;    name: &quot;wuwei&quot;,    age: 18,    sex: &quot;男&quot;&#125;let &#123;name,age,sex&#125; = json;console.log(name,age,sex);  // wuwei 18 男\n\n2. 对象解构赋值属性名必须相同对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。\n// 这里解构的属性名必须和对象的属性名相同,否则解不出来就全是undefinedlet &#123;nam,ag,se&#125; = json;console.log(nam,ag,se);  // undefined undefined undefined\n\n3. 自定义变量名与属性名不同// 如果想自己定义更改属性名可以如下操作let &#123;name:nam,age:ag,sex:se&#125; = json; // 这样依然可以改属性名,并打印了解构的值console.log(nam,ag,se);  //wuwei 18 男\n\n也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。\n实际上说明，对象的解构赋值是下面形式的简写\nlet &#123;name:name,age:age,sex:sex&#125; = json; // 这样依然可以改属性名,并打印了解构的值console.log(nam,ag,se);  //wuwei 18 男\n\n4. 解构可以用于嵌套结构let obj = &#123;  p: [    &#x27;Hello&#x27;,    &#123; y: &#x27;World&#x27; &#125;  ]&#125;;let &#123; p: [x, &#123; y &#125;] &#125; = obj;x // &quot;Hello&quot;y // &quot;World&quot;\n\n5. 对象的解构赋值也可以指定默认值var &#123;x = 3&#125; = &#123;&#125;;x // 3var &#123;x, y = 5&#125; = &#123;x: 1&#125;;x // 1y // 5var &#123;x: y = 3&#125; = &#123;&#125;;y // 3var &#123;x: y = 3&#125; = &#123;x: 5&#125;;y // 5var &#123; message: msg = &#x27;Something went wrong&#x27; &#125; = &#123;&#125;;msg // &quot;Something went wrong&quot;\n\n默认值生效的条件是，对象的属性值严格等于undefined。\nvar &#123;x = 3&#125; = &#123;x: undefined&#125;;x // 3var &#123;x = 3&#125; = &#123;x: null&#125;;x // null\n\n6. 数组也可以按照对象的方式解构由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。\nlet arr = [1, 2, 3];let &#123;0 : first, [arr.length - 1] : last&#125; = arr;first // 1last // 3\n\n7. 注意点:let &#123;a&#125; = &#123;a : &quot;apple&quot;&#125;;console.log(a);  //apple// 这么写没什么问题// 但是有人喜欢先定义,先定义一个变量a,在去解构let a; &#123;a&#125; = &#123;a : &quot;apple&quot;&#125;;console.log(a);  //报错//Uncaught SyntaxError: Unexpected token =// 你会发现报语法所处,因为 &#123;a&#125;是不是有块级作用域啊,=赋值就是有问题的// 我们可以加括变成表达式let a; (&#123;a&#125; = &#123;a : &quot;apple&quot;&#125;);console.log(a);  //apple// 发现这么写没任何问题,但是这么写的意义在哪里了,所有强烈不建议你们这么写\n\n因为这个花括号被当成解构,一旦用不好,就会被当成块作用域\n例子:function getPos()&#123;\t//....    return &#123;\t\tleft:10,        bottom:20\t&#125;&#125;let &#123;left,bottom&#125; = getPos();console.log(left,bottom);  // 10, 20// 这里不敢用top,因为全局的top会被当成window对象.所以这个时候就取名就显得格外重要function getPos()&#123;\t//....    return &#123;\t\tleft:10,        top:20\t&#125;&#125;let &#123;left,top:t&#125; = getPos();console.log(left,t); //10 20// 如果使用使用top,这里在全局环境下可以使用解构自己定义名字的方式\n\n三. 字符串的解构赋值const [a, b, c, d, e] = &#x27;hello&#x27;;a // &quot;h&quot;b // &quot;e&quot;c // &quot;l&quot;d // &quot;l&quot;e // &quot;o&quot;\n\n字符串也可以看做是类数组,因为有length属性\n类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。\nlet &#123;length : len&#125; = &#x27;hello&#x27;;len // 5\n\n说明类数组可以按照正常的数组和对象方式解构\n四.函数参数的解构赋值:1. 函数参数的解构function add([a,b])&#123;  return a+b;&#125;add([2,3])//5function fn(&#123;a,b&#125;)&#123;\tconsole.log(a,b); //1 2&#125;fn(&#123;\ta: 1,    b: 2&#125;)\n\n2. 函数参数解构的默认值函数参数的解构也可以使用默认值。\nfunction move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123;  return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, 0]move(&#123;&#125;); // [0, 0]move(); // [0, 0]\n\n3. 参数默认值的注意事项function move(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123;  return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, undefined]move(&#123;&#125;); // [undefined, undefined]move(); // [0, 0]\n\n上面代码是为函数move的参数指定默认值，而不是为变量x和y指定默认值，所以会得到与前一种写法不同的结果。\n五. 数值和布尔值的解构赋值解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。\nlet &#123;toString: s&#125; = 123;s === Number.prototype.toString // truelet &#123;toString: s&#125; = true;s === Boolean.prototype.toString // true\n\n六. 关于圆括号的影响解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。\n由此带来的问题是，如果模式中出现圆括号怎么处理。ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。\n但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。\n1. 不能使用圆括号的情况以下三种解构赋值不得使用圆括号。\n1.1 变量声明语句// 全部报错let [(a)] = [1];let &#123;x: (c)&#125; = &#123;&#125;;let (&#123;x: c&#125;) = &#123;&#125;;let &#123;(x: c)&#125; = &#123;&#125;;let &#123;(x): c&#125; = &#123;&#125;;let &#123; o: (&#123; p: p &#125;) &#125; = &#123; o: &#123; p: 2 &#125; &#125;;\n\n1.2 函数的参数函数参数也属于变量声明，因此不能带有圆括号。\n// 报错function f([(z)]) &#123; return z; &#125;// 报错function f([z,(x)]) &#123; return x; &#125;\n\n1.3 赋值语句的模式// 全部报错(&#123; p: a &#125;) = &#123; p: 42 &#125;;([a]) = [5];//上面代码将整个模式放在圆括号之中，导致报错。// 报错[(&#123; p: a &#125;), &#123; x: c &#125;] = [&#123;&#125;, &#123;&#125;];\n\n2. 可以使用圆括号的情况可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。\n[(b)] = [3]; // 正确(&#123; p: (d) &#125; = &#123;&#125;); // 正确[(parseInt.prop)] = [3]; // 正确\n\n上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是p，而不是d；第三行语句与第一行语句的性质一致。\n七.解构的用途\n除了可以一次定义多个变量\n还可以让函数返回多个值\n可以方便地让函数的参数跟值对应起来\n提取json数据\n函数参数的默认值\n\n八.函数默认值","categories":["WebFrontend"],"tags":["javascript"]},{"title":"js懒加载","url":"/2022/08/26/WebFrontend/JavaScript/js%E6%87%92%E5%8A%A0%E8%BD%BD/","content":"什么是懒加载图片懒加载就是延迟加载，因为浏览器可视范围是有限的，所以网页的内容都是需要进行滚动才能完成浏览，既然要滚动到网页下面才能浏览到看不见的图片。\n第一个方法：事件监听\n监听scroll这个事件，鼠标滚动就触发，因此我们需要知道两个参数。首先是窗口显示区的高度window.innerHeight,以及图片到视窗上边的距离（高度）getBoundingClientRect().top。\n\n如果图片还未能看见，也就是说图片距离视窗的距离大于窗口显示区的高度。\n如果图片能看见，也就是说图片距离视窗的距离小于窗口显示区的高度。\n代码实现&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;utf-8&quot;&gt;\t\t&lt;title&gt;未遭拒绝的成功决不会长久。&lt;/title&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;p&gt;把脾气拿出来，那叫本能；把脾气压回去，才叫本事。&lt;/p&gt;\t\t&lt;p&gt;人只要不失去方向，就不会失去自我。&lt;/p&gt;\t\t&lt;p&gt;人们痛恨的不是改变，而是被改变。&lt;/p&gt;\t\t&lt;p&gt;昨日的成功经验与辉煌可能是明天成功的阻碍。&lt;/p&gt;\t\t&lt;p&gt;对于幸运者来说，一生都是短暂的；对于不幸者来说，一夜都是漫长的。&lt;/p&gt;\t\t&lt;p&gt;不要着急，不要害怕，一步一个脚印，踩出自我的阳关大道。&lt;/p&gt;\t\t&lt;p&gt;你说那里有你的梦想，你说只要你足够努力就能成功。&lt;/p&gt;\t\t&lt;p&gt;只要是辛勤的蜜蜂，在生活的广阔原野里，到处都能够找到蜜源。&lt;/p&gt;\t\t&lt;p&gt;拼命去争取成功，但不要期望一定会成功。&lt;/p&gt;\t\t&lt;p&gt;这个社会，是赢家通吃，输者一无所有，社会，永远都是只以成败论英雄。&lt;/p&gt;\t\t&lt;p&gt;生命的多少用时间计算，生命的价值用贡献计算。&lt;/p&gt;\t\t&lt;p&gt;愿我们每个人都能深谙其道，也但愿我们每个人有时也都能忍耐一下。&lt;/p&gt;\t\t&lt;p&gt;把脾气拿出来，那叫本能；把脾气压回去，才叫本事。&lt;/p&gt;\t\t&lt;p&gt;人只要不失去方向，就不会失去自我。&lt;/p&gt;\t\t&lt;p&gt;人们痛恨的不是改变，而是被改变。&lt;/p&gt;\t\t&lt;p&gt;昨日的成功经验与辉煌可能是明天成功的阻碍。&lt;/p&gt;\t\t&lt;p&gt;对于幸运者来说，一生都是短暂的；对于不幸者来说，一夜都是漫长的。&lt;/p&gt;\t\t&lt;p&gt;不要着急，不要害怕，一步一个脚印，踩出自我的阳关大道。&lt;/p&gt;\t\t&lt;p&gt;你说那里有你的梦想，你说只要你足够努力就能成功。&lt;/p&gt;\t\t&lt;p&gt;只要是辛勤的蜜蜂，在生活的广阔原野里，到处都能够找到蜜源。&lt;/p&gt;\t\t&lt;p&gt;拼命去争取成功，但不要期望一定会成功。&lt;/p&gt;\t\t&lt;p&gt;这个社会，是赢家通吃，输者一无所有，社会，永远都是只以成败论英雄。&lt;/p&gt;\t\t&lt;p&gt;生命的多少用时间计算，生命的价值用贡献计算。&lt;/p&gt;\t\t&lt;p&gt;愿我们每个人都能深谙其道，也但愿我们每个人有时也都能忍耐一下。&lt;/p&gt;\t\t&lt;p&gt;把脾气拿出来，那叫本能；把脾气压回去，才叫本事。&lt;/p&gt;\t\t&lt;p&gt;人只要不失去方向，就不会失去自我。&lt;/p&gt;\t\t&lt;p&gt;人们痛恨的不是改变，而是被改变。&lt;/p&gt;\t\t&lt;p&gt;昨日的成功经验与辉煌可能是明天成功的阻碍。&lt;/p&gt;\t\t&lt;p&gt;对于幸运者来说，一生都是短暂的；对于不幸者来说，一夜都是漫长的。&lt;/p&gt;\t\t&lt;p&gt;不要着急，不要害怕，一步一个脚印，踩出自我的阳关大道。&lt;/p&gt;\t\t&lt;p&gt;你说那里有你的梦想，你说只要你足够努力就能成功。&lt;/p&gt;\t\t&lt;p&gt;只要是辛勤的蜜蜂，在生活的广阔原野里，到处都能够找到蜜源。&lt;/p&gt;\t\t&lt;p&gt;拼命去争取成功，但不要期望一定会成功。&lt;/p&gt;\t\t&lt;p&gt;这个社会，是赢家通吃，输者一无所有，社会，永远都是只以成败论英雄。&lt;/p&gt;\t\t&lt;p&gt;生命的多少用时间计算，生命的价值用贡献计算。&lt;/p&gt;\t\t&lt;p&gt;愿我们每个人都能深谙其道，也但愿我们每个人有时也都能忍耐一下。&lt;/p&gt;\t\t&lt;img data-src=&quot;img/1.webp&quot; /&gt;\t\t&lt;br /&gt;\t\t&lt;img data-src=&quot;img/2.webp&quot; /&gt;\t\t&lt;br /&gt;\t\t&lt;img data-src=&quot;img/3.webp&quot; /&gt;\t\t&lt;script&gt;\t\t\tconst images = document.querySelectorAll(&#x27;img&#x27;); //获取所有image标签\t\t\twindow.addEventListener(&#x27;scroll&#x27;, (e) =&gt; &#123; //滚动事件\t\t\t\t//判断每张图片的位置是否出现在可视区域，使用forEach来进行遍历\t\t\t\timages.forEach(image =&gt; &#123;\t\t\t\t\t//每次遍历的时候我们都获取每张图片到顶部的距离,并且进行if判断\t\t\t\t\tconst imageTop = image.getBoundingClientRect().top;\t\t\t\t\t//如果图片距离视窗顶部的距离小于窗口显示区的高度，使得图片可以进行加载\t\t\t\t\tif(imageTop &lt; window.innerHeight)&#123;\t\t\t\t\t\t//html部分：如果用户没滚到指定的位置，我们需要不加载图片，简单的方式使用自定义属性，使用data-*来进行表示\t\t\t\t\t\t//html部分：因此我们可以把src属性改为data-src，这样就相当于不知道要在哪里下载这些图片了\t\t\t\t\t\tconst data_src = image.getAttribute(&#x27;data-src&#x27;)//获取刚刚自定义属性\t\t\t\t\t\t//然后把这个自定义属性赋值给原本的src属性\t\t\t\t\t\timage.setAttribute(&#x27;src&#x27;, data_src);\t\t\t\t\t&#125;;\t\t\t\t\tconsole.log(&#x27;scroll触发&#x27;);\t\t\t\t&#125;);\t\t\t&#125;);\t\t&lt;/script&gt;\t&lt;/body&gt;&lt;/html&gt;\n\n我们打开控制台的Network选项，并勾选disable cache，也就是禁止缓存，然后是Fast 3G，也就是比较慢的网络环境来测试恶略的网络环境\n\n现在我们看到加载内容里面没有图片，因为图片还没有出现在可视范围，当我们滚到图片区域，可以看到图片开始进行在加载了，也基本实现了懒加载的功能\n\n虽然实现了懒加载，但是从控制台查看发现滚动事件触发了相当多次，页面加载很多内容就会导致任务的堆积，即使图片已经加载了还是会不断触发事件，非常消耗资源。因此目前最推荐使用的方法还是IntersectionObservers。\n什么是IntersectionObservers？\nIntersectionObservers（交叉观察）也就是目标元素和可视化窗口会产生交叉区域。IntersectionObservers是浏览器提供的构造函数，我们可以直接拿来使用（部分浏览器不兼容）。\n既然是构造函数，所以需要new一个实例，我们可以用observer来表示实例，observer实例可以理解为一个用于观察的实例\nconst observer = new IntersectionObservers\n\n比如把observer实例想象为一个拿着望远镜的人，当这个人拿起望远镜就是进行观察。拿起望远镜就是使用了观察这个动作，也可以说是方法。我们就用observer.observe(DOM节点)来表示，具体要观察哪个DOM节点就在括号里面填写就行了。\n当我们不用望远镜观察的时候，也就是一个取消的动作，一个取消的方法，就用observer.unobserve(DOM节点)来表示,这样我们就不用进行不断观察，因为图片已经被加载出来就没有必要观察了，实例可以进行开始和结束观察DOM节点,但是我们在观察到目标DOM节点的时候需要进行相应的动作，一般来说我们就需要函数来封装这些动作。\n\n为此IntersectionObservers接收两个参数；第一个参数是一个回调函数，既然是回调函数就需要触发条件然后来执行的，这个回调函数一般触发两次，目标元素能看见触发一次，看不见又触发一次，有了这些基本概念就可以进行代码操作了；\nconst images = document.querySelectorAll(&#x27;img&#x27;); //获取所有image标签\t\t\tconst callback = () =&gt; &#123;\t\t\t\tconsole.log(&#x27;看见了触发，看不见了再触发&#x27;)\t\t\t&#125;;\t\t\t//使用IntersectionObserver来创建一个实例，并且传入参数callback\t\t\tconst observer = new IntersectionObserver(callback);\t\t\timages.forEach(image =&gt;&#123;\t\t\t\t//使用forEach进行遍历,在每次循环的时候使用observer实例的observe方法来观察每一个img节点\t\t\t\tobserver.observe(image);\t\t\t&#125; );\n\n现在我们在控制台试着上下滚动，因为没设置显示图片但是预留了图片的区域，每次进入或者离开图片区域都会触发这个回调函数。\nconst images = document.querySelectorAll(&#x27;img&#x27;); //获取所有image标签const callback = entries =&gt; &#123;\tconsole.log(entries)&#125;;\n\n回调函是接收一个参数的，这个参数是一个数组。我们用entries来表示这个数组，并且在控制台输出entries，因为有三张图片，所以数组的长度为3；\n\n既然是数组我们依旧需要进行遍历，使用forEach来进行遍历，并且输出每一次触发的细节。\nconst callback = entries =&gt; &#123;    entries.forEach(entry =&gt; &#123;        console.log(entry);    &#125;);&#125;;\n\n\n这一次我们重点看一看数组里面的isIntersecting属性，从字面意思来看就是”是否交叉“，也就是是否进行到可视区域。还没滚动之前是false，滚动到图片区域isIntersecting属性就变成了true，有这个元素我们就可以判断该次触发回调函数时是否已经观察到了图片，从中可以看到控制台每次触发了三次回调函数。\n可以使用target属性查看目标元素\nhttps://www.bilibili.com/video/BV1FU4y157Li?spm_id_from=333.337.search-card.all.click&amp;vd_source=1272b02e7a60d7fb8d81dfcdf529184e\n","categories":["WebFrontend"],"tags":["javascript"]},{"title":"BootStrap","url":"/2022/08/05/WebFrontend/UI/BootStrap/","content":"BootStrapBootStrap 介绍Bootstrap是一套现成的CSS样式集合。\nBootStrap是最受欢迎的HTML、CSS和JS框架，用于开发响应式布局、移动设备优先的WEB项目。\nBootStrap 特点\n简洁、直观、强悍的前端开发框架，html、css、JavaScript工具集，让web开发更迅速，简单。\n基于html5、css3的bootstrap，具有大量的诱人特性：友好的学习曲线，卓越的兼容性，响应式设计，12列格网，样式向导文档。\n自定义jQuery插件，完整的类库，bootstrap3基于Less，bootstrap4基于Sass的CSS预处理技术\nBootstrap响应式布局设计，让一个网站可以兼容不同分辨率的设备。Bootstrap响应式布局设计，给用户提供更好的视觉使用体验。\n丰富的组件\n\n下载与使用\n下载：https://getbootstrap.com/\n\n下载完成后\n拷贝dist&#x2F;css中的bootstrap.min.css到项目css中\n拷贝dist&#x2F;js中的bootstrap.min.js到项目的js中\n\n下载jQuery.js\n\n在html模板为\n&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;utf-8&quot;&gt;\t\t&lt;title&gt;Bootstrap的HTML标准模板&lt;/title&gt;\t\t&lt;!--\t\t\tviewport表示用户是否可以缩放画面；\t\t\twidth指定视区的逻辑宽度；\t\t\tdevice-width只是视区宽度应为设备的屏幕宽度；\t\t\tinitial-scale指令用于设置web页面的初始缩放比例\t\t\tinitial-scale=1则将显示未经缩放的web文档\t\t--&gt;\t\t&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1则将显示未经缩放的web文档=1.0&quot;&gt;\t\t&lt;!-- 载入Bootstrap 的 css --&gt;\t\t&lt;link href=&quot;css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;/&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;h1&gt;Hello, world!&lt;/h1&gt;\t\t&lt;!-- jQuery (Bootstrap 的 JavaScript 插件需要引入 jQuery) --&gt;\t\t&lt;script src=&quot;https://code.jquery.com/jquery.js&quot;&gt;&lt;/script&gt;\t\t&lt;!-- 包括所有已编译的插件 --&gt;\t\t&lt;script src=&quot;js/bootstrap.min.js&quot;&gt;&lt;/script&gt;\t&lt;/body&gt;&lt;/html&gt;\n\n常规\n&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;utf-8&quot;&gt;\t\t&lt;title&gt;&lt;/title&gt;\t\t&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1则将显示未经缩放的web文档=1.0&quot;&gt;\t\t&lt;link href=&quot;bootstrap/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;/&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;h1&gt;Hello, world!&lt;/h1&gt;\t\t&lt;script src=&quot;https://code.jquery.com/jquery.js&quot;&gt;&lt;/script&gt;\t\t&lt;script src=&quot;bootstrap/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;\t&lt;/body&gt;&lt;/html&gt;\n\n\n\n布局容器和格栅网络系统\n\n","categories":["WebFrontend"],"tags":["css"]},{"title":"CSS3笔记","url":"/2022/08/05/WebFrontend/UI/CSS3%E7%AC%94%E8%AE%B0/","content":"CSS简介理解CSS：设想元素周围有一个盒子CSS允许你创建规则，来控制每个盒子（以及盒子中的内容）的呈现方式。\nCSS将样式规则与HTML元素关联CSS通过将规则与HTML元素相关联的方式来工作。这些规则用来控制指定元素中的内容如何显示。一条CSS规则包含两个部分：一个选择器和一条声明\n\n这条规则表明所有&lt;p&gt;元素都应该用Arial字体来显示。\n选择器表明要应用规则的元素。同一条规则可以应用在多个元素上，前提是你需要将这些元素名用逗号隔开。\n声明用于表明应该如何显示选择器指明的元素。声明分为两个部分（属性和值）并以冒号作为分隔符。\nCSS属性会影响元素的显示方式CSS声明位于花括号中，而且每条声明都由两部分组成：属性和值，两者由冒号隔开。可在一条声明内指定多个属性，各属性之间用分号隔开。\nh1, h2，h3 &#123;    font-family: Arial;    color: yellow;&#125;  /* 属性：值 */\n\n上面这条规则表明所有的&lt;h1&gt;元素、&lt;h2&gt;元素和&lt;h3&gt;元素将以黄色的Arial字体显示。\n属性表明你想要改变元素的哪些方面。例如颜色、字体、宽度、高度和边框.\n值用来指定想要在所选属性上应用的设置。例如：如果指定一个颜色属性，那么这个属性的值就算你希望这些元素中的文本所呈现的颜色。\n使用外部CSS&lt;link&gt;\n在HTML文档中，&lt;link&gt;元素可以告诉浏览器何处寻找用于定义页面样式的CSS文件。它是一个空元素（也就是说它不需要结束标签），而且位于&lt;head&gt;元素中。它应该使用以下三个特性：\n\nhref：该特性表明CSS文件的路径（通常位于css或styles文件夹中）。\ntype：表明该页面所连接的文档的类型。它的值应该是text&#x2F;css。\nrel：该特性表明HTML页面与被链接文件的关系。当链接到一个CSS文件时，该特性的值应该为stylesheet。\n\n&lt;link href = &quot;css/styles.css&quot; type = &quot;text/css&quot; rel = &quot;stylesheet&quot; /&gt;\n\n当建立一个包含有多个页面的网站时，应该使用外部样式表。这样做具有以下好处：\n\n\n允许所有页面使用同样的样式规则（重复利用性）。\n将页面的内容和表现分离。\n可以通过修改一个文件（而不必修改每个页面）来改变所有页面的样式。\n\n\n使用内部CSS&lt;style&gt;\n可以在HTML页面添加CSS规则，这时需要将它们置于&lt;style&gt;元素内，&lt;style&gt;元素通常位于页面的&lt;head&gt;元素中。\n&lt;style&gt;使用该元素特性表明这些样式是在CSS中指定的。该特性的值应该为text&#x2F;css。\n&lt;style type = &quot;text/css&quot;&gt;    body &#123;        ......    &#125;&lt;/style&gt;\n\nCSS选择器CSS选择器参考手册\n\n\nCSS规则如何级联如果有两个或者更多的规则应用在同一个元素上，那么理解这些规则的优先级关系是非常重要的。\n就近原则：如果两个选择器完全相同，那么后出现的选择器优先级较高。\n具体性原则：如果一个选择器比其他选择器更加具体，那么具体的选择器优先于一般的选择器。\n重要性：可以在任意属性值的后面添加**!important**来强调这一条规则比应用于同一元素的其他规则更重要。\n继承如果在&lt;body&gt;元素上指定了font-family属性或color属性，那么它们将应用于&lt;body&gt;元素的大多数元素上。这是因为font - family属性被这些子元素所继承。\nbackground-color属性和border属性不会被子元素继承。如果这些元素会被继承，那么这些页面会很乱。\n可以通过将属性值设置为inherit来强制大多数元素从它的父元素中继承属性值。在本示例中，&lt;div&gt;元素(属于page类)从应用于&lt;body&gt;元素的CSS规则中继承了padding属性的值。\n&lt;div class = &quot;page&quot;&gt;    &lt;h1&gt;Potatoes&lt;/h1&gt;    &lt;P&gt;        There are dozens of different potato varieties.    &lt;/P&gt;    &lt;p&gt;        They are usually described as early.second early and maincrop potatoes.    &lt;/p&gt;&lt;/div&gt;\n\nbody &#123;    font-family: Arual, Verdana, sans-serif;    color: #665544;    padding: 10px;&#125;.page &#123;    border: 1px solid #664433;    background-color: #efefef;    padding: inherit;&#125;\n\n颜色前景色colorcolor属性允许指定元素中文本的颜色。可以在CSS中采用以下三种方法之一来指定任何颜色：\nRGB值：三原色组成颜色，例如：rgb(100,100,90)。\n\n十六进制编码：这种方式是通过六位十六进制编码表示颜色，其中的六位编码（每两位构成一个值，共三个值）前面加一个#号。例如：#ee3e80。\n颜色名称：浏览器可以标识147种预定义的颜色名称。\n/* color name */h1 &#123;    color: DarkCyan;&#125;/* hex code */h2 &#123;    color: #ee3e80;&#125;/* rgb calue */p &#123;    color: rgb(100.100.90);&#125;\n\n背景色background-colorCSS在处理每个HTML元素时都假设它们位于一个无形的盒子中，而background-color属性设置的正是这个盒子的背景色。\n如果为指定背景色，那么背景将是透明的。\nbody &#123;    background-color: rgb(200, 200, 200);&#125;h1 &#123;    background-color: darkcyan;&#125;h2 &#123;    background-color: #ee3e80;&#125;p &#123;    background-color: white;&#125;\n\nCSS3：透明度opacity,rgba\nopacity 指定透明度，数组介于0.1~1.0之间，0.5表示50%的透明度，0.15表示15%的透明度（会影响子元素）\nCSS3中的rgba属性比rgb多个了标识透明度的值。这个值称为alpha值，数组介于0.1~1.0之间，0.5表示50%的透明度，0.15表示15%的透明度。（不会影响子元素）\np.one &#123;    background-color: rgb(0, 0, 0);    opacity: 0.5;&#125;p.two &#123;    background-color: rgba(0, 0, 0, 0.5);&#125;\n\n\nCSS3：HSL和HSLAhsl颜色属性以及作为一种新的颜色指定方式进入CSS3中。该属性的值以hsl开头，位于其后的括号内是以下几种值：\n\n色调：通过介于0°~360°之间的一个角度表示。\n饱和度：通过百分数表示。\n明度：通过百分数表示，0%表示黑色，50%表示标准色，100%表示白色\nALPHA：透明度，该值由于0~1.0之间的数字表示。\n\nbody &#123;    background-color: #C8C8C8; /*添加该值为了兼容旧浏览器*/    background-color: hsl(0, 0%, 78);&#125;p &#123;    background-color: #ffffff;    background-color: hsla(0, 100%, 100%, 0.5);&#125;\n\n文本字体术语\n衬托字体(SERIF)：衬托字体在字母主要笔画的末端有一些额外的装饰。这些装饰被称为衬线\n无衬线字体(SABS-SERIF)：无衬线字体中的字母拥有笔直的线条，因此它的设计更加简洁。\n等宽字体(MONOSPACE)：等宽字体中的每个字母的宽度都相同，而非等宽字体中字母的宽度不同。\n草书字体(Cursive)： 模仿了人类的笔迹。\n幻想字体(Fantasy)：是装饰性&#x2F;俏皮的字体。\n\nfont-family: Georgia, Times, serif; /*衬托字体*/\n\n字体大小font-sizedont-size属性用来指定字体大小，常用方式：\n\n像素：像素之所以能被广泛使用，是因为它能让Web设计人员对文本占用的空间进行精准的控制。它的表示方式是在像素值后面加个px。\n百分数：文本在浏览器中默认大小是16px。因此75%相当于12px，200%相当于32px。\nEM值：lem相当于一个字母m的宽度。\n\n选用更多字体@font-face@font-face通过指定字体的下载地址(当这种字体在用户的计算机上没有安装时，就会自动下载)让你调用字体，即使用户在浏览时使用的计算机上没有安装相应的字体也可以加以使用。\n\nfont-family：该属性指定字体的名称\nsrc：该属性指定字体的路径。\nformat：该属性指定所提供字体的格式。\n\n@font-face &#123;    font-family: &#x27;ChunckFiveRegular&#x27;;    src: url(&#x27;fonts/chunkfive.eot&#x27;);&#125;h1, h2 &#123;    font-family: ChukFiveRegular, Georgia, serif;&#125;\n\n粗体font-weightfont-weight属性允许创建粗体文本。该属性通常选用以下两个值：\n\nnormal：该值使文本以普通粗细显示。\nbold：该值使文本以粗体显示\n\n.credits &#123;    font-weight: bold;&#125;\n\n斜体font-stylefont-style属性允许创建斜体文本：该属性有三个可选值：\n\nnormal：该值使文以普通字体（相对斜体和倾斜来说）显示。\nitalic：该值使文本以斜体显示。\noblique：该值使文本倾斜显示。\n\n.credits &#123;    font-style: italic;&#125;\n\n大写和小写text-transformtext-transform属性可以改变文本的大小写，可选用以下值之一：\n\nuppercase：该值使文本以大写显示。\nlowercase：该值使文本以小写显示。\ncapitalize：该值使每个单词的首字母以大写显示。\n\nh1 &#123;    text-transform: uppercase;&#125;h2 &#123;    text-transform: lowercase;&#125;.credits &#123;    text-transform: capitalize;&#125;\n\n下划线和删除线text-decoratioontext-decoratioon属性可以选用以下值：\n\nnone：删除应用在文本上的装饰线\nunderline：该值会在文本底部增加一条实线\noverline：该值会在文本顶部增加一条实线\nline-through：该值会用一条实现穿过文字\n\n行间距line-height在css中，line-height属性用于设置文本行的整个高度\np &#123;    line-height: 1.4em;&#125;\n\n字母间距和单词间距letter-spacing，word-spacing字距是印刷行业用来描述字母之间空隙的一个术语。可以使用letter-spacing属性来控制字母之间的间距。\nh1, h2&#123;    text-transform: uppercase;    letter-spacing: 0.2em;&#125;.credits &#123;    font-weight: bold;    word-spacing: 1em;&#125;\n\n对齐方式text-aligntext-align用于控制文本的对齐方式。该属性可以选用以下值：\n\nleft：该值表明文本向左对齐\nright：该值表明文本向右对齐\ncenter：该值将文本居中显示\njustify：该值表明文本两端对齐，即段落中除了末行以外的其他每行都要在宽度上占满文本所在的容器。\n\nh1 &#123;    text-align: left;&#125;p &#123;    text-align: justify;&#125;.credits &#123;    text-align: right;&#125;\n\n垂直对齐vertical-alignvertical-align属性可以选用的值包括：\n\n\nbaseline\nsub\nsuper\ntop\ntext-top\nmiddle\nbottom\ntext-bottom\n\n\n它还可以选用长度值（通常以像素或em值指定）或是行高的百分数。\n#six-moths &#123;    vertical-align: text-top;&#125;#one-year &#123;    vertical-align: baseline;&#125;#two-years &#123;    vertical-align: text-bottom;&#125;\n\n\n文本缩进text-indenttext-indent属性允许将元素中的首行文本进行所见，通常采用像素值或em值。\nh1&#123;    text-indent: -9999px;&#125;\n\nCSS3：投影text-shadow该属性用于创建投影，投影指的是比文本颜色更暗的版本，它位于文本的后方并略有偏移。该属性还可以通过添加亮度比文本稍高的阴影来创建浮雕效果。\n由于创建投影需要指定三个长度值和一种颜色，因此该属性的值非常复杂：\n\n\n第一个长度值表明阴影向左或向右延伸的距离\n第二个长度值表明阴影向上或向下延伸的距离\n第三个长度值为可选项，它用于指定投影的模糊程度\n最后一项是投影的颜色值\n\n\np&#123;    background-color: #aaaaaa;    color: #ffffff;    text-shadow: -1px -1px #666666;&#125;\n\n首字母或首行文本:first-letter, :first-line可以通过:first-letter和 :first-line为一个元素中的首字母或者首行文本另外指定一个值。他们被称为伪元素\np.intro:first-letter &#123;    font-size: 200%;&#125;p.inro:first-line&#123;    font-weight: bold;&#125;\n\n链接样式:link, :visited默认情况下,浏览器通常以蓝色显示链接并附带下划线,此外,浏览器还会改变那些已经访问过的链接的颜色,以此来帮助用户分清他们已经访问过哪些页面.\n在CSS中,有两个伪类允许为已访问的和未访问的链接定义不同的样式.\n\n:link 该伪类允许给未访问的链接设置样式\n:visited 该伪类允许给访问过链接设置样式\n\na:link &#123;    color: deeppink;    text-decoration: none;&#125;a:visited &#123;    color: black;&#125;a:hover &#123;    color: deeppink;    text-decoration: underline;&#125;a:active&#123;    color: darkcyan;&#125;\n\n相应用户 :hover, :active, :focus当用户与元素进行交互时,可使用下面的三种伪元素来改变元素的外观.\n\n:hover 该伪元素在用户将定位设备(比如光标)悬停在某个元素上时生效\n:active 该伪类在元素上进行操作时生效\n:focus 该伪类在元素拥有拥有焦点时生效\n当使用多个伪类时,应当遵循:link,:visited,:hover,:focus,:active顺序\n\n特性选择器\n盒子盒子的大小width, height默认情况下,一个盒子的大小刚好容下其中的内容,并根据其中内容的变化而变化.如果自定义盒子的大小,就需要用到windth和height属性.\n指定盒子大小最常用的方式是像素、百分数或em值。\n&lt;div&gt;    &lt;p&gt;        一段文本    &lt;/p&gt;&lt;/div&gt;\n\ndiv.box &#123;    height: 300px;    width: 400px;    background-color: #ee3e80;&#125;p &#123;    height: 75%;    width: 75%;    background-color: #eeddda;&#125;\n\n宽度限制min-width, max-width为了适应用户的屏幕大小，有些设计会适时地展开或收缩页面。在此设计中min-width属性指定一个盒子在浏览器窗口较窄时可以显示的最小宽度，max-width属性指定一个盒子在浏览器较宽时成伸展的最大宽度。\n&lt;tr&gt;    &lt;td class = &quot;description&quot;&gt;    ......    &lt;/td&gt;    &lt;td&gt;......&lt;/td&gt;&lt;/tr&gt;\n\ntd.description &#123;    min-width: 450px;    max-width: 650px;    text-align: left;    padding: 5px;    margin: 0px;&#125;\n\n高度限制min-height, max-height和宽度限同理\n内容移除 overflowofverflow属性告诉浏览器当盒子的内容超过盒子本身时如何显示。它有两个属性值可供选择：\n\nhidden：该属性会直接把溢出盒子空间的内容进行隐藏。\nscroll：该属性会在盒子上添加一个滚动条，这样用户可以通过滚动滑块来查看剩余的内容。\n\np.one &#123;    overflow: hidden;&#125;p.two &#123;    overflow: scroll;&#125;\n\n\n\n\n外框、外边距和内边距有三种属性可以应用在所有盒子上，可以通过调节这些属性来控制盒子的外观：\n\n外框(BORDER)\n外边距(MARGIN)\n内边距(PADDING)\n\n\n边框宽度border-widthborder-width属性用来控制边框宽度。该属性可以时像素值(不可以使用百分数)，也可以选择以下值之一:\n\nthin\nmedium\nthink\n\n可以通过下面4种属性分别对各个边框大小进行控制:\n\nborder-top-width\nborder-right-width\nborder-bottom-width\nborder-left-width\n\n又或者：\nborder-width: 2px 1px 1px 2px; /*顺序为，上方，右侧，下方，左侧*/\n\n边框样式border-style可使用border-style属性来控制边框的样式。该属性可以选用以下值：\n\nsolid 一条实现\ndotted 一串方形点\ndashed 一条虚线\ndouble 两条实线\nridge 显示为在页面上凸起的效果\ninset 显示为嵌入页面的效果\noutset 看起来像是凸出屏幕\nhedden&#x2F;none 不显示任何边框\n每个边也可以单独设置样式\n\np.one &#123;border-style: solid;&#125;\n\n\n边框颜色border-color可利用RGB值、十六进制码或是CSS颜色名称来指定边框颜色。\n每个边框可以单独设置。\np.one &#123;    border-color: #0088dd;&#125;\n\n快捷方式borderborder属性允许你在一个属性中同时指定边框的宽度、样式和颜色\np &#123;    width: 250px;    border:3px dotted #0088dd;&#125;\n\n\n内边距paddingpadding属性用来指定元素的内容与元素边框之间保持多大的空隙。\np &#123;    padding: 10px;&#125;\n\n\n外边距marginmargin属性用来控制盒子之间的空隙。\np &#123;    margin: 20px;&#125;\n\n\n内容居中如果想让一个盒子在页面上居中显示（或者在某个元素居中显示），可将left-margin属性和right-margin属性的值设置为auto\nbody &#123;    text-align: center;&#125;p &#123;    width: 300px;    padding: 50px;    border: 20px solid #0088dd;&#125;p.example &#123;    margin: 10px auto 10px auto;    text-align: left;&#125;\n\n\n内联元素与块级元素的转换displaydisplay属性允许你将一个内联元素转换成一个块级元素，反之赤然，而且该属性还可以从页面上隐藏元素。该属性可以选用以下值：\n\ninline：该值可以使一个块级元素表现得像一个内联元素。\nblock：该值可以使一个内联元素表现得像一个块级元素。\ninline-block：该值可以使一个块级元素像内联元素那样浮动并保持其他的块级元素特征。\nnone：该值将一个元素从页面上隐藏。\n\nli &#123;    display: inline;    margin-right: 10px;&#125;li.coming-soon &#123;    display: none;&#125;\n\n\n盒子的隐藏visibilityvisibility属性允许从用户的视线中隐藏盒子，但它保留了元素原来占用的空间。该属性可以选用以下值之一：\n\nhidden：该值用于隐藏元素。\nvisible：该值用于显示元素。\n\nli &#123;    display: inline;    margin-right: 100px;&#125;li.coming-soom &#123;    visibility: hidden;&#125;\n\n\nCSS3：边框图像border-imageborder-image属性将图片应用到盒子的边框上。它采用一张背景图片，并将图片切割成九块。\n该属性需要三种信息：\n\n\n图片的URL\n\n切割图片的位置\n\n如何处理直边，可以选用以下值：\n\nstretch 伸展图片\nrepeat 重复图片\nround 平铺图片\n\n\n\n\n#borderimg &#123;  border: 10px solid transparent;  padding: 15px;  border-image: url(border.png) 30 stretch;&#125;\n\n\nCSS3：盒子的阴影box-shadowbox-shadow属性允许在盒子的周围增加阴影。使用该属性时，至少包含下列项目中前两项的值以及一个颜色值。\n\n水平偏移：负值表示将阴影置于盒子的左侧。\n垂直偏移：负值表示将阴影置于盒子的上方。\n模糊距离：缺省默认为实边。\n阴影扩展：如果使用该值，正值会使用阴影向四周延伸，负值则会使阴影收缩。\n\np &#123;    box-shadow: 5px 5px 5px #777777;&#125;\n\n\nCSS3：圆角border-radiuscss3引入了在盒子上创建圆角的功能。为了实现该功能，需要使用一个称为border-radius的属性。该值表示半径（像素）\np &#123;    border-radius: 10px&#125;\n\nCSS3：椭圆形border-radius要创建更复杂的形状，可给圆角的横向值和纵向值指定不同的距离。\np &#123;    border-radius: 80px 50px;&#125;\n\n\n列表、表格和表单项目符号样式list-style-typelist-style-type属性允许控制项目符号（也成为标记）的形状或样式。\n该属性可在应用到&lt;ol&gt;元素、&lt;ul&gt;元素和&lt;li&gt;元素的规则中使用。\n无序列表：\n对于一个无序列表的list-style-type属性，可以使用以下值：\n\nnone\ndisc\ncircle\nsquare\n\n有序列表：\n对于一个有序（编号）列表的list-style-type属性，可以使用以下值：\n\ndecimal：123\ndecimal-leading-zero：01 02 03\nlower-alpha：a b c\nupper-alpha：A B C\nlower-roman：i. ii. iii.\nupper-roman：I II III\n\nol &#123;    list-style-type: lower-roman;&#125;\n\n项目图像list-style-image可利用list-style-imagge属性将一个图像作为项目符号使用。\n该属性的值以字母url开头，后秒跟着一对圆括号。在括号里面，图像的路径在双引号中给出。\n该属性可以在应用到&lt;ul&gt;元素和&lt;li&gt;元素的规则中使用。\nul &#123;    list-style-image: url(&quot;images/star.png&quot;);&#125;li &#123;    margin: 10px 0px 0px 0px;&#125;\n\n\n标记的定位list-style-position默认情况下，列表会缩进到页面中。list-style-position属性用于表明标记显示的位置，是在包含主体内容的盒子的内部，还是其在外部。\n该属性可以选用以下两个值：\n\noutside：该值表明标记于文本块的左侧（这也是未使用该属性时的默认处理方式）\ninside：该值表明标记位于文本的内部，同时文本块会被缩进。  \n\nul &#123;    width: 250;&#125;li &#123;    margin: 10px;&#125;ul.illuminations &#123;    list-style-position: outside;&#125;ul.season &#123;    list-style-position: inside;&#125;\n\n\n列表快捷方式list-style与其他的一些CSS属性一样，针对列表样式也有一个类似快捷方式的属性。该属性称为list-style，它允许按任意顺序表示标记的样式、图像和位置属性。\nul &#123;    list-style:inside circle;&#125;\n\n\n表格属性\nwidth：表格宽度\npadding：用于设置每个单元格边框与器内容之间的空隙\ntext-transform：用于将表格标题中的内容转换大写。\nletter-spacing，font-size：用于为表格标题的内容增加额外的样式。\nborder-top，border-bottom：用于设置表格标题上方和下方的边框。\ntext-align：用于将某些单元格中的书写方式设置为左对齐或者向右对齐\nbackground-color：用于交替改变表格行的背景颜色。\n:hover：在用户把光标悬停在某个表格行时将此高亮显示\n\n空单元格的边框empty-cells如果在一个表格中含有空单元格，那么就可以使用empty-cells属性来指定是否显示空单元格的边框。\n如果想显示或隐藏单元格的边框，就需要用到empty-cells属性。可以选用以下三个值之一：\n\nshow：用于显示空单元格的边框\nhide：该值用于隐藏空单元格边框\ninherit：如果一个表格嵌套在另一个表格中，那么inherit值表明单元格遵循外部表格规则。\n\n单元格之间的空隙border-spacing，border-collapseborder-spacing属性允许你控制相邻单元格之间的距离。默认情况下，浏览器经常在每个单元格之间留有一个较小的空隙，利用border-spacing属性可以进行控制，该属性的可选值有：\n\ncollapse：该值表示尽可能将单元格相邻的边框合并为一个单独的边框\nseparate：该值表示将相邻的边框分离\n\n定义单行文本框样式文本输入框的一些常用CSS属性：\n\nfont-size：用于设置用户输入文本的大小\ncolor，background-color：文本颜色,输入框的背景色\nborder，border-radius：增加边框边缘,创建圆角\n:focus(伪类)：用来改变输入时文本输入框的背景颜色\n:hover(伪类)：用来在用户将光标悬停在文本输入框时改变文本输入框的背景色\nbackground-image：为盒子增加背景图像。\n\n定义提交按钮样式\ncolor：控制按钮上文本颜色\ntext-shandow：可在支持该属性的浏览器中展示3D效果的文本\nborder-bottom：使按钮的下方边框稍粗一点，从而使3D效果更加逼真\nbackground-color：可以使提交按钮从周围的项目中突显出来\n\n光标样式cursorcursor属性用于控制显示给用户的光标的类型。\n例如，对于一个表单，把光标悬停于表单上时将光标设置为手型。常用值如下：\n\n\nauto\n\ncrosshair\n\ndefault\n\npointer\n\nmove\n\ntext\n\nwait\n\nhelp\n\nurl(“cursor.gif”);\n\n\n\na &#123;    cursor: move;&#125;\n\n\n布局普通流position:static在普通流中，每个块级元素都会在下一个元素的上方。由于这是浏览器处理HTML元素的默认方式。\n相对定位position:relative如果将一个盒子的position属性值设置为absolute，那么它就会脱离普通流，不在影响页面中其它元素的位置（如同它不在那个位置一样）。\n盒子的位移属性（top或bottom以及keft或right）用于指定元素相对于它的包含元素应该显示在什么位置、\nh1 &#123;    position: absolute;    top: 0px;    left: 500px;    width: 250px;&#125;p &#123;    width: 450px;&#125;\n\n\n固定定位position:fixed固定定位时绝对定位的一种类型，将position属性的值设置为fixed就表示固定定位\n固定定位时指元素相对于浏览器窗口进行定位。因此，当用户滚动页面时，这类元素的位置保持不变。\nh1 &#123;    position: fixed;    top: 0px;    left: 0px;    padding: 10px;    margin: 0px;    width: 100%;    background-color: #efefef;&#125;\n\n\n重叠元素z-index当使用相对定位、固定定位或者绝对定位时，盒子时可以重叠的。如果盒子出现重叠，那么在HTML代码中，后出现的元素将位于页面中先出现元素的上层。\n如果要控制元素的层次，可使用z-index属性。该属性的值是一个数字，数值越大，元素的层级就越靠前。\n\n浮动元素floatfloat属性允许将普通流的元素在它的包含元素内尽可能地向左或向右排列。\nblockquote &#123;    float: right;&#125;\n\n\n清除浮动clearclear属性用于表明一个盒子的左侧或者右侧不允许浮动元素（在同一个包含元素内）。该属性可以选用以下值：\n\nleft：盒子的左侧不能接触同一个包含元素内其他任何元素。\nright：盒子的右侧不能接触同一个包含元素内其他任何元素。\nboth：盒子的左侧和右侧都不能接触同一个包含元素内的其他任何元素。\nnone：盒子的两侧都可以接触元素。\n\n利用浮动创建多列式布局许多网页都采用了多列式的设计。这种设计的每一个列用一个&lt;div&gt;元素表示。下面三种CSS属性用来将多个列并排到一起：\n\nwidth：该属性用于设置列宽\nfloat：该属性用于将多个列并排\nmargin：该属性用于将多个列之间创建空隙\n\n.columnlof2 &#123;    float: left;    width: 620px;    margin: 10px;&#125;.column2of2 &#123;    float: left;    width: 300px;    margin: 10px;&#125;\n\n\n固定宽度布局，流体布局固定宽度布局的设计不会因为用户扩大或缩小浏览器窗口而发生变化。这种设计通常以像素作为衡量单位。\n流体布局设计随着用户对浏览器窗口的扩大或缩小而伸展或收缩，这种设计通常使用百分数。\n多个样式表@import,link有些网页设计人员将它们的CSS规则分为几个单独的样式表。例如他们可能会使用一个样式表来控制布局，而用另一个样式表来控制字体和颜色等\n有些设计人员采取更加模块化的方法指定样式表，他们创建单独的样式表分别控制印刷排版、布局、表单、表格，甚至为网站内的每个子栏目指定不同的样式。\n在一个页面内加入多个样式表的方法有两种：\n\n\n在HTML页面链接一个样式表，然后再这个样式表中使用@import规则来导入其他的样式表。\n可在HTML页面内使用多个&lt;link&gt;元素分别引用样式表。\n\n\n&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;title&gt;Import&lt;/title&gt;        &lt;link rel = &quot;stylesheet&quot; type = &quot;text/css&quot; href = &quot;css/styles.css&quot; /&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;/body&gt;&lt;/html&gt;\n\n@import url(&quot;tables.css&quot;);@import url(&quot;typography.css&quot;);body &#123;    ......&#125;\n\n图像在CSS中控制图像的大小可在CSS中利用width属性和height属性控制一个图像的大小\n&lt;img src=&quot;images/magnolia-large.jpg&quot; class=&quot;large&quot; alt=&quot;Magnolia&quot;&gt;\n\nimg.large&#123;    width: 500px;    height: 500px;&#125;\n\n使用CSS将图像对齐相对于&lt;img&gt;元素的align特性来说，越来越多的网页设计人员使用float属性来对齐图像。可以采用两种方式来实现对齐：\n\n\n将float属性添加到控制图像大小的类中（比如small类）。\n使用如align-left或align-right的名称创建新类，将图像在页面内向左或右对齐。\n\n\nimg.align-left &#123;    float: left;    margin-right: 10px;&#125;\n\n使用CSS将图像居中默认情况下，图像属于内联元素。这意味着它们与周围的文本一起流动。为使图像居中，我们应该转换成块级元素，通过将display属性的值设置为block可以完成转换。\n图像被转换成块级元素后，可采用以下两种方法将其水平居中：\n\n\n对于图像的包含元素，可将其text-align属性的值设置为center。\n\n对于图像本身而言，可使用margin属性并将其左，右外边距的值设置为auto。\n\n\n\nimg.align-center&#123;    dispaly: block;    margin: 0px auto;&#125;\n\n背景图像background-imagebackground-image属性允许你在任何HTML元素之后放置图像。背景图像可以填满整个页面或是填充页面的一部分。默认情况下，背景图像会自动重复并充满整个盒子。\nbody &#123;    background-image: url(&quot;images/pattern.gif&quot;);&#125;\n\n重复图像background-repeat background-attachmentbackground-repeat 属性可选用以下四个字值中的一个：\n\n\nrepeat：背景图像在水平方向和垂直方向上都进行重复（默认的显示方式）\n\nrepeat-x：背景图像只在水平方向进行重复\n\nrepeat-y：背景图像仅在垂直方向上重复\n\nno-repeat：背景图像只显示一次。background-attachment属性用于指定背景图像在用户混动页面时的移动方式，可以选用以下两个值中的一个：\n\nfixed：背景图像固定在页面中的一个位置\nscroll：背景图像随用户上下滚动页面而上下移动\n\n\n\n\n背景图像的定位background-position如果背景图像不进行重复，可以使用background-position属性来指定背景图像在浏览器在窗口中的位置\n该属性通常会有一堆值。第一个值表示水平位置，第二个值表示垂直位置\n\nbody &#123;    background-image: url(&quot;images/tulip.gif&quot;);    background-repeat: no-repeat;    background-position: center top;&#125;\n\n简写background该属性比如按照以下顺序来指定，但如果不想指定某个属性，可将其忽略。\n\nbackground-color\nbackground-image\nbackground-repeat\nbackground-attachment\nbackground-position\n\ndiv &#123;    background:        url(example-1.jpg)        no-repeat top left&#125;\n\n图像翻转与子画面利用CSS，可在用户将光标悬停在一个链接或按钮上时为链接或按钮创建另一种样式（称为翻转），还可以在用户单击它时创建第三种样式。\n当一个单独的图像应用在某个界面的多个不同部位时，它就被称为子画面（sprite）\nCSS3：渐变background-image渐变通过background-image属性来创建。\n#grad &#123;    background-image: linear-gradient(#e66465, #9198e5);&#125;\n\n","categories":["WebFrontend"],"tags":["css"]},{"title":"微信小程序Uni-app笔记","url":"/2023/04/18/WebFrontend/%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8FUni-app%E7%AC%94%E8%AE%B0/","content":"全局配置pages.jsonpages.josn 文件用来对uni-app进行全局配置，决定页面文件的路径、窗口表现、设置多tab等。\n\nglobalStyle设置默认页面的窗口表现。\npages 设置页面路径及窗口表现。\ntabBar 设置底部 tab 的表现\n\n获取元素节点    const query = uni.createSelectorQuery()    query.select(&#x27;#ion-heade&#x27;).boundingClientRect()    query.exec(res =&gt; &#123;        headerOffsetH.value = res[0].height    &#125;)\n\nToast        Toast(&#x27;获取项目列表失败!&#x27;)\n\n        uni.showLoading(&#123;            title: &#x27;请选择期望职位&#x27;,        &#125;)\n\n获取元素节点&lt;view id=&quot;ion-heade&quot;&gt;1234&lt;/view&gt;\n\nconst query = uni.createSelectorQuery()query.select(&#x27;#ion-heade&#x27;).boundingClientRect()query.exec(res =&gt; &#123;\tconsole.log(&#x27;元素信息：&#x27;, res[0])&#125;)\n\n\n注意事项：要在页面加载之后进行获取\n\n组件传参&lt;template&gt;  &lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;  &lt;button @click=&quot;setMessage&quot;&gt;Change Message&lt;/button&gt;&lt;/template&gt;&lt;script&gt;import &#123; useMyStore &#125; from &#x27;@/store/myStore&#x27;export default &#123;  setup() &#123;    const store = useMyStore()    const message = computed(() =&gt; store.getMessage())    function setMessage() &#123;      store.setMessage(&#x27;New message from component!&#x27;)    &#125;    return &#123;      message,      setMessage    &#125;  &#125;&#125;&lt;/script&gt;\n\n&lt;template&gt;  &lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;  &lt;button @click=&quot;setMessage&quot;&gt;Change Message&lt;/button&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt;import &#123; useMyStore &#125; from &#x27;@/store/myStore&#x27;import &#123; defineComponent, computed &#125; from &#x27;vue&#x27;const store = useMyStore()const message = computed(() =&gt; store.getMessage())function setMessage() &#123;  store.setMessage(&#x27;New message from component!&#x27;)&#125;&lt;/script&gt;\n\n小程序双向数据绑定\n最好不要使用v-model，使用v-bind 和 v-on\n\n&lt;input :value=&quot;textValue&quot; @input=&quot;inputChange&quot; maxlength=&quot;500&quot; placeholder=&quot;请用一段简短的文字描述一下自己吧&quot; /&gt;&lt;view&gt;&#123;&#123; description &#125;&#125;/500 字&lt;/view&gt;\n\nlet description = ref(&#x27;&#x27;)\n\n\n多行文本&lt;textarea :value=&quot;textValue&quot; @input=&quot;inputChange&quot; maxlength=&quot;500&quot; placeholder=&quot;请用一段简短的文字描述一下自己吧&quot; /&gt;&lt;view&gt;&#123;&#123; description &#125;&#125;/500 字&lt;/view&gt;\n\nconst textValue = ref(&#x27;&#x27;)let description = ref(0)const _ParameterPassingService = new ParameterPassingService()const inputChange = (event: any) =&gt; &#123;    description.value = event.detail.cursor&#125;\n\n\n在 UniApp 中，v-model 指令不能直接应用于 textarea 组件，因为 UniApp 会对 Vue.js 的语法进行编译，生成多端应用代码，而不同平台对于表单组件的处理方式可能有所不同。例如，在微信小程序中，textarea 组件的双向数据绑定需要使用 value 属性和 bindinput 事件，而在其他平台上，可能需要使用不同的属性和事件来实现相同的功能。因此，为了确保跨平台的兼容性，UniApp 建议使用 v-bind 和 v-on 指令来实现 textarea 组件的双向数据绑定，而不是直接使用 v-model 指令。如果组件无法输入：尝试添加高度\n\nuniapp css 修改::v-deep .uni-select &#123;    border: none;    text-align: right;    right: 0px;&#125;\n\n\n弹窗显示uni.showToast(&#123;\ttitle: &#x27;&#x27;,&#125;)\n\n\n下拉菜单&lt;picker @change=&quot;bindPickerChange&quot; :value=&quot;selectedSalary&quot; :range=&quot;salariesOptions&quot; range-key=&quot;ItemName&quot;&gt;\t&lt;view class=&quot;uni-input&quot;&gt;&#123;&#123; salariesOptions[selectedSalary]?.ItemName &#125;&#125;&lt;/view&gt;&lt;/picker&gt;&lt;script setup lang=&quot;ts&quot;&gt;const selectedSalary: any = ref(0)const salariesOptions: Ref&lt;any[]&gt; = ref([])\tconst bindPickerChange = (e: any) =&gt; &#123;\t\tselectedSalary.value = e.detail.value\t&#125;&lt;/script&gt;\n\n\n页面传参跳转页面：\nuni.navigateTo(&#123;\turl: `/pages/boss/interview-worker/interview-worker?id=$&#123;offerId&#125;&amp;title=$&#123;title&#125;&amp;flag=$&#123;flag&#125;`,&#125;)\n\n被跳转的页面：\nonLoad(query =&gt; &#123;\treqId.value = query?.id || &#x27;&#x27;\ttitle.value = query?.title || &#x27;&#x27;\tflag.value = query?.flag || &#x27;&#x27;&#125;)\n\n","categories":["WebFrontend/移动应用"]},{"title":"HTML5布局","url":"/2022/08/05/WebFrontend/UI/HTML5%E5%B8%83%E5%B1%80/","content":"HTML5布局传统的HTML布局一直以来，网页设计人员都利用&lt;div&gt;元素将页面中的相关元素集中在一起（比如那些组成页眉、文章、页脚、侧边栏的元素），并使用class或id特性来指定&lt;div&gt;在页面结构中的作用\n\n新的HTML5布局元素HTML5引入了一组新的元素，这些元素允许对页面各个部分进行分割。它们的名称直接表明了其中包含的内容。\n\n页眉和页脚&lt;header&gt; &lt;footer&gt;&lt;header&gt; 和 &lt;footer&gt;元素可以用作：\n\n\n网站中出现在每个页面顶部的主页眉或底部的主页脚\n页面中单独的&lt;article&gt;或&lt;section&gt;中的页眉或页脚。\n\n\n&lt;header&gt;    &lt;h1&gt;WRXinYue&#x27;s blog&lt;/h1&gt;    &lt;nav&gt;        &lt;ul&gt;            &lt;li&gt;&lt;a href=&quot;&quot; class= &quot;curremt&quot;&gt;home&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a href=&quot;&quot;&gt;classes&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a href=&quot;&quot;&gt;catering&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a href=&quot;&quot;&gt;about&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a href=&quot;&quot;&gt;contact&lt;/a&gt;&lt;/li&gt;        &lt;/ul&gt;    &lt;/nav&gt;&lt;/header&gt;\n\n&lt;footer&gt;    $copy: 2022 WRXinYue&#x27;s blog&lt;/footer&gt;\n\n导航&lt;nav&gt;&lt;nav&gt;元素专门用于包含网站的主要导航块，比如网站的主导航。\n文章&lt;artcle&gt;&lt;artcle&gt;元素就像是页面中任意部分（可能是单独存在的部分，也可能是联合出现的某一部分）的一个容器。\n它们可以是一个单独的文章、博客日志、评论、论坛帖子，或者任何其他独立的内容。\n如果一个页面含多篇文章（或是多个文章摘要），那么每个单独的元素的文章都应个位于其专属的&lt;article&gt;元素中\n&lt;article&gt;    &lt;figure&gt;        &lt;img scr = &quot;images/bok-choi.jpg&quot; alt = &quot;Bok Choi&quot; /&gt;        &lt;figcaption&gt;Bok Choi&lt;/figcaption&gt;    &lt;/figure&gt;    &lt;hgroup&gt;        &lt;h2&gt;二级标题&lt;/h2&gt;    &lt;/hgroup&gt;    &lt;p&gt;        .......    &lt;/p&gt;&lt;/article&gt;\n\n附属信息&lt;aside&gt;&lt;aside&gt;元素有两个作用，具体具有哪种作用取决于其是否位于&lt;article&gt;元素中\n如果在&lt;article&gt;元素内出现时，它应该包含与当前文章相关的信息，而不必涉及页面的整体信息。\n当在&lt;article&gt;元素外出现，它应该包含与整个页面相关的内容。\n部分&lt;section&gt;&lt;section&gt;元素用于将相关的内容集中到一块，而每个部分通常都带有一个标题。\n&lt;section&gt;元素不能作为整个页面的容器使用（除非这个页面只包含一个内容）\n标题组&lt;hgroup&gt;&lt;hgroup&gt;元素的作用是将一个或多个&lt;h1&gt;到&lt;h6&gt;的标题元素组合到一块，将它们当成一个标题看待。\n图形 &lt;figure&gt; &lt;figcaption&gt;它可以用来包含一篇文章正文中引用的任何内容\n分节元素 &lt;div&gt;在没有合适的元素用来组合一组元素时，仍可以使用&lt;div&gt;元素\n为块级元素添加链接HTML5允许网页设计人员在包含子元素的块级元素周围添加&lt;a&gt;元素。这将使整个块变成一个链接、\n","categories":["WebFrontend"],"tags":["html"]},{"title":"CSS备忘录","url":"/2023/04/18/WebFrontend/UI/CSS%E5%A4%87%E5%BF%98%E5%BD%95/","content":"div盒子水平垂直居中FlexBox布局居中：\n通过设置父容器的 display: flex; 和 justify-content: center; align-items: center; 样式，即可实现将子元素水平垂直居中。\n&lt;div class=&quot;parent&quot;&gt;  &lt;div class=&quot;child&quot;&gt;Hello World!&lt;/div&gt;&lt;/div&gt;&lt;style&gt;  .parent &#123;    display: flex;    justify-content: center;    align-items: center;    height: 100vh; /* 可以根据实际需求调整 */  &#125;&lt;/style&gt;\n\n绝对定位居中：\n父容器添加 position: relative; 样式，并为子元素添加 position: absolute; 以将其从文档流中分离出来。然后可以使用 top, bottom, left, 和 right 属性，将子元素定位到父容器的中心\n&lt;div class=&quot;parent&quot;&gt;  &lt;div class=&quot;child&quot;&gt;Hello World!&lt;/div&gt;&lt;/div&gt;&lt;style&gt;  .parent &#123;    position: relative;    height: 100vh; /* 可以根据实际需求调整 */  &#125;    .child &#123;    position: absolute;    top: 50%;    left: 50%;    transform: translate(-50%, -50%);  &#125;&lt;/style&gt;\n\nFlexbox“自动边距”（auto margin）居中：\nmargin-top: auto; 和 margin-bottom: auto; 来实现元素在父容器中的垂直居中\n&lt;div class=&quot;parent&quot;&gt;  &lt;div class=&quot;child&quot;&gt;Hello World!&lt;/div&gt;&lt;/div&gt;&lt;style&gt;  .parent &#123;    height: 100vh;    display: flex;    flex-direction: column;  &#125;    .child &#123;    margin-top: auto;    margin-bottom: auto;  &#125;&lt;/style&gt;","categories":["WebFrontend/UI"]},{"title":"我使用Vite的坑","url":"/2023/04/18/WebFrontend/tools/%E6%88%91%E4%BD%BF%E7%94%A8Vite%E7%9A%84%E5%9D%91/","content":"部分热重载失效问题如果您修改了一个组件的模板代码，但是在修改后，浏览器没有自动更新，这可能是因为该模板代码包含了组件实例状态（例如 v-model 绑定或者 ref 引用），导致组件无法被热更新。这种情况下，您可以尝试在组件模板外面添加一个包装元素，以将状态提取到外层组件，从而使得内层组件可以被热更新。\n例如，在以下示例中，我们将 v-model 绑定添加到一个名为 value 的属性上：\n&lt;template&gt;  &lt;input :value=&quot;value&quot; @input=&quot;$emit(&#x27;update:value&#x27;, $event.target.value)&quot;&gt;&lt;/template&gt;\n\n在这种情况下，如果您想要热更新组件，您可以尝试在组件模板外面添加一个 &lt;div&gt; 元素，从而将 value 提取到外层组件中：\n&lt;template&gt;  &lt;div&gt;    &lt;input :value=&quot;value&quot; @input=&quot;$emit(&#x27;update:value&#x27;, $event.target.value)&quot;&gt;  &lt;/div&gt;&lt;/template&gt;\n这将使得组件可以被热更新，并且您可以在修改代码后立即看到效果。\n请注意，这种情况只适用于修改了组件模板的情况。如果您修改了组件的 JavaScript 代码，那么您需要确保修改的代码可以被正确编译和加载，并且没有错误或运行时异常。\n","categories":["/"]},{"title":"HTML5笔记","url":"/2022/07/30/WebFrontend/UI/HTML5%E7%AC%94%E8%AE%B0/","content":"复习以下HTML和CSS基础知识，参考书籍：《HTML&amp;CSS设计与构造网站》\n结构HTML描述页面的结构HTML代码由包括含在尖括号种的字符构成，这些代码称为HTML元素。元素通常由两个标签构成：一个起始标签和一个结束标签（结束标签要多一个斜杠）。每个HTML元素都会向浏览器传达起始标签和结束标签之间的内容的结构信息。\n标签的作用就像是容器。它们告诉你起始标签和结束标签之间的内容的结构信息。\n\n\n\n特性特性提供有关元素中内容的附加信息。它们出现在元素起始标签中，并由特性名称和特性值组成，中间由等号隔开。\n\n文本\n结构化标记：用来描述标题和段落的元素。\n语义化标记：表达特定含义的标记。\n\n标题&lt;h1&gt;&lt;/h1&gt;~&lt;h6&gt;\n\n粗体斜体&lt;b&gt;&lt;/b&gt; //粗体&lt;i&gt;&lt;/i&gt;\t//斜体\n\n上标和下标&lt;sup&gt;&lt;/sup&gt;//如2²&lt;sub&gt;&lt;/sub&gt;//如H₂O\n\n空白当浏览器遇到两个或两个以上的连续空格时，只将其显示为一个空格。这一特性称为白色空间折叠.\n换行和水平线&lt;br /&gt;//换行符&lt;hr /&gt;//上下文章分割线\n\n语义化标记有一些元素，它们不不影响网页结构，却为所在的页面添加了格外信息——这些元素称为语义化标记。\n如em和blockquote这些标签\n加粗和强调&lt;strong&gt;元素的作用是表示其中的内容十分重要。默认情况显示为粗体&lt;/strong&gt;&lt;em&gt;元素其强调作用，能够细微改变语句的含义&lt;/em&gt; \n\n引用这两个元素都可以用cite特性来表面引用的来源。cite\n&lt;blockquote cite=&quot;www.wrxinyue.cn&quot;&gt;&lt;/blockquote&gt;&lt;q&gt;标记段落较短引用&lt;/q&gt;\n\n缩写词和首字母缩写词&lt;p&gt;&lt;abbr title=&quot;Professor&quot;&gt;Prof&lt;/abbr&gt;...&lt;/p&gt;&lt;p&gt;&lt;acronym title=&quot;Professor&quot;&gt;Prof&lt;/acronym&gt;...&lt;/p&gt;\n\n引文和定义&lt;cite&gt;元素可以用来表明引用的来源&lt;/cite&gt;&lt;dfn&gt;元素用来表示一个新术语定义&lt;/dfn&gt;\n\n设计者详细信息&lt;address&gt;元素有一个非常特殊的用途：包含页面设计者的联系详情&lt;/address&gt;\n\n内容的修改&lt;ins&gt;下划线&lt;/ins&gt;&lt;del&gt;删除线&lt;/del&gt;&lt;s&gt;元素表示不准确或不相关却不应当予以删除的内容&lt;/s&gt;\n\n列表有序列表&lt;ol&gt;//使用由该元素来创建有序列表    &lt;li&gt;有序列表1&lt;/li&gt;    &lt;li&gt;有序列表2&lt;/li&gt;    &lt;li&gt;有序列表3&lt;/li&gt;    &lt;li&gt;有序列表4&lt;/li&gt;&lt;/ol&gt;\n\n无序列表&lt;ul&gt;    &lt;li&gt;无序列表&lt;/li&gt;    &lt;li&gt;无序列表&lt;/li&gt;    &lt;li&gt;无序列表&lt;/li&gt;    &lt;li&gt;无序列表&lt;/li&gt;&lt;/ul&gt;\n\n定义列表&lt;dl&gt;\t//定义列表由该元素创建，并通常包含一系列术语及其定义\t&lt;dt&gt;元素用来包含被定义的术语&lt;/dt&gt;    &lt;dd&gt;元素用来包含定义&lt;/dd&gt;&lt;/dl&gt;\n\n嵌套列表&lt;ul&gt;  &lt;li&gt;一级嵌套&lt;/li&gt;  &lt;li&gt;一级嵌套&lt;/li&gt;     &lt;ul&gt;        &lt;li&gt;二级嵌套&lt;/li&gt;        &lt;li&gt;二级嵌套&lt;/li&gt;    &lt;/ul&gt;  &lt;li&gt;一级嵌套&lt;/li&gt;&lt;/ul&gt;\n\n链接编写链接链接是由&lt;a&gt;元素建立的。用户可以单击位于起始标签&lt;a&gt;和结束标签&lt;/a&gt;之间的任何内容。使用href特性来指定要链接到的页面。如:&lt;1 href=&quot;www.wrxinyue.cn&quot;&gt;我的博客地址&lt;/a&gt;\n\n目录结构对于规模较大的网站而言，在管理代码时，更合理的方式是将不同类别的别的页面保存在不同的文件夹中。网站的文件夹有时也称为目录。\n相对URL相对URL可用于为网站内部的页面之间建立链接。它用一种简短的方式告诉浏览器去何处查找文件。\n\nEMAIL链接可以用&lt;a&gt;元素建立email链接mailto：&lt;a href=&quot;mailto&quot;:wrxinyue@formax.com&gt;给我发邮件&lt;/a&gt;\n\n在新窗口打开链接target:&lt;a href=&quot;http://www.wrxinyue.cn&quot; target=&quot;_blank&quot;&gt;新的窗口打开链接&lt;/a&gt;\n\n链接到当前页面的某个特定位置只需要使用id特性就可以实现链接达到目标位置目的。\nid特性值必须以字母或者下划线开头，同一页面不能出现两个相同id的值。\n要连接到一个使用id特性的元素，还需要用到&lt; a&gt;元素，不同的是它的href特性值以#开头，后面跟着你所要链接元素的id特性值。实例：\n&lt;h1 id=&quot;top&quot;&gt;需要到达的地方&lt;/h1&gt;&lt;a href=&quot;#top&quot;&gt;点我开始到达&lt;/a&gt;\n\n链接到其他页面的某个特定位置方法和上面类型，添加绝对或者相对链接即可，实列：\n&lt;a href = &quot;http://www,htmalandcssbook.com/#bottom&quot;&gt;\n\n图像网站上存储图像一般网站图片会存在images文件夹中，但是我会选择使用图床给服务器减少负担\n添加图像&lt; img&gt;图像的参数必须包含src和alt参数：\n\n\nsrc：图片地址\nalt：图片无法显示出现的描述\ntitle：添加图片的附加信息\nheight：以像素为单位来指定图像的高度\nwidth：以像素为单位来指定图像的宽度\n\n\n实列：\n&lt;img src=&quot;images/quokka.jpg&quot; alt=&quot;quokka&quot; title=&quot;......&quot; /&gt;&lt;img src=&quot;images/quokka.jpg&quot; alt=&quot;quokka&quot; width=&quot;600&quot; height=&quot;450&quot; /&gt;\n\n表格表格以网络形式表示数据。网络中每个块称为表格的一个单元格。\n基本的表格结构&lt;table&gt;元素用来创建表格&lt;tr&gt;table row表示每行的开始&lt;td&gt;wable data，表示表格中的每个单元格&lt;th&gt;table heading，表示类或行的标题scope特性来表面此元素是列标题还是行标题。col表示列标题，row表示行标题\n\n实例：\n&lt;table&gt;    &lt;tr&gt;        &lt;th&gt;&lt;/th&gt;        &lt;th scope = &quot;col&quot;&gt;Saturday&lt;/th&gt;        &lt;th scope = &quot;col&quot;&gt;Sunday&lt;/th&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;th =scope = &quot;row&quot;&gt;Tickets sold:&lt;/th&gt;        &lt;td&gt;120&lt;/td&gt;        &lt;td&gt;130&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;th scope = &quot;row&quot;&gt;Total sales：&lt;/th&gt;        &lt;td&gt;$600&lt;/td&gt;        &lt;td&gt;$675&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;\n\n跨列可以在&lt; th&gt;或者&lt; td&gt;元素中用colspan特性来表明单元格所要跨越的列数。\n&lt;table&gt;    &lt;tr&gt;        &lt;th&gt;9am&lt;/th&gt;        &lt;th&gt;10am&lt;/th&gt;        &lt;th&gt;11am&lt;/th&gt;        &lt;th&gt;12am&lt;/th&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;th&gt;Monday&lt;/th&gt;        &lt;td colspan = &quot;2&quot;&gt;Geography&lt;/td&gt;        &lt;td&gt;Math&lt;/td&gt;        &lt;td&gt;Art&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;th&gt;Tuesday&lt;/th&gt;        &lt;td colspan = &quot;30&quot;&gt;Gym&lt;/td&gt;        &lt;td&gt;Home Ec&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;\n\n\n跨行和跨列差不多在&lt; th&gt;或者&lt; td&gt;元素中用rowspan特性来表明单元格所要跨越的行数\n&lt;table&gt;    &lt;tr&gt;        &lt;th&gt;&lt;/th&gt;        &lt;th&gt;ABC&lt;/th&gt;        &lt;th&gt;BBC&lt;/th&gt;        &lt;th&gt;CNN&lt;/th&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;th&gt;6pm * 7pm&lt;/th&gt;        &lt;td rowspan = &quot;2&quot;&gt;Movie&lt;/td&gt;        &lt;td&gt;Comedy&lt;/td&gt;        &lt;td&gt;News&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;th&gt;7pm * 8pm&lt;/th&gt;        &lt;td&gt;Sport&lt;/td&gt;        &lt;td&gt;Current Affairs&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;\n\n\n长表格&lt;thead&gt;//表格标题&lt;tbody&gt;//表格主体&lt;tfoot&gt;//表格脚注\n\n实列：\n&lt;table&gt;    &lt;thead&gt;        &lt;tr&gt;            &lt;th&gt;Date&lt;/th&gt;            &lt;th&gt;Income&lt;/th&gt;            &lt;th&gt;Expenditure&lt;/th&gt;        &lt;/tr&gt;    &lt;/thead&gt;    &lt;tbody&gt;        &lt;tr&gt;            &lt;th&gt;1st January&lt;/th&gt;            &lt;td&gt;250&lt;/td&gt;            &lt;td&gt;36&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;th&gt;2nd January&lt;/th&gt;            &lt;td&gt;285&lt;/td&gt;            &lt;td&gt;48&lt;/td&gt;        &lt;/tr&gt;        &lt;!-- additional rows as above --&gt;        &lt;tr&gt;            &lt;th&gt;31st January&lt;/th&gt;            &lt;td&gt;129&lt;/td&gt;            &lt;td&gt;64&lt;/td&gt;        &lt;/tr&gt;    &lt;/tbody&gt;    &lt;tfoot&gt;        &lt;tr&gt;            &lt;td&gt;&lt;/td&gt;            &lt;td&gt;7824&lt;/td&gt;            &lt;td&gt;1241&lt;/td&gt;        &lt;/tr&gt;    &lt;/tfoot&gt;&lt;/table&gt;\n\n\n表单表单概述网络最知名的表单大概就要术语Google主页中的搜索框了。除了可以让用户进行搜索。表单还可以让用户在线完成其他功能\n\n表单控件添加文本：\n\n\n单行文本框Texi input：用于单行文本\n密码框Password input：类似于单行文本框，但它会掩盖输入其中的字符\n文本域Text area：用于较长的文本，例如消息和评论\n\n\n进行选择：\n\n\n单选按钮Radio buttons：用户必须选择多个选项中的一个使用\n复选框Checkboxes：用户可以选择一个或多个选项时使用\n下拉列表Drop-down boxes：用户必须从一个选项列表中挑选其中之一时使用\n\n\n提交表单：\n\n\n提交按钮Submit buttons：从当前表单向另一个网页提交数据\n图像按钮Image buttons：类似于提交按钮，但只能提交图片\n\n\n上传文件：\n\n\n允许用户把文件（例如图片）上传到网站。\n\n\n表单结构&lt;form&gt;每个表单都位于&lt;form&gt;元素中。每个&lt;form&gt;元素都要设置action特性，通常还有要设置method特性和id特性。\n\naction：其特性值时服务器上一个页面的URL，这个页面用来在用户提交表单时接受表单的信息\n\nmethod：提交表单可以采用get或者post方法。\n\nget方法：表单中的值附加在由action特性所指定的URL末尾。get方法适用以下情形\n\n短表单（例如搜索框）\n只从Web服务器上检索数据的情形（不发送那些要在数据库中添加或删除的数据）\n\n\npost方法：表单的值被放在HTTP头信息进行发送，如果出现以下情形就用post方法\n\n允许用户上传文件\n非常长\n包含敏感信息（例如密码等）\n向数据库中添加或删除信息\n\n\n\n\nid：它的值是用来在页面上众多元素中对表单进行唯一性的标识（也常用在脚本中-例如检查你是否在那些需要信息的区域中填写了信息）\n\n\n&lt;form action=&quot;http://www.example.com/subscribe.php&quot; mothod=&quot;get&quot;&gt;    &lt;p&gt;        This is where the from controls will appear    &lt;/p&gt;&lt;/form&gt;\n\n单行文本框&lt;input&gt;元素用来创建多种不同的表单控件，其type特性的值决定了他将要创建哪种控件\n\ntype &#x3D; “text”：当type特性的值为text时，&lt; input&gt;元素会创建一个单行文本框。\nname：这个特性的值对表单控件进行标识并与输入的信息一同传送到服务器\nmaxlength：这个特性可以用来限制用户在文本区域输入字符的数量，它的值为用户可以输入字符的最大数量\n\n&lt;form action = &quot;http://www.example.com/login.php&quot;&gt;    &lt;p&gt;        &lt;input type = &quot;text&quot; name &quot;username&quot; size = &quot;15&quot; maxlength = &quot;30&quot; /&gt;    &lt;/p&gt;&lt;/form&gt;\n\n\n\n密码框为了保证绝对的安全，就要设置服务器通过安全套接层（SSL）与用户的浏览器进行连接。\n\ntype &#x3D; “password”：当type特性的值为password时，&lt; input&gt;\nname ：这个特性表明密码框的名称，它将与用户输入的代码一同发送到服务器\nsize，maxlength ：密码框也会可以像单行文本框一样设置size特性和maxlength特性\n\n文本域（多行文本框）&lt; textarea&gt;元素用来创建多行文本框。\n&lt;form action = &quot;http://www.example.com/comments.php&quot;&gt;    &lt;P&gt;        What did you think of this gig    &lt;/P&gt;    &lt;textarea name = &quot;comments&quot; cols = &quot;20&quot; rows = &quot;4&quot;&gt;Enter your comments .....&lt;/textarea&gt;&lt;/form&gt;\n\n单选按钮&lt;input&gt;\n\ntype &#x3D; “radio”：单选按钮只让用户从一个选项中选择其中一个\nname：将用户所选择选项的值一同发送到服务器中\nvalue：为选项指定了被选中时要发送到服务器的值\ncheacked：用来指定当页面加载时哪个值\n\n&lt;form action = &quot;httpL//www.example.com/profile.php&quot;&gt;    &lt;p&gt;        Please select your favorite genre:        &lt;br /&gt;        &lt;input type = &quot;radio&quot; name = &quot;genre&quot; value = &quot;rock&quot; checked = &quot;checked&quot; /&gt; Rpck        &lt;input type = &quot;radio&quot; name = &quot;genre&quot; value = &quot;pop&quot; /&gt; Pop        &lt;input type = &quot;radio&quot; name = &quot;genre&quot; value = &quot;jazz&quot; /&gt; Jazz    &lt;/p&gt;&lt;/form&gt;\n\n\n复选框&lt; input&gt;\n\ntype &#x3D; “checkbox”复选框允许用户在回答一个问题时选择（和取消选择）一个或多个选项。\nname：将用户所选择选项的值一同发送到服务器中\nvalue：为选项指定了被选中时要发送到服务器的值\nchecked：用来指定当页面加载时哪个值\n\n&lt;form action = &quot;http://www.example.com/profile.php&quot;&gt;    &lt;P&gt;        Please select your favorite music service(s);        &lt;br /&gt;        &lt;input type = &quot;checkbox&quot; name = &quot;service&quot; value = &quot;itunes&quot; checked = &quot;checked&quot; /&gt; iTunes        &lt;input type = &quot;checkbox&quot; name = &quot;service&quot; value = &quot;lastfm&quot; /&gt; Last.fm        &lt;input type = &quot;checkbox&quot; name = &quot;service&quot; value = &quot;spotify&quot; /&gt; Spotify     &lt;/P&gt;&lt;/form&gt;\n\n下拉列表框&lt;slect&gt;\n该元素用来创建下拉列表框，它包含两个或者两个以上的&lt;option&gt;元素\n\nname：指定这个表单控件名称，此名称与用户选项值一并发送到服务器。\n\n&lt;option&gt;\n该元素用于指定用户可以选择的选项。\n\nvalue：option元素使用value特性来指定选项的值，如果该选项被选中，那么这个值将与控件的名称一并发送到服务器\nselected特性可以用来指定当前页面加载时被选中的选项。selected特性的值应该时selected。\n\n&lt;form action = &quot;http://www.example.com/profile.php&quot;&gt;    &lt;p&gt;        What device do you listen to music on    &lt;/p&gt;    &lt;select name = &quot;devices&quot;&gt;        &lt;option value = &quot;ipod&quot;&gt;iPod&lt;/option&gt;        &lt;option value = &quot;radio&quot;&gt;Radio&lt;/option&gt;        &lt;option value = &quot;computer&quot;Computer&lt;/select&gt;    &lt;/select&gt;&lt;/form&gt;\n\n\n\n多选框&lt;select&gt;\n\nsize：可以通过增加size特性的值来将一个下拉列表框变成一个能显示多个选项的列表框\nmultiple：该特性的值设置为multiple，允许用户从这一列表中选择多个选项\n\n&lt;form action = &quot;http://www.example.com/profile.php&quot;&gt;    &lt;p&gt;        Do you paly any ......    &lt;/p&gt;    &lt;select name = &quot;instruments&quot; size = &quot;3&quot; multiple = &quot;multiple&quot;&gt;        &lt;option value = &quot;guitar&quot; selected = &quot;selected&quot;&gt;Guitar&lt;/option&gt;        &lt;option value = &quot;drums&quot; Drums&gt;Drums&lt;/option&gt;        &lt;option value = &quot;keyboard&quot; selected = &quot;selected&quot;&gt;Keyboard&lt;/option&gt;        &lt;option value = &quot;bass&quot;&gt;Bass&lt;/option&gt;    &lt;/select&gt;&lt;/form&gt;\n\n\n\n文件上传域&lt;input&gt;\n如果你希望让用户上传文件（例如图像、视频、mp3或者PDF），就需要文件域\n\ntype &#x3D; ”file“：这个类型的input会创建一个后面附有Browse按钮的类似文本框的控件。当用户点击Browse按钮时，会打开一个新窗口来让用户从它们的计算机上选择一个文件上传到网站。\n如果允许用户上传文件，必须将&lt;form&gt;元素上的method特性值设置为post（HTTP get方式是不能发送文件的）。\n\n\n&lt;form action = &quot;http://example.com/upload.php&quot; method = &quot;post&quot;&gt;    &lt;p&gt;        Upload your song in MP3 format:    &lt;/p&gt;    &lt;input type = &quot;file&quot; name = &quot;user song&quot; /&gt;&lt;br /&gt;    &lt;input type = &quot;submit&quot; value = &quot;Upload&quot; /&gt;&lt;/form&gt;\n\n\n\n提交按钮&lt;input&gt;\n\ntype &#x3D; “submit”：提交按钮用来将表单发送到服务器。\nname：可以用name特性但不是必须的\nvalue：用于控制在按钮上显示的文本\n\n&lt;form action = &quot;http://www.example.com/subscribe.php&quot;&gt;    &lt;p&gt;        Subscribe to our email list:    &lt;/p&gt;    &lt;input type = &quot;text&quot; name = &quot;email&quot; /&gt;    &lt;input type = &quot;submit&quot; name = &quot;subscribe&quot; value = &quot;Subscribe&quot; /&gt;&lt;/form&gt;\n\n按钮和隐藏控件&lt;button&gt;\n引入&lt;button&gt;元素的目的是让用户更好地控制按钮的显示方式，并且允许其他元素出现在&lt;button&gt;元素内\n&lt;form action = &quot;http://www.example.com/add.php&quot;&gt;    &lt;button&gt;        &lt;img scr = &quot;images/add.gif&quot; alt = &quot;add&quot; width = &quot;10&quot; height = &quot;10&quot; /&gt;        Add    &lt;/button&gt;    &lt;input type = &quot;hidden&quot; name = &quot;bookmark&quot; value = &quot;lyrics&quot; /&gt;&lt;/form&gt;\n\n\n\n标签表单控制&lt;lable&gt;\n在使用表单控件时，可以直接通过表单控件旁边的文本说明它的作用并以此保持代码的简洁。\n\nfor特性用来声明标签控件标注的是哪个表单控件。\n\n组合表单元素&lt;fieldset&gt;\n可以将相关表单控件置于&lt;fieldset&gt;元素中分成一组。常常会带有分界线\n&lt;legend&gt;\n在表单控件上的标题\n&lt;fieldset&gt;    &lt;legend&gt;        Contact details    &lt;/legend&gt;    &lt;label&gt;Email:&lt;br /&gt;    &lt;input type = &quot;text&quot; name = &quot;email&quot; /&gt;&lt;/label&gt;&lt;br /&gt;    &lt;label&gt;Mobile:&lt;br /&gt;    &lt;input type = &quot;text&quot; name = &quot;moblie&quot; /&gt;&lt;/label&gt;&lt;br /&gt;    &lt;label&gt;Telephon:&lt;br /&gt;    &lt;input type = &quot;text&quot; name = &quot;telephone&quot; /&gt;&lt;/label&gt;&lt;/fieldset&gt;\n\n\nHTML：表单验证网络中的表单在用户错误地填写表单控件控件后会弹出错误提示消息，这个过程称为表单验证。\n通常情况下，表单验证是通过JavaScript实现的。但HTML5引入了验证机制并将这一工作交由浏览器完成。\n验证过程可以确保在表单提交后服务器能够理解用户在表单中所填写的信息。在表单发送到服务器之前对表单的内容进行验证有助于：\n\n减少服务器的工作量\n让用户认识到表单是否存在问题时要比服务器完成验证要快\n\n&lt;form action = &quot;http://www.example.com/login&quot;method = &quot;post&quot;&gt;    &lt;label for = &quot;username&quot;&gt;Username:&lt;/label&gt;    &lt;input type = &quot;text&quot; name = &quot;username&quot; required = &quot;required&quot; /&gt;&lt;br /&gt;    &lt;label for = &quot;password&quot;&gt;Password:&lt;/label&gt;    &lt;input type = &quot;password&quot; name = &quot;password&quot; required = &quot;required&quot; /&gt;&lt;br /&gt;    &lt;input type = &quot;submit&quot; value = &quot;Submit&quot; /&gt;&lt;/form&gt;\n\n\nHTML5：日期控件&lt;input&gt;\n许多表单都需要收集日期、电子邮件地址和URL等信息。传统上，使用单行文本框来完成这些工作。\nHTML5引入了新的表单控件并将某些信息的收集方式标准化，而那些不识别此类控件的旧浏览器会将它们作为单行文本框来处理。\n\ntype &#x3D; “date”：要求用户提供日期，可以使用&lt;input&gt;元素并将其type特性的值设为date。这会在支持HTML5新输入类型的浏览器上创建一个日期输入控件。\n\n&lt;form action = &quot;http://www.example.com/bookings/&quot; method = &quot;post&quot;&gt;    &lt;label for = &quot;username&quot;&gt;Departure date:&lt;/label&gt;    &lt;input type = &quot;date&quot; name = &quot;depart&quot; /&gt;    &lt;input type = &quot;submit&quot; value = &quot;Submit&quot; /&gt;&lt;/form&gt;\n\nHTML：电子邮件和URL输入控件&lt;input&gt;\nHTML5还引用了让用户输电子邮件地址和URL的输入控件。那些不支持这类输入控件的浏览器会把它们当成普通文本框来处理。\n\ntype &#x3D; “email” ：如果需要用户提供电子邮件地址，你可以使用电子邮件输入控件。那些支持HTML5验证机制的浏览器将检查用户提供的信息是不是一个格式正确的电子邮件地址。有些智能手机输入电子邮件地址时还会对其键盘布局进行优化，使得键盘可以显示最有可能用到的按键（比如@符号）\ntype &#x3D; “url”：在你需要用户提供网页地址时，可以使用URL输入控件。那些支持HTML5验证机制的浏览器将检查用户所提供的信息是否符合URL的格式。有些智能收集在你输入URL时还会对其键盘布局进行优化。\n\n&lt;form action = &quot;http://www.example.org/profile.php&quot;&gt;    &lt;p&gt;        Please enter your website address:    &lt;/p&gt;    &lt;input type = &quot;url&quot; name = &quot;website&quot; /&gt;    &lt;input type = &quot;submit&quot; value = &quot;Submit&quot; /&gt;&lt;/form&gt;\n\n\nHTML5：搜索输入控件&lt;input&gt;\n如果你想为搜索查询创建一个单行文本框，可使用HTML5为此提供一个专用输入控件。\n\ntype &#x3D; “search”：创建HTML5的搜索框，应将&lt;input&gt;元素的type特性值设置为search，旧浏览器会显示文本框。\nplaceholder：在任何文本输入控件上，好可以使用一个名为placeholder的特性，在用户单击文本输入区域之前，文本框内显示的文本就是placeholder特性的值。\n\n&lt;form action = &quot;http://www.example.org/search.php&quot;&gt;    &lt;p&gt;        Search：    &lt;/p&gt;    &lt;input type = &quot;search&quot; name = &quot;search&quot; placeholder = &quot;Enter keyword&quot; /&gt;    &lt;input type = &quot;submit&quot; value = &quot;Search&quot; /&gt;&lt;/form&gt;\n\n\n其他标记DOCTYPE（文档类型）由于HTML存在多个版本，因此每个页面的开头都应该用一个DOCTYPE声明来告诉浏览器此页面是用来HTML的哪个版本。\n由于XHTML是采用XML编写的，因此有时你会看到使用了严格版XHTML DOCTYPE 的页面以一个可选的XML声明开头\nHTML5&lt;!DOCTYPE html&gt;XML声明&lt;?xml version=&quot;1.0&quot; ?&gt;\n\nHTML中注释\n&lt;!-- comment goes here --&gt;\n\nid特性每个HTML元素都可以附带id特性。id特性用来从页面上的其他元素中对一个元素进行唯一标识，它的值应该以字母或下划线开头。\nclass特性每个HTML元素都可以附带一个class特性，有时候，你希望有一种方法可以指定多个元素并将这些元素和页面上的其他元素区分出来，而不是单独指定文档中的某个元素。\n块级元素有些元素在浏览器窗口中显示时总是另起一行。这些元素被称为块级元素如&lt;h1&gt;、&lt;p&gt;、&lt;li&gt;等\n内联元素有些元素在显示时总是与它的邻近元素出现在同一行内。这些元素被称为内联元素如&lt;a&gt;、&lt;b&gt;、&lt;em&gt;、&lt;img&gt;等\n将文本和元素集中在一个块级元素中&lt;div&gt;\n&lt;div&gt;元素允许你将一组元素集中到一个块级元素内。\n如果在&lt;div&gt;元素上使用id特性或者class特性，就意味着你可以通过创建CSS规则来指定&lt;div&gt;元素会在屏幕上占据多少空间，还可以改变其内部所有元素的外观。\n将文本和元素集中在一个内联元素中&lt;span&gt;\n&lt;span&gt;元素就像是&lt;div&gt;元素的内联版本。它用来：\n\n在没有其他合适元素的情况下包含一段文本并将其与周围的文本区别开\n包含若干个内联元素\n\n人们使用&lt;span&gt;元素最常见的原因就是可以利用CSS来控制&lt;span&gt;元素中的内容的外观。\n你经常会看到&lt;class&gt;特性或id特性用于&lt;span&gt;元素.\n\n解释这个&lt;span&gt;元素的作用\n这样就可以在这些具有特定class或id特性值的元素上应用CSS样式\n\n内联框架&lt;iframe&gt;\n内联框架就像在你的网页里分隔的小窗口——你可以在这个小窗口中看到另一个网页。&lt;iframe&gt;这一术语是inline frame（内联框架的缩写）。\n内联框架是由&lt;iframe&gt;元素创建的。你有必要知道如何使用它的几个特性：\n\nsrc：特性指定要在框架中显示页面的URL。\nheight：特性指定的内联框架高度的像素值\nwidth：特性指定的内联框架宽度的像素值\nseamless：在HTML5中，一个称为seamless的新特性可以应用在不希望出现滚动条的地方\n\n&lt;iframe    width = &quot;450&quot;:    height = &quot;350&quot;:    src = &quot;http://www.wrxinyue.cn&quot;&gt;&lt;/iframe&gt;&lt;!-- 写在一行比较方便 --&gt;&lt;iframe src = &quot;http://www.wrxinyue.cn&quot; width = &quot;450&quot; height = &quot;350&quot;&gt;&lt;/iframe&gt;\n\n\n页面信息&lt;meta&gt;\n&lt;meta&gt;元素位于&lt;head&gt;元素中并包含着所在页面的相关信息。\n&lt;meta&gt;元素是空元素，所以它没有结束标签。它通过特性来携带信息。\n最常用的特性是name特性和content特性，它们还经常同时出现。这些特性用来指定页面的某些特性。name特性的值就是你要设定的属性，而content特性的值就是你想给这个属性的值。\n第一个&lt;meta&gt;元素的name特性表明此元素要为该页面指定一段描述信息。content特性是指定这段描述信息的位置。\nname特性的值可以任意指定，该特性的一些常用的值有：\n\ndescription：用于包含一段关于页面的描述信息。\nkeywords：用于包含一组以逗号分隔的关键词列表，用户可以通过这些关键词来找到这个页面。\nrobots：用于指定搜索引擎是否可以将这个页面加入到它们的搜索结果中。如果不希望页面加入搜索结果，可以使用值noindex。如果希望搜索引擎将该页面加入搜索结果，但不要收录页面上的链接的其他页面，可以使用值nofollow\n\n&lt;meta&gt;元素还会成对使用http-equiv特性和content特性。在下面的示例中，可以看到http-equiv特性的三个实例。每个实例都有各自的用途：\n&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;title&gt;Information About Your Pages&lt;/title&gt;        &lt;meta name = &quot;description&quot; content = &quot;WRXinYue’s blog&quot; /&gt;        &lt;meta name = &quot;keywords&quot; content = &quot;blog,wrxinyue,web,unity&quot; /&gt;        &lt;meta name = &quot;robots&quot; content = &quot;nofollow&quot; /&gt;        &lt;meta http-equiv = &quot;author&quot; content = &quot;WRXinYue&quot; /&gt;        &lt;meta http-equiv = &quot;pragma&quot; content = &quot;no-cache&quot; /&gt;        &lt;meta http-equiv = &quot;expires&quot; content = &quot;Fri, 04 Apr 2022 00:00:00 GMT&quot; /&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;/body&gt;&lt;/html&gt;\n\n\nauthor ：用于定义网页的设计者\npragma：用于防止浏览器对页面的缓存\nexpires：由于浏览器经常缓存页面的内容，expires选项可以用来指定页面的过期时间（以及缓存的有效期）\n\n转义字符有一些字符用于编写HTML代码并作为HTML的保留字符（例如，左尖括号和右尖括号）\n参考表：https://tool.oschina.net/commons?type=2\n视频和音频HTML5：向网页添加视频&lt;vodeo&gt;\n&lt;vodeo&gt;元素有很多特性用于控制视频的播放：\n\nsrc：该特性指定视频的路径。\nposter：在视频加载时或在视频播放之前，该特性用于指定在播放器中显示一个图像。\nwidth，height：这两个特性用像素值指定播放器的大小。\ncontrols：如果使用该特性，就表示浏览器需要提供默认的播放控件。\nautoplay：如果使用了该特性，就表示视频文件应该自动播放。\nloop：如果使用该特性，就表示在视频结束之后重新播放。\npreload：该特性告诉浏览器在页面加载时需要做什么。它可以选用以下三个值：\nnone：该值表示在用户按下播按钮之前，浏览器不必加载视频。\nauto：该值表示浏览器应该在页面加载时载入视频。\nmetadata：该值表示浏览器只需收集少量视频信息，比如大小、首帧图像、播放列表和持续时间。\n\n\n\n&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;title&gt;Adding HTML5 Video&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;video src = &quot;video/puppy.mp4&quot;               poster = &quot;images/puppy.jpg&quot;               width = &quot;400&quot; height = &quot;300&quot;               preload               controls               loop&gt;            &lt;p&gt;                A video of a puppy playing in the snow            &lt;/p&gt;        &lt;/video&gt;    &lt;/body&gt;&lt;/html&gt;\n\n\nHTML5：多个视频源&lt;source&gt;\n要指定播放文件的路径，可以在&lt;video&gt;元素中使用&lt;source&gt;元素可以代替起始标签&lt;video&gt;中的src特性\n可以使用多个&lt;source&gt;元素来指定不同格式的视频。\n\nsrc &#x3D; 该特性用于指定视频的路径。\ntype &#x3D; 需要使用该特性来告诉浏览器视频的格式，不然它会加载一些视频，看看是否可以播放该文件（这会耗费时间并占用宽带）\ncodece &#x3D; 用来对视频进行编码的编码器也在type特性中指出。\n\n&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;title&gt;Multiple video Sources&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;video poster = &quot;images/1.jpg&quot; width = &quot;400&quot; height = &quot;320&quot; preload controls loop &gt;            &lt;source src = &quot;video/1.mp4&quot; type = &#x27;video/mp4;codecs = &quot;avcl.42E01E, mp4a.40.2&quot;&#x27; /&gt;            &lt;source src = &quot;video/1.webm&quot; type = &#x27;video/webm;codecs = &quot;vp8, vorbis&quot;&#x27; /&gt;            &lt;p&gt;                A voideo of a puppy palying in the snow            &lt;/p&gt;        &lt;/video&gt;    &lt;/body&gt;&lt;/html&gt;\n\nHTML5：向网页中添加HTML5音频使用托管服务：\n有些网站允许上传音频，它们还会提供一个可以嵌入到网页的播放器。比如SoundCloud.com和MySpace.com\n使用HTML5：\nHTML5引入了一个新元素&lt;audio&gt;。支持该元素的浏览器会提供默认的控件，和上面以及一样\n\n当访问者从网站中的一个网页跳转到另一个网页时，需要如AJAX的技术来加载页面的内容，也正因为如此，有些网站将音频播放器在新窗口中打开，这样听众在页面跳转时音乐就不会中断。\n\n&lt;audio&gt;\n&lt;audio&gt;元素包含许多可以用来控制音频播放的特性：\n\nsrc：该特性用于指定音频文件路径。\ncontrols：该特性表明播放器是否显示播放控件。如果没有使用该特性，播放控件就会默认隐藏。可以利用JavaScript来指定个性化控件。\nautopplay：该特性的出现表示音频应该自动开始播放。\npreload：该特性在播放器没有设置autoplay时告诉浏览器应该做什么。\nloop：该特性表示在音频播放结束后进行重新播放。\n\n&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;title&gt;Adding HTMLs Audio&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;audio src = &quot;audio/test=audio.ogg&quot; controls autoplay&gt;            &lt;p&gt;                This browser does not suppory our audio format.            &lt;/p&gt;        &lt;/audio&gt;    &lt;/body&gt;&lt;/html&gt;\n\nHTML5：多个音频源&lt;source&gt;\n在起始标签&lt;audio&gt;和结束标签&lt;/audio&gt;之间使用&lt;source&gt;元素可以指定多个音频文件(&lt;source&gt;元素可以替代起始标签&lt;audio&gt;中的src特性)。\n\n\nsrc：&lt;source&gt;元素使用src特性来表示音频文件位于何处。\ntype：type特性还有像在&lt;video&gt;元素中那样被广泛用在&lt;source&gt;元素中.\n\n\n","categories":["WebFrontend"],"tags":["html"]},{"title":"微信小程序技术","url":"/2023/03/11/WebFrontend/%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8/APP%20%E5%B8%B8%E7%94%A8%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F/","content":"简介小程序本质来说是前端，都是开发页面交互，以及数据请求业务逻辑\n如何学习看开发文档是最好且最快的学习方式，其次就是官方的视频教程，生动有趣\nAPP常用开发模式\nNative App – 原生开发\nWebApp – H5应用\nHyriid App – 混合开发\n\n\n微信小程序技术栈\nui库：WeUI，有赞的vantUI\nVue框架：腾讯Wepy，Uniapp，美团MpVue(停止维护)\nreact框架(多端支持)：阿里Remax，京东Taro\n跨端开发：Uniapp，Chameleon\n其它：低代码、云开发\n\n@GetMapping(&quot;/getSrmAreaTemplateByProjectId&quot;)  @ApiOperation(&quot;获得SRM区域数据映射列表&quot;)  @PreAuthorize(&quot;@ss.hasPermission(&#x27;biz:srm-area:query&#x27;)&quot;)  public CommonResult&lt;List&lt;SrmAreaRespVO&gt;&gt; getSrmAreaTemplateByProjectId(@RequestParam(&quot;projectId&quot;) Long projectId) &#123;\t/** 根据项目 ID 获取 SRM 区域数据映射列表 */    List&lt;SrmAreaDO&gt; list = srmAreaService.getSrmAreaTemplateByProjectId(projectId);      /** 将 `SrmAreaDO` 列表转换为 `SrmAreaRespVO` 列表。 */    List&lt;SrmAreaRespVO&gt; resp = SrmAreaConvert.INSTANCE.convertList(list);      for (SrmAreaRespVO vo: resp) &#123;          vo.setFlag(true);          vo.setTriggerFlag(false);      &#125;      return success(bulidTree(resp));  &#125;      private static List&lt;SrmAreaRespVO&gt; buildTree(List&lt;SrmAreaRespVO&gt; treeList) &#123;    Map&lt;Long, SrmAreaRespVO&gt; idToNodeMap = new HashMap&lt;&gt;();    // 将所有节点放入 idToNodeMap 中，方便后面查找父子关系    for (SrmAreaRespVO node : treeList) &#123;        idToNodeMap.put(node.getId(), node);    &#125;    List&lt;SrmAreaRespVO&gt; resultList = new LinkedList&lt;&gt;();    for (SrmAreaRespVO node : treeList) &#123;        if (node.getParentId() == 0L) &#123;            resultList.add(node);        &#125; else &#123;            SrmAreaRespVO parentNode = idToNodeMap.get(node.getParentId());            if (parentNode != null) &#123;                parentNode.getChildren().add(node);            &#125;        &#125;    &#125;    return resultList;&#125;\n\n\n首先要确认，我们要循环什么，\n","categories":["WEBbackend"],"tags":["移动应用"]},{"title":"js基础语法","url":"/2022/08/09/WebFrontend/JavaScript/js%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","content":"JavaScript简介什么是JavaScript前端 : 广义上就是所有用户界面都是前端, 狭义上就是网页上展示的内容\nhtml : 构建页面的结构\ncss : 描述元素的展示效果\njs : 响应用户行为, 交互等复杂操作\nJavaScript的发展历史\n1990年欧洲核能研究院在互联网上发明了万维网（规范制定了html）\n1992年美国超级电脑应用中心（NCSA）开发了人类历史上的第一个浏览器 Mosaic (浏览器风波)\n1994年 Netscape Navigator1.0 版浏览器问世\n1995年JavaScript 问世 &#x3D; 布兰登 艾奇 self c js的优秀之处就是他并非原创,他的原创并不优秀\n1996年微软抢占市场 ie Jscript\n1997年JavaScript提交给了ECMA(欧洲计算机制造商协会) 制定了一个国际化的标准JavaScript进入标准化时代 ECMA-262发布\n2009年 ECMAScript 5.0发布 &amp; node.js诞生 2008年的 浏览器引擎v8的诞生\n2010年 Express 发布 &amp; angular发布 NPM、BackboneJS和RequireJS 诞生\n\nJavaScript的特点\n解释性的语言\n动态语言(弱类型语言) let a &#x3D; 123 a &#x3D; ‘asdf’\n语法结构 和 c 和 java 非常相似\n基于原型的面向对象\n\nJavaScript的运行环境运行在网页中, 在浏览器中运行,他是一个脚本语言, js是一个不需要编译就能运行的语言, 他是嵌套进了html在浏览器中运行的语言, 它不仅仅只可以在浏览器中运行 , 也可以在任何搭载js引擎的地方运行 ,\n\nV8 — chrome , opear edge\nSpiderMonkey – firefox\n还有一些代号 chakra 用于 ie\n\n引擎的工作原理\n引擎读取脚本\n将脚本转换为机器语言\n机器语言快速执行\n\njs的组成部分\nECMScript : js的语法规范\nDOM : 文档对象模型, 描述处理网页页面和接口, 操作页面中的元素\nBOM : 浏览器对象模型, 提供了浏览器的操作的方法\n\n为什么要学习JavaScript？js在网页中的优势\n\n与html&#x2F;css完美集成\n简单的事情,简单的完成\n被所有浏览器支持并且默认开启\n\njs是将这三件事完美结合到一起的唯一的浏览器技术\n此外js还可以用于创建服务器和移动端的应用程序\n无可替代的js每个程序员都有自己的开发习惯和项目需求,对语言和有一定的要求, 所以市面上也会出现许多新的语言能来实现网页的脚本 , 但是这些语言在浏览器执行之前都会被编译成为js\n例如\n\ntypeScript : 有更加严格的数据类型的js\ncoffeeScript\nflow\ndart\nbrython\n\njs能做啥\nAtwood定律：“任何可以使用JavaScript来编写的应用，最终会由JavaScript编写。\n根据JavaScript具备的语言特性，他能做的事情将超乎你的想象，\n\njs能做啥前端领域\n\n有dom 可以操作 html页面结构样式 ui动画\n有bom 可以响应浏览器的事件，操作浏览器\n根据dom实现的用户行为交互\n前端数据的验证\n前后端数据的交互 （ajax，axios）\n\n后端领域\n\nV8 JIT NodeJS 让JavaScript可以在服务端崭露头角，打破了JavaScript只能寄生在浏览器上的魔咒。CouchDB mongodb等基于JSON格式的NoSQL类型的数据库诞生，让JavaScript也可以在DB操作上大展身手。\n\n\nweb服务框架 express&#x2F;koa\n数据库编写 mongodb\n自动化构建领领域。gulp\n\n手机端\n桌面应用\n图形&#x2F;游戏\n嵌入式开发与iot开发\nJS声明变量关键词变量用于存储数据\n需要先声明变量，才能使用\n声明变量使用关键词主要有三个：let、const、var\n\nvar关键词是老版本（ES5）JS所使用，现在已经淘汰\n\nletlet是新版本用于声明变量的关键词，let声明的变量为普通变量\n用法：\nlet a = 1// 或者let aa = 1\n\n上述使用let声明一个变量，变量名为a，值为1\n变量的使用正确用法：\n// 先声明变量【此为注释】let a = 1 // 声明时进行赋值// 后使用变量alert(a) // 此处浏览器弹窗：1\n\n上述代码也可以\nlet a // let变量可以声明时不赋值a = 1 // 对变量a进行赋值alert(a) // 弹窗：1\n\n错误用法：\n// 此处先使用变量alert(a) // 此处会报错// 后进行声明，为错误用法，因为在使用时，变量未被声明，所以会报错let a = 1\n\n\n结论：\n变量必须先声明后使用！！！\n先使用，后声明会报错\n\n变量的声明在同一环境中（同一作用域内）所有变量名称不能冲突，否则报错\nlet a = 1// 此处为其他代码let a = 1 // 此处会报错\n\n\n结论：\n变量禁止在同一作用域内重复声明\n\n作用域的概念在后续章节进行讲解\n更改变量值let声明的变量的值可以进行更改\nlet a = 1alert(a) // 此处弹窗：1a = 2 // 此处更改了变量a的值为2，后续再使用a时，值就是aalert(a) // 此处弹窗：2\n\n\n结论：\n更改已声明变量的值时，直接对变量赋值即可，无需写声明关键词\n\nconstconst所声明的变量为常量，而非普通变量\n常量：常量是一种特殊的变量，该变量的值必须在声明时就设置，且后续无法进行更改。\nconst a = 1 // 声明常量a，值为1a = 2 // 此处修改常量的值是违规操作，所以会报错\n\n除此之外，const常量的特性跟let变量一致。\n数据类型数据类型是字面含义，表示各种数据的类型。在任何语言中都存在数据类型，因为数据是各种各样的。\nJavaScript主要包含8种数据类型，8种数据类型可以分为基础类型和引用型两个分类：\n\n基础型数据类型\nnumber 数字（包含整数和浮点数）\nstring 字符串\nboolean 布尔值\nundefined 未定义\nnull 空指针\nsymbol 符号\nbigint 大整数\n\n\n引用型数据类型\nobject 对象\n\n\n\n通常可以使用typeof操作符查看数据类型，但是请注意，在检测null值时返回的不是null类型，而是object类型，这是一个特例。\nNumberJavaScript不区分整数、浮点数等，统一都叫Number。typeof 100 得到 &quot;number&quot;。\n\n数值字面量\n10、1.5、-20\n\n浮点数精度问题\nconsole.log(0.1+0.2);\nconsole.log(0.7*100);\nJavaScript中采用 IEEE 754 标准 (opens new window)的 64 位双精度浮点数。数值的运行会先将数值转为二进制，而这种标准下小数可能会出现表示不全的情况，从而最终的结果出现误差。（有汇编基础的同学可以自行进一步了解）\n如果为了得到相对准确的结果，一般会将小数转为整数之后再进行运行，最后除以倍数。例如：console.log( (0.1*100+0.2*100)/100 );\n\n数值范围\n根据标准，64位浮点数的指数部分的长度是11个二进制位，意味着指数部分的最大值是2047（2的11次方减1）。也就是说，64位浮点数的指数部分的值最大为2047，分出一半表示负数，则 JavaScript 能够表示的数值范围为21024到2-1023（开区间），超出这个范围的数无法表示。\n如果一个数大于等于2的1024次方，那么就会发生“正向溢出”，即 JavaScript 无法表示这么大的数，这时就会返回Infinity。相反，最大负数为 -Infinity。\nInfinity 和 -Infinity 也是数字的一种。\n\n特殊值\nNaN是一个特殊的值，它的类型是number，表示一个损坏的数值，通常出现在有不能转换为数字的数据参与运算时产生。\n\n\nString用来放一段文字。typeof &quot;文字文字&quot; 得到 &quot;string&quot;。\n\n字符串字面量\n&quot;文字&quot; // 双引号&#x27;ababa&#x27; // 单引号`abcd` // 反引号\n\n三种引号都可以用来表示字符串数据。\n\n转义字符\n如果想在字符串使用引号文字：\nconsole.log(  &quot;It&#x27;s an apple.&quot;  ); //一种引号里面使用其他两种引号没有问题console.log( &quot;John:\\&quot;I love you.\\&quot;&quot; ); //内部使用字面量相同的引号，则需要使用 \\ 转义符号\n\n其他转义含义：\n\n\n字符串拼接\n进行 + 运算时，两边任意一边的数据是字符串的话，则是拼接的功能\nconsole.log(&quot;123&quot; + &quot;4&quot;); //&quot;1234&quot;console.log(&quot;123&quot; + 4); //&quot;1234&quot;console.log(&quot;zzt&quot; + &quot;666&quot;); //&quot;zzt666&quot;\n\nBoolean布尔值类型只有两个值：真true 和 假false。用于判断。\ntypeof true得到&quot;boolean&quot;。\nUndefined未定义类型的值为undefined。\n在变量没有被赋值时，默认值也为undefined。\ntypeof undefined得到&quot;undefined&quot;。\nNullnull 和 undefined 意义很接近，都表示“没有”。null可以理解为一个“空”对象，但是并不占据内存空间。通常在一个变量即将在后续的逻辑中被赋予一个对象值，但是刚开始定义的时候不能确定到底是哪个对象值时，赋予它初始值null。\n注意：typeof null得到&quot;object&quot;。\nSymbol\nsymbol是一种运用场景极少的数据类型，该类型数据在开发中，基本不会使用。所以了解即可\n\nSymbol值不可以进行运算\nSymbol实际上是ES6引入的一种原始数据类型，用它来产生一个独一无二的值。在JS中，基础数据类型通常只要“长得一样”在判断相等时，就是true，而在某些特定场合下，我们可能会需要一些独一无二的值来保证程序正常运行，比如给对象创建属性时，不会覆盖已有属性的情况。此时就需要Symbol.\nlet s1 = Symbol() // 通过Symbol函数创建一个symbol数据let s2 = Symbol() // 再创建一个console.log(s1) // 输出结果：Symbol()console.log(s2) // 输出结果：Symbol()// 它们俩长得一样，但是却不相等s1 == s2 // false\n\n结论：每次调用Symbol() 都会在程序中，创建一个独一无二的值\nBigInt\n该数据类型是在ES2020版本才加入的，所以2020之前的浏览器环境是不支持的。\n\nJavaScript在数字上一直都很糟糕，因为在没有bigint类型之前，数字只能表示-(2^53-1)至 2^53-1 范围的值，即Number.MIN_SAFE_INTEGER 至Number.MAX_SAFE_INTEGER，超出这个范围的整数计算或者表示会丢失精度。\nvar num = Number.MAX_SAFE_INTEGER;  // -&gt; 9007199254740991num = num + 1; // -&gt; 9007199254740992// 再次加 +1 后无法正常运算num = num + 1; // -&gt; 9007199254740992// 两个不同的值，却返回了true9007199254740992 === 9007199254740993  // -&gt; true\n\n于是 BigInt 应运而生，它是第7个原始类型，可安全地进行大数整型计算。 你可以在BigInt上使用与普通数字相同的运算符，例如 +, -, &#x2F;, *, %等等。\n创建 BigInt 类型的值也非常简单，只需要在数字后面加上 n 即可。例如，123 变为 123n。也可以使用全局方法 BigInt(value) 转化，入参 value 为数字或数字字符串。\nconst aNumber = 111;const aBigInt = BigInt(aNumber);aBigInt === 111n // truetypeof aBigInt === &#x27;bigint&#x27; // truetypeof 111 // &quot;number&quot;typeof 111n // &quot;bigint&quot;\n\n只要在数字末尾加上 n，就可以正确计算大数了：\n1234567890123456789n * 123n;// -&gt; 151851850485185185047n\n\n不过有一个问题，在大多数操作中，不能将 BigInt与Number混合使用。比较Number和 BigInt是可以的，但是不能把它们相加。\n1n &lt; 2 // true1n + 2// Uncaught TypeError: Cannot mix BigInt and other types, use explicit conversions\n\nBigInt的支持情况：\n\nObject类型JavaScript中object类型包含的数据有很多，数组、普通对象、DOM节点、内置对象、函数等等都属于obejct类型。\n\n数组\n一个数组中可以存放一组数据。\n\n取值使用 [数字序号] 下标，序号从0开始计数。取值超出序号最大值时，得到undefined。\nlet arr = [10,50,true,&quot;Fly&quot;];console.log(arr[2]); //trueconsole.log(arr[6]); //undefined\n\n数组中可以存放数组。\nlet arr = [    10,    [        &quot;夏栀&quot;,        &quot;锦鲤&quot;,        [            true,            false        ]    ]];console.log(arr[0]); //10console.log(arr[1][0]); //&quot;夏栀&quot;console.log(arr[2][1]); //false\n\n数组拥有 length 属性，可以得到数组存放的数据的个数。\nlet a = [10,20];let b = [7,8,9];let c = [4,5,,6,];console.log(a.length); //2console.log(b.length); //3console.log(c.length); //4 最后一个,后面没有值的话，不算个数，中间的,之间即使没有数据也算个数\n\n数组可以取值，可以修改值或者新增值\nlet arr = [4,5];arr[0] = 44;arr[2] = 6;console.log(arr); // [44,5,6]let arr2 = [7,8,9];arr2.length = 2;console.log(arr2); //[7,8]\n\n\n普通对象\n\n对象以键值对的形式存储数据。键也就是对象的属性，值就是一个具体的数据。\n属性的命名规则和变量命名规则有点相似，但是属性名更宽松。属性名允许是数字，不规范的属性名字可以加&quot; &quot;变成一个正确的属性名。\nlet xz = &#123;    name : &quot;夏栀&quot;,    &quot;age&quot; : 18,    //属性可以加 &quot;&quot; 类似字符串的写法，也可以不加    &quot;a b c&quot; : true, //不规则的属性名，必须加 &quot;&quot;，不加会报错    20 : null //自然数数字可以充当属性名，不必加 &quot;&quot;&#125;;\n\n取值时使用 . 操作符。\nlet xz = &#123;    name : &quot;夏栀&quot;,    age : 18,    marry : false,    friends : [&quot;锦鲤&quot;,&quot;思思&quot;]&#125;;console.log( xz.age ); //18console.log( xz.friends[0] ); //&quot;锦鲤&quot;console.log( xz.hobby ); //undefined\n\n当属性是一个数据时，使用 [] 来取值\nlet xz = &#123;    name : &quot;夏栀&quot;,    age : 18,    marry : false,    friends : [&quot;锦鲤&quot;,&quot;思思&quot;]&#125;;console.log( xz.name ); //&quot;夏栀&quot;console.log( xz[&quot;name&quot;] ); //&quot;夏栀&quot;let a = &quot;age&quot;;console.log( xz[a] ); //18console.log( xz.a ); //undefined\n\n对象可以取值，也可以重新赋值，也可以新增属性\nlet obj = &#123;a : 10&#125;;obj.a = 20;obj.b = 30;console.log(obj); // &#123;a:20,b:30&#125; \n\n\n内置对象\nJavaScript语法中本来已经存在的对象，称之为内置对象。这些对象一般都已经包含了很多属性和方法，功能健全丰富，我们可以直接哪来使用。例如 window document Math。\n\n函数\nJavaScript中函数也是对象类型，是一个极为特殊的对象。\n\n定义函数\nlet a = function()&#123;    //这里可以写任意js代码&#125;;function b()&#123;    //这里可以写任意js代码&#125;\n\n函数执行\nfunction fn()&#123;    alert(123);&#125;//函数不执行是，内部函数不会运行。//函数加 () 可以自执行fn();\n\n更多函数相关的知识在后续章节会详细介绍\n\n\n\n\nobject类型的数据，typeof会得到object，但是函数在typeof时得到function。\n运算符算术运算符加(+) 减(-) 乘(*) 除(/) 取余(%) 乘方(**)// 加法运算let a = 1let b = a + 2 // 此时b等于3// 减、乘、除同理\n\n重点说下取余运算\n取余运算即是字面含义，取除运算的余数，有时也叫模运算\n// 例如：5 除以 3  商为1   余数为2let a = 5 % 3 // 此时a存储的就是5除以3的余数2let b = 6 % 2 // 此时能整除，所以余数为0，则b的值为0// 小模大的余数// 例如：3 除以 5，因为被除数比除数小，所以此时商为0，余数为3let c = 3 % 5 // 此时 c = 0let d = 2 % 10 // d = 0// 所以：小值对大值取余运算时，余数为小值\n\n接着来看乘方运算，乘方运算就是计算某个数的n次方的结果\n// 例如：计算5的平方let a = 5 ** 2 // 等同于 a = 5 * 5 ==&gt;  a = 25let b = 4 ** 4 // b = 256let c = 2 ** 3 // c = 8\n\n赋值运算符等于(=) 加等于(+=) 减等于(-=) 乘等于(*=) 除等于(/=) 取余等于(%=) 乘方等于(**=)\n\n看起来虽然多，但是比较比较容易理解\n\n通常看到等号，要先计算等号右边\n\n// 等于 以下两种都是等于运算，简单来说 就是对变量赋值let a = 1 let b = 1 + 3// 后续的带了运算符的都是同一个原理// 例如: +=let a = 1a += 1 // 此时a=2，因为a += 1等价于 a = a + 1// 其他同理\n\n比较特殊的两个赋值运算符自增1(++)、自减1(--)\nlet a = 1a++ // 此时a = 2，因为a的自增1运算，可以理解为 a += 1，也就是 a = a + 1// 同理let b = 3b-- // 此时b = 2，因为b的自减1运算，可以理解为 b -= 1，也就是 b = b - 1\n\n所以自增和自减，是在自身原始值的基础上，进行增1或者减1计算，并且会改变自身的值，有赋值运算的效果\n需要注意的是，自增和自减还有一些需要注意的地方，以自增为例\nlet a = 1let b = a++ // 请注意，此时 b = 1\n\n原因是自增和自减，有两种情况，一种为后置自增或后置自减，另外一种为前置自增和前置自减，写法就是符号写在后面和前面的区别：前置自增：++a、后置自增：a++，自减同理。\n接下来我们来看下上述为何b&#x3D;1，而不是2，原因是后置自增和后置自减参与其他运算时，是先将原始值完整参与其他运算后，才进行自增；而前置自增和前置自减，是先将原始值自增或自减后，才参与其他运算。有一个先后顺序的问题。\nlet a = 1let b = a++ // 此时 b = 1，a = 2\n\n是因为这里有一个自增运算，同时还有一个赋值的等于运算，而a的自增是后置的，所以此处程序先将a的原始值1参与其他运算（此处是赋值运算）后才会自增，所以b接收到的是原始值1，而后，a自增为2。所以结果为：b=1 a=2，自增运算同理。\nlet a = 1let b = ++a // a = 2  b = 2\n\n根据上述原理，此时a的前置自增，会先进行自增，后参与赋值运算，所以a=2 b=2\n\n赋值运算符是非常简单的运算符，唯一需要关注的是自增和自减的情况。自增和自增还有一个特殊的功能，后一个章节讲解\n\n比较运算符大于(&gt;)、小于(&lt;)、相等(==)、不相等(！=)、全等(===)、不全等(!==)、大于等于(&gt;=)、小于等于(&lt;=)\n\n比较运算符的结算结果，永远都是一个布尔值，条件成立为true，不成立为false\nlet a = 2 &gt; 1 \t// a = truelet b = -5 &gt; 1 \t// b = false\n\n需要注意的是相等和全等的区别（不相等和不全等同理）\n相等判断运算时，如果两个运算数类型不相同时，会先转换为同一个类型，再进行比较，如果相等则结果为true，反之false，而不全等运算时，如果两个运算数类型不相同，则立刻返回false，不进行任何类型转换，如果类型相同，则正常比较，根据结果返回值。\nlet a = 1 == &quot;1&quot;\t// 请注意，第一个运算数是数字1，第二个则是字符串1// 此时 a = true，由于此时是相等比较，所以会将字符串1转换为数字后进行比较。let b = 1 === &quot;1&quot; // b = false// 此时，由于两个数类型不同，所以全等运算时，直接返回false// 不相等和不全等同理\n\n字符串再比较大小时，是按位比较各自的编码。&quot;3&quot;&gt;&quot;20&quot;得到true\n对象在做相等判断时，比较的是内存地址。\n关于不同类型的值进行比较运算时，类型的转换规则参考下表：\n\n\n\n值\n字符串操作环境\n数字运算环境\n逻辑运算环境\n对象操作环境\n\n\n\nundefined\n“undefined”\nNaN\nfalse\nError\n\n\nnull\n“null”\n0\nfalse\nError\n\n\n非空字符串\n不转换\n字符串对应的数字值\nTrue\n\n\n\n空字符串\n不转换\n0\nfalse\nString\n\n\n0\n“0”\n不转换\nfalse\nNumber\n\n\nNaN\n“NaN”\n不转换\nfalse\nNumber\n\n\nInfinity\n“Infinity”\n不转换\ntrue\nNumber\n\n\nNumber.POSITIVE_INFINITY\n“Infinity”\n不转换\ntrue\nNumber\n\n\nNumber.NEGATIVE_INFINITY\n“-Infinity”\n不转换\ntrue\nNumber\n\n\nNumber.MAX_VALUE\n“1.7976931348623157e+308”\n不转换\ntrue\nNumber\n\n\nNumber.MIN_VALUE\n“5e-324”\n不转换\ntrue\nNumber\n\n\n其他所有数字\n“数字的字符串值”\n不转换\ntrue\nNumber\n\n\ntrue\n“true”\n1\n不转换\nBoolean\n\n\nfalse\n“false”\n0\n不转换\nBoolean\n\n\n对象\ntoString()\nvalue()或toString()或NaN\ntrue\n不转换\n\n\nSymbol\ntoString()\nError\ntrue\nSymbol\n\n\nBigInt\ntoString()\n不转换\n除0n都是true\nBigInt\n\n\n逻辑运算符与(&amp;&amp;)、或(||)、非(!)\n\n\n与运算和或运算可以理解为一个管道\n\n与是和的意思，true能通过，false不通过\n或就是或者, false通过，true不通过\n非也叫取反。\n逻辑运算符在运算时，会在计算时，临时将运算数转换为布尔值。\nlet a = 1let b = 2let c = a &amp;&amp; b // 此时 c = 2\n\n与运算时，a被转为布尔值true，根据与运算符的特性，true通过了，所以取到右边的值。c就等于右边的值2\nlet a = 0let b = 2let c = a &amp;&amp; b // c = 0\n\n此时a转为布尔值false，false不能通过&amp;&amp;，所以停下来了，就取到了a的值，所以c等于0\n或运算跟与运算则行为相反\n关于各种值转为布尔值的情况，记住以下几个值即可：\nJS中所有的值只有如下6个值可以转为false，除了这6个值，其他的都是转为true\n\n数字：NaN\n空指针：null\n未定义：undefined\n数字：0\n布尔值：false\n空字符串：“”\n\n非运算是将运算符之后的值临时转为布尔值后，取其相反值\nlet a = 1let b = !a // b = false\n\na是数字1，转为布尔值为true，所以相反值为false，则b = false\nlet a = 0let b = !a // b = truelet a = &quot;&quot;let b = !a // b = truelet a = &quot;JavaScript真是太简单了&quot;let b = !a // b = false\n\n运算符优先级运算符优先级\n拓展知识（不用掌握）位运算位运算直接对内存中表示数据的位进行操作，所以运算效率是最高的。\n位运算时会将数值转换为32位整型来进行运算，所以位运算遇到小数时，直接处理掉小数部分当成整数来运算。并且要是一个数的二进制表示超过32位，或者运算完后超过32位，那么就会出问题。所以不是所有的情况都适用位运算。\n32位中，前31位表示数值，第32位表示符号，例如：3 的32位表示为：00000000 00000000 00000000 00000011。（PS：短除法求二进制）。\n负数会以二进制补码的形式来表示，规则是：\n//以 -3 为例子//第一步：取负数对应的正数的二进制码，例子中取 3 的二进制码00000000 00000000 00000000 00000011 //3的二进制码//第二步：取得到的二进制码的反码，0变1  1变011111111 11111111 11111111 11111100 //二进制反码//第三步：反码加111111111 11111111 11111111 11111101 //得到-3的二进制表示\n\n位运算操作符：按位非~ 、按位与&amp;、按位或|、按位异或^、左移&lt;&lt;、无符号右移&gt;&gt;&gt;、有符号右移&gt;&gt;。\n\n~ 按位非\n\n每一位取反，例：\nlet a = 12;let b = ~a;// 12的二进制表示：     00000000 00000000 00000000 00001100// 按位非得到最终结果： 11111111 11111111 11111111 11110011  //因为 第32位是1，代表负数，那这个负数是多少呢？按照上面的办法我们可以反推回来：//负数码减-1：         11111111 11111111 11111111 11110010//结果取反码：         00000000 00000000 00000000 00001101//表示的正数是：13，所以该负数为  -13alert(b); //验证一下\n\n所以按位非的结果为 该数负数减1， ~12 === -13 ~-5 === 4\n\n&amp; 按位与\n\n与是两个数之间的操作，两个数每一位的值 1 1 得1 1 0得0 0 1得0 0 0得0，例：\nlet a = 11 &amp; 4;//11的二进制  00000000 00000000 00000000 00001011//4 的二进制  00000000 00000000 00000000 00000100//按位与      00000000 00000000 00000000 00000000//结果为 0alert( a ); //验证一下\n\n\n| 按位或 ^ 按位异或\n\n这就和上面一个道理了，或都应该能理解 11得1 10得1 01得1 00得0，\n异或：11得0 10得1 01得1 00得0\n\n&lt;&lt; 左移\n\n二进制码左移几位，右边的空位补0\nlet a = 4 &lt;&lt; 2;//4的二进制码： 00000000 00000000 00000000 00000100//左移2位：  00 00000000 00000000 00000000 000100    //左边超过32的就不用管了，右边少于8位的补0    //得到：        00000000 00000000 00000000 00010000  // 16alert(a); //验证一下\n\n左移是不会改变符号位的，相当于原来的数乘以 2的几次方。\n\n&gt;&gt;&gt; 无符号右移 &gt;&gt; 有符号右移\n\n有符号右移：不动符号位，二进制码右移，左侧补0，原理和上述一样。\n无符号右移：移动所有位包括符号位，整体右移，左侧补0，所以如果负数进行无符号右移，会得到一个很蛋疼的数。\n\n位运算的运用\n\n左移右移来进行相对于 2的乘方 运算。\n强制取整，位运算直接会舍弃小数，例如：let a = 12.12 | 0;，直接舍弃小数位，并且或上0不会影响整数位。\n判断奇偶，奇数 &amp; 1 一定是 1 偶数 &amp; 1一定是 0\n类型转换类型转换是将某个数据转换为其他类型的数据的操作。\n可以参考表格\n\n\n\n值\n字符串操作环境\n数字运算环境\n逻辑运算环境\n对象操作环境\n\n\n\nundefined\n“undefined”\nNaN\nfalse\nError\n\n\nnull\n“null”\n0\nfalse\nError\n\n\n非空字符串\n不转换\n字符串对应的数字值\nTrue\n\n\n\n空字符串\n不转换\n0\nfalse\nString\n\n\n0\n“0”\n不转换\nfalse\nNumber\n\n\nNaN\n“NaN”\n不转换\nfalse\nNumber\n\n\nInfinity\n“Infinity”\n不转换\ntrue\nNumber\n\n\nNumber.POSITIVE_INFINITY\n“Infinity”\n不转换\ntrue\nNumber\n\n\nNumber.NEGATIVE_INFINITY\n“-Infinity”\n不转换\ntrue\nNumber\n\n\nNumber.MAX_VALUE\n“1.7976931348623157e+308”\n不转换\ntrue\nNumber\n\n\nNumber.MIN_VALUE\n“5e-324”\n不转换\ntrue\nNumber\n\n\n其他所有数字\n“数字的字符串值”\n不转换\ntrue\nNumber\n\n\ntrue\n“true”\n1\n不转换\nBoolean\n\n\nfalse\n“false”\n0\n不转换\nBoolean\n\n\n对象\ntoString()\nvalue()或toString()或NaN\ntrue\n不转换\n\n\nSymbol\ntoString()\nError\ntrue\nSymbol\n\n\nBigInt\ntoString()\n不转换\n除0n都是true\nBigInt\n\n\n显示类型转换转换方法：\n\n转数字：Number()\n转字符串：String()\n转布尔值：Boolean()\n转字符：Symbol()基本没有该需求\n转大数字：BigInt()\n\n常见需求是在数字、布尔值、字符串三者之间进行转换\nlet a = 1let r1 = String(a) // 将a转换为字符串let r2 = Boolean() // 将a转换为布尔值let b = &quot;123&quot;let r3 = Number(b) // 将b转换为数字，请注意，如果字符串内不全是数字字符时会转换成坏值NaNlet r4 = Boolean(b) // 将b转为布尔值// 布尔值转换为数字时，true转为1 false转为0，转为字符串时相当于给对应的值加上引号\n\n\n以上通过对应的数据类型的接口转换的方式叫显示类型转换\n\n隐式类型转换隐式转换是在使用非上面的接口转换时的叫法，通常这些转换情况容易被人忽略，所以叫隐式转换\n1. 转数字上一章提到的自增和自减，就具有隐式类型转换的功能，会将变量转换为数字\nlet a = &#x27;123&#x27; // 此时a是字符串，而不是数字a++  // 此时 a = 124，\n\n因为自增和自减具备类型转换的功能，会先将a转换为数字，再进行自增\n同时在比较大于、小于、小于等于、大于等于时，有数字参与的比较，也会将另外一个非数字转换为数字\n2.转字符串当有字符串参与的加法运算时，非字符串数据会被转换成字符串，然后将两个字符串合并\nlet a = &quot;123&quot;let b = truelet c = a + b// c = &quot;123true&quot;\n\n判断判断是代码流程控制的一个重要环节，绝大多数逻辑的实现都离不开判断。\n1. if判断写法：\n//单个ifif( 条件 )&#123;    //条件为真时执行的代码&#125;//if elseif( 条件 )&#123;    //条件为真时执行的代码&#125;else&#123;    //条件为假时执行的代码&#125;//多个elseif( 条件1 )&#123;    //条件1为真时执行的代码&#125;else if( 条件2 )&#123;    //条件1假 条件2真时执行的代码&#125;else if( 条件3 )&#123;    //条件1条件2都为假 条件2为真时执行的代码&#125;//可以一直列下去，可以if()&#123;&#125;结束，也可以else&#123;&#125;结束。\n\n2. 三目运算真语句为一条，假语句也只有一条时，我们可以将这种if else改为三目写法；\n条件 ? 真执行的语句 : 假执行的语句;//设 前文已定义变量 a  b//ifif( a &gt; b )&#123;    oBox.className = &quot;goudan&quot;;&#125;else&#123;    oBox.className = &quot;dachui&quot;;&#125;//三目 oBox.className = a&gt;b ? &quot;goudan&quot; : &quot;dachui&quot;;\n\n三目不一定比if好，有些时候看起来三目比if更直观，但是有些时候if看起来会比三目更直观。\n\n() 结合三目的使用\n\n真语句或者假语句不止一条时，是不是不能用三目呢，不一定哈，比如：\n//ifelseif(2&gt;5)&#123;    console.log(1);    console.log(1);    console.log(1);&#125;else&#123;    console.log(2);    console.log(3);    console.log(4);&#125;//改成三目2&gt;5?(    console.log(1),    console.log(1),    console.log(1)\t):\t(    console.log(2),    console.log(3),    console.log(4)\t);\n\n3. switch特殊形式的ifelse可以改写为switch，更清晰。\n例： （注意关键词 switch case break default）\n//设 前文已定义变量a//if elseif( a === &quot;阿飞&quot; )&#123;    //code1&#125;else if( a === &quot;风屿&quot;  )&#123;    //code2&#125;else if( a === &quot;夏栀&quot; )&#123;    //code3&#125;else&#123;    //code4&#125;//switchswitch( a )&#123;    case &quot;阿飞&quot;:    \t//code1    \tbreak;    case &quot;风屿&quot;:    \t//code2    \tbreak;    case &quot;夏栀&quot;:    \t//code3    \tbreak;    default:    \t//code4    \tbreak;&#125;\n\n4. 使用 &amp;&amp; || 来代替判断有时候会用到，\n例：\n//设前文已定义变量a b//ifif(a)&#123;    somecode;&#125;//逻辑a &amp;&amp; somecode;//ifif( a &gt; b )&#123;    console.log(2);&#125;else&#123;    console.log(3);&#125;//三目console.log(   a&gt;b?2:3   );//逻辑运算console.log(    a&gt;b &amp;&amp; 2 || 3    );\n\n循环for循环是任何一门语言都会有个命令，用于反复执行某段代码。\n例如，循环代码块5次：\nfor (let i = 0; i &lt; 5; i++) &#123;  let text = `当前数字为$&#123;i&#125;`  console.log(text)&#125;// 输出结果：当前数字为0当前数字为1当前数字为2当前数字为3当前数字为4\n\n此例中，let i = 0是声明循环的计次变量，i &lt; 5是循环终止条件，i++是计次变量更新步长，&#123;&#125;内的所有代码为循环体内代码块。\n具体流程是：计次变量进行终止条件判断运算，如果结果为true，则循环体执行，结束后进行步长更新运算，从而得到新的结果再次参与判断；如果结果为false，则立刻终止循环；\n所以想要控制循环次数，可以通常改变判断条件实现，如果循环条件永远为true，则就是一个死循环。\nfor-infor-in循环是一种特殊循环，可用于循环对象或数组（通常循环数组，使用for-of）\nlet o = &#123;  name: &#x27;dapiaoliang&#x27;,  age: 18,  sex: &#x27;woman&#x27;&#125;// 将对象内的所有键值对循环输出, 此时可以使用for-infor (let key in o) &#123;  let text = `当前属性名：$&#123;key&#125;, 值：$&#123;o[key]&#125;`&#125;// 结果（这种循环输出顺序可能会不一样，但数量不变）当前属性名：name, 值：dapiaoliang当前属性名：age, 值：18当前属性名：sex, 值：woman\n\n由此可见，for-in 用于循环对象内所有的键值对，具体输出顺序可能会发生变化，但是每个键值对都会被循环一次。\nfor-offor-of时一种专门用于循环数组或类似数组结构（Iterator接口）的循环命令\nlet arr = [&quot;dapiaoliang&quot;, 18, &#x27;woman&#x27;]for (let value of arr) &#123;  let text = `当前值是：$&#123;value&#125;`  console.log(text)&#125;// 结果当前值是：dapiaoliang当前值是：18当前值是：woman\n\n类似for-in，可直接循环数组的每一项数据\nwhilewhile是for的一个变种。（不常用）\nwhile (条件) &#123;\t循环体&#125;\n\n当条件为true，循环体就会执行，这种循环没有计次变量，不需要更新步长。所以条件通常需要是一个可变参数，如果不是可变参数，就需要在循环体内，有明确的终止条件\ndo-whiledo-while是一种特殊的while循环（不常用）\ndo &#123;  循环体&#125;while(条件)\n\n看起来是将while的条件和循环体交换了位置，所以这种循环体，在第一次时，是不需要进行判断条件就会执行，执行结束后，再进行判断，判断结果决定下一次是否会循环\n\n所以，do-while的条件是决定下一次是否循环，而第一次永远都会执行，所以可以理解为至少执行一次的while循环\n\n跳出循环如果在循环体内由于某些原因，需要在代码块内跳出循环，可以使用对应的关键字。\nbreak用于永久终止此循环，continue用于终止当前这次循环（立刻进入下一次）\n例如，跳过i = 3时情况\nfor (let i = 0; i &lt; 5; i++) &#123;  if (i === 3) &#123;    continue  &#125;  let text = `当前数字为$&#123;i&#125;`  console.log(text)&#125;当前数字为0当前数字为1当前数字为2当前数字为4\n\n上述例子，在i=3时，循环体内判断为真，执行continue，那么此次后续两行代码不会执行，会立刻进入下一次循环。\nfor (let i = 0; i &lt; 5; i++) &#123;  if (i === 3) &#123;    break  &#125;  let text = `当前数字为$&#123;i&#125;`  console.log(text)&#125;当前数字为0当前数字为1当前数字为2\n\n此时判断内是break，那么当i=3时，执行了break，那么后续所有次数的循环都不会执行。break会把整个循环全部关闭。\n函数函数是由事件驱动的或者当它被调用时执行的可重复使用的代码块。通俗的说，函数是利用特定语法，将一段代码打包在一起，每次调用函数就可以让这个代码块内的代码全部执行，复用代码。\n\n要注意的是，函数跟循环不相似，循环是重复一定次数的执行代码，函数虽然可以重复执行代码，但是它很灵活，可以任意决定它调用的时机\n\n声明函数声明函数有两种方式\n// 方式一let fn1 = function () &#123;  // 代码块&#125;// 方式二function fn2 () &#123;  // 代码块&#125;\n\nfn1和fn2都是函数名字，这是两种不同声明方式写的位置不同。\n\n函数体内的代码，在声明时不会执行的。必须在调用函数后，才能执行\n\n调用函数函数调用只需要将函数名字加括号即可，一个函数可以重复调用无数次\nlet fn = function () &#123;  // 代码块&#125;fn()\n\n调用后，函数内的代码块就会执行\n例如：计算1 + 2的值，并且输出\nlet add = function () &#123;  let res = 1 + 2  console.log(res)&#125;// 第一次调用add() // 此时函数调用，函数体内的代码执行，输出3// 还可以再次调用add() // 此时再次调用，继续执行代码，输出3...\n\n这样我们就可以得到一个能自动计算1+2值的函数，但是这样很蠢…因为每次都只会计算1+2，计算其他值，就需要再写函数，很麻烦。所以…看下面\n函数参数为了不让函数内部的代码全部都固定死、每次执行都是固定结果，所以函数可以在调用时，可以从外部注入数据到内部使用，这种行为是通过函数参数完成的。\n想要使用函数参数功能，从外部注入数据，那么函数内就需要提前有占位的符号，这种符号就类似变量功能，称为形参，而注入的数据成为实参\n// 例如计算，1 + n的结果// 此时函数内需要一个n作为占位符，那么n需要提前声明let add = function (n) &#123; // 这个n是声明函数内会使用n（n就是形参）  let res = 1 + n // 这里使用n占位  console.log(res)&#125;// 调用时，可以传入不同的数据，作为此次调用n的实际数据，add(5) // 此时n=5，则执行后，输出：6 （传入的5就是此次传入的实参）add(10) // 输出：11...add(-10) // -9\n\n这样就得到一个能计算1+n的函数，如果需要的参数很多，依次写上占位符，将实参一次写在调用的括号内即可\n\n实参和形参的顺序是对应的，第一个形参接收第一个实参…以此类推\n形参需要遵守变量命名规范\n\nlet fn = function (a,b,c,d,e) &#123;&#125;fn(1,2,3,4,5)\n\n虽然形参和实参可以让函数使用起来非常灵活，但是这样并不是万能的。\n例如，需要计算所有传入的实参的和。\nlet add = function (a， b, c)&#123;  // 如果实参个数不确定，那么形参就不好写，因为写少了，多出来的实参就无法接收，写多了，可能又会没有值传入  let res = a + b + c&#125;add(1, 2) // 此时传入2个实参，形参3个，那么最后一个c就没有值就是undefined，此时进行运算会得到NaN\n\n通过上面例子，发现形参实参通常实在个数确定的时候使用，如果数量不确定就很尴尬…所以请看下面\nRest参数rest是剩余的意思，rest参数是用于函数参数不确定，每次传入的数量都不同，或者函数参数过多，但是又不想写那么多形参的情况，那么rest可以一次性全部接收\n// 例如，计算传入的所有数据let add = function (...rest) &#123;  let res = 0  for (let value of rest) &#123;    res += value  &#125;  console.log(res)&#125;add(1, 2) // 实参2个，此时rest接收到就是两个数据，  输出 3add (3, 5, 4) // 实参3个，rest内就是3个数据。输出 12\n\n通过上面例子，可以看出，rest非常灵活，可以用于接收所有实参\n如果需要接收部分参数，也可以这么做\nlet add = function (a, b, ...rest) &#123;&#125;add(1,2,3,4,5) // 此时 a = 1 b = 2 rest = [3,4,5]\n\n\n所以，rest是用于接收剩余没有被形参所接收的全部参数的。如果一个形参都没有，只有rest，那么rest接收所有，如果rest前面有形参，则先优先其他形参接收，剩余没有被接收的都在rest内。所以rest的名字非常形象【剩余参数】\n\n请注意的是，rest必须是最后一个参数，rest参数后面不能写其他形参。下面的写法都是错误的\nlet fn = function (...rest, a)&#123;&#125;let fn1 = function (a, ...rest, b)&#123;&#125;let fn2 = function (...rest, ...rest2) &#123;&#125;// 这三种都是错的。\n\n返回值上面的所有函数，数据只能从外传入内，然后在内部使用。无法将函数内的运算结果返回出外部使用。这是因为函数没有设置返回值。\n函数设置返回值使用return命令，return的作用是停止函数执行，并立刻返回后面的值\nlet add = function () &#123;  let res = 1 + 3  return res&#125;add() // 4\n\n函数内一旦执行到return的行，就会立刻返回值。下一行之后的代码都永远不会执行。\n箭头函数箭头函数是function函数在某些情况的特殊写法\nlet fn = function () &#123;  return 1 + 3&#125;// 上面fn函数执行后，立刻返回1+3的值，对应的箭头函数写法let afn = () =&gt; 1 + 3\n\n箭头函数=&gt;之后的内容就相当于function函数return之后的内容。但是这种写法只适合上面的情况。\nlet fn = function () &#123;  let a = 3  let b = 2  let c = a ** b  return c&#125;// 上面的函数，函数体内有多条语句时，需要下面写法let afn = () =&gt; &#123;  let a = 3  let b = 2  let c = a ** b  return c&#125;\n\n通过上面两个例子可以发现，如果箭头函数内有多条语句时，需要写花括号。没有花括号的适合，箭头后只能写一条语句，并且语句的结果会默认被return，有花括号时，如果需要返回值，需要明确写上return\n如果需要传参时：\nlet add = function (a, b, ...rest) &#123;  let res = a + b  for(let value of rest) &#123;    res += value  &#125;  return res&#125;// 以上函数等价于下面箭头函数let fn = (a, b, ...rest) =&gt; &#123;  let res = a + b  for(let value of rest) &#123;    res += value  &#125;  return res&#125;\n\n所以参数写法跟function函数是完全一致的。\n函数在对象内的简洁写法如果一个函数是对象内的某个属性的值，可以有简洁写法\nlet o = &#123;  fn: function () &#123;      &#125;&#125;// 以上是正常写法，跟下方写法完全等价let o1 = &#123;  fn () &#123;      &#125;&#125;\n\n作用域作用域通俗的说，是变量起作用的范围。因为每个变量都有对应的“生活环境”\nJavaScript中作用域主要分为以下几种：\n\n全局作用域（即script标签内的空间）\n函数作用域（每个函数的花括号内的部分）\n块作用域（除函数外，其他的花括号空间都是块作用域，如if的花括号）\n\n变量只提供给当前环境和当前环境的子环境进行使用。\n&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;utf-8&quot;&gt;\t\t&lt;title&gt;Examples&lt;/title&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;script&gt;\t\t\t// 此时这里是script内部，所以这个空间是一个全局作用域，在此环境声明的变量为全局变量\t\t\t\t\t\tlet a = 1 // a 为全局变量\t\t\tlet fn = function () &#123;\t\t\t\t// 这是函数体内，所以这个小空间是函数作用域\t\t\t\tlet a = 2 // 此时这个变量a服务与这个空间和这个空间的子空间\t\t\t\tconsole.log(a) // 当前使用的a在这个环境中存在，所以输出 2\t\t\t\t&#123;\t\t\t\t\t// 此处，直接写了一个花括号，那么就开启一个独立的空间\t\t\t\t\tconsole.log(a) // 此时当前空间没有a，所以向上个空间查找，就找到函数内的a，所以输出 2\t\t\t\t&#125;\t\t\t&#125;\t\t\tconsole.log(a)  // 此时的console语句是在全局环境执行，所以这里的a不是函数内的，而是全局环境的a  所以输出 1\t\t\tlet fn2 = function () &#123;\t\t\t\t&#123;\t\t\t\t\tconsole.log(a)\t\t\t\t\t// 此时这个块作用域自身空间没有a，向上级空间查找，上级空间是fn2的函数空间，也没有找到，继续向上级查找，在全局空间找到了，所以输出 1\t\t\t\t&#125;\t\t\t&#125;\t\t&lt;/script&gt;\t&lt;/body&gt;&lt;/html&gt;\n\n上图作用域结构如下图所示\n查找的规则是，先查找自身，如果查找到就用，就不在向上查找，如果没有依次向上层作用域找，直到找到为止。如果找到全局都没有找到对应名称的变量，则抛出错误xxx is not defined。这就是作用域的规则。\n常用APINumbertoFixed()四舍五入指定小数位数，返回结果为字符串\nlet num = 3.1415926// 保留两位小数let str1 = num.toFixed(2) // 3.14// 保留三位小数let str2 = num.toFixed(3) // 3.142\n\nNumber.isNaN()判断一个数是否是NaN\nNumber.isNaN(&#x27;123&#x27;) // false Number.isNaN(456) // falseNumber.isNaN(true) // falseNumber.isNaN(NaN) // true\n\nNumber.isFinite()检测某个值是否是有限数字\nNumber.isFinite(123) // trueNumber.isFinite(12346546546545646546464646465456456456) // trueNumber.isFinite(true) // falseNumber.isFinite(&#x27;abd&#x27;) // falseNumber.isFinite(NaN) // false\n\nNumber.isInteger()检测某个值是否为整数\nNumber.isInteger(123) // trueNumber.isInteger(123.0) // trueNumber.isInteger(123.1) // falseNumber.isInteger(&#x27;abc&#x27;) // false\n\nNumber.parseInt()parseInt() 函数可解析一个字符串，并返回一个整数。\nNumber.parseInt(&#x27;123.456&#x27;) // 123Number.parseInt(&#x27;123aaa&#x27;) // 123Number.parseInt(&#x27;123.456aaa&#x27;) // 123Number.parseInt(&#x27;a123&#x27;) // NaN\n\nNumber.parseFloat()parseInt() 函数可解析一个字符串，并返回一个浮点数。\nNumber.parseFloat(&#x27;123.456&#x27;) // 123.456Number.parseFloat(&#x27;123aaa&#x27;) // 123Number.parseFloat(&#x27;123.456aaa&#x27;) // 123.456Number.parseFloat(&#x27;a123&#x27;) // NaN\n\nStringcharCodeAt()返回指定位置的字符串unicode编码\nlet str = &quot;abcde&quot;str.charCodeAt(2)   // 99 \n\nString.fromCharCode()通过unicode编码排序值返回对应的字符\nString.fromCharCode(99) // c\n\nsubstring()substring( startNum , endNum ) 截取字符串\nlet str = &quot;hello&quot;str.substring(1,2) // e// startNum 参数为起始位置(包含), endNum 参数结束位置(不包含)// endNum 参数不写 默认截取所有的\n\nsubstr( )substr(startNum, length) 截取字符串\nlet str = &quot;hello&quot;str.substr(1,2) //el// startNum 参数为起始位置(包含), length 参数截取长度// length 参数不写 默认截取所有的\n\nslice( )slice 使用与substring 相同\ntrim()清除左右空格\nlet str = &quot; hello  &quot;str.trim() // &quot;hello&quot;\n\nreplace()replace( str , repStr ) 替换字符串\nlet str = &quot;12345abcdef&quot;let str1 = str.replace(2,4)console.log(str1) // 14345abcdef// str 参数为查找字符的被替换字符, repStr 参数值 将替换str值// 如果没有查询到将返回原字符串\n\nsplit()字符串切割成数组,从选择器切割\nlet str = &quot;hello&quot;console.log(str.split(&quot;e&quot;))  // [&quot;h&quot;, &quot;llo&quot;]\n\nindexOf()indexOf( Str[,num]) 查找到字符串返回下标,否则返回-1,\nlet str=&quot;hello&quot;console.log(str.indexOf(&quot;e&quot;)) // 1// Str 参数为查找字符, num 参数为查找开始位置// num参数不写 默认从0开始\n\nlastIndexOf()返回结果与indexOf相同, 检索方向为从后往前;\nincludes(),startsWith(),endsWith()\nincludes((str[,num]) 返回布尔值，表示是否找到了参数字符串\nstartsWith((str[,num]) 返回布尔值，表示参数字符串是否在原字符串的头部\nendsWith((str[,num]) 返回布尔值，表示参数字符串是否在原字符串的尾部\n\nlet str = &quot;apple banana&quot;;str.includes(&quot;apple&quot;) // truelet str = &quot;http://www.baidu.com&quot;;str.startsWith(&quot;http&quot;);      // truestr.startsWith(&quot;https&quot;);      // falselet str = &quot;http://www.baidu.com&quot;;str.endsWith(&quot;com&quot;);      // truestr.endsWith(&quot;cn&quot;);      // false// Str 参数为查找字符, num 参数为查找开始位置// num参数不写 默认从0开始\n\nrepeat()repeat(n) 将字符串重复n次\nlet str = &quot;夏栀&quot;;let repstr = str.repeat(3);console.log(repstr);  //夏栀夏栀夏栀// n 参数为重复几次   参数如果是小数，会被向下取整\n\nArraypush()push(data[,data]) 依次往数组最后添加数组项 ,可以添加多个\nlet arr = [1,2,3]let arr1 = arr.push(4,5)console.log(arr)  // [1,2,3,4,5]  // 返回值新数组的length    改变原数组\n\npop()删除数组最后一项\nlet arr = [1,2,3]let arr1 = arr.pop()console.log(arr) // [1,2]// 返回值是删除的数值  改变原数组\n\nshift()移除数组中第一项并返回该项\nlet arr = [1,2,3]let arr1 = arr.shift()console.log(arr)     // [2,3]// 返回值是删除的数值   改变原数组\n\nunshift()在数组前添加任意数组项,可以添加多个\nlet arr = [1,2,3]let arr1 = arr.unshift(0)    // 改变原数组       console.log(arr) // [0,1,2,3] // 返回值新数组的length          改变原数组\n\nsplice()splice(index,num,info) 具有截取,替换,添加方法\n//- index 从数组第几个项开始//- num  截取的数量 //- info 从截取位置开始添加数组项//- 会改变原数组  返回截取的数组let arr = [1,2,3,4,5]arr.splice(2,3,&quot;a&quot;,&quot;b&quot;)console.log(arr)//1)截取方法     截取数量let arr = [1,2,3,4]arr.splice(1,2)//2)添加方法    截取数量为零arr.splice(1,0,1)arr.splice(1,0,1,2,3)  // 添加多个  //4)替代方法    截取数量与添加相同arr.splice(0,0,5)\n\nsort()sort( function ) 数组排序\n// function 参数为一个函数体   函数体接收两个形参// 不传参数 根据ASCII码表 来比较数组中的第一个值排序let arr = [22,44,11,33,55]arr.sort(function(a,b)&#123;    return a - b //从小到大排列    return b - a //从达到小排列&#125;)console.log(arr)/*函数 return正数 不换位置\t返回大于0 换位置\t小于0 不会位置\t与每一项比较*/\n\nconcat()合并两个数组为一个新的数组 不改变原数组\nlet arr1 = [1,2,3]let arr2 = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]let arr = arr1.concat(arr2)console.log(arr)\n\njoin()join(str) 根据参数规则返回新的字符串 不改变原数组\nlet arr = [1,2,3,4]let arr1 = arr.join(&quot;-&quot;)console.log(arr1) // 1-2-3-4// 将数组合并成字符串\n\nreverse()数组反向排序 改变原数组\nlet arr = [1,2,3,4]let arr1 = arr.reverse()console.log(arr1)  // [4, 3, 2, 1]\n\nslice()slice(startNum,endNum) 截取数组\nlet arr = [1,2,3,4]arr.slice(1,3)// startNum 参数为起始位置(包含), endNum 参数结束位置(不包含)// endNum 参数不写 默认截取所有的\n\nArray.isArray()判断是否是数组\nlet arr = [1,2,3]console.log(Array.isArray(arr))//true\n\nArray.from()把类数组(获取一组元素,arguments)对象转成数组\nindexOf(Str[,num])查找到数组项返回下标, 否则返回-1, 与字符串使用一样\nlet arr = [1,2,3]arr.indexOf(2)// Str 参数为查找字符, num 参数为查找开始位置// num参数不写 默认从0开始\n\nincludes()查看数组中是否包含参数的值,返回布尔值\nvar arr = [&quot;apple&quot; , &quot;origan&quot;,&quot;banana&quot;];var a = arr.includes(&quot;apple&quot;);console.log(a);   // truevar b = arr.includes(&quot;apple2&quot;);console.log(b);   // false\n\nforEach循环数组,无返回值\nvar arr = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;]arr.forEach(function(value,index,arr)&#123;    console.log(value,index,arr);&#125;)\n\nmap正常情况下,需要配合return使用,返回新数组,如果没有return,这个就相当于forEach\nmap如果没有return 则返回元素项数个undefined组成的新数组\n// 整理数据结构let arr= [    &#123;title: &quot;aa&quot;,read: 100&#125;,    &#123;title: &quot;bb&quot;,read: 20&#125;,    &#123;title: &quot;cc&quot;,read: 50&#125;]let newArr = arr.map((item,index,arr) =&gt; &#123;    let json = &#123;&#125;;    json.shop = `*$&#123;item.title&#125;--`;    json.price = `￥$&#123;item.read&#125;元`    return json;&#125;)console.log(arr);console.log(newArr);\n\nreduce用的极少,比如求数组的和,阶乘都可以\nlet arr = [1,2,3,4,5,6,7,8,9,10]let res = arr.reduce((prev,cur,index,arr) =&gt; &#123;    return prev + cur;&#125;)console.log(res);  //55// prev是上一次的运算结果,cur是当前的值,index是当前的下标,arr是当前的数组\n\nObjectObject.assign(目标对象,需要合并的对象)\nlet json = &#123;a:1&#125;;let json2 = &#123;b:2&#125;;let json3 = &#123;c:3&#125;;let obj = Object.assign(&#123;&#125;,json,json2,json3);console.log(obj);     // &#123;a: 1, b: 2, c: 3&#125;\n\n定时器\nsetTimeout() 用来指定某个函数或字符串在指定的毫秒数之后执行 只执行一次\n\nclearTimeout() 清除定时器\n\n/*setTimeout() 有两个参数\t1.执行体 注意:函数传递参数可以把实参放在时间参数的后面(不兼容IE9及以下)\t2.时间 多久执行*/let a=0let fun =()=&gt;&#123;    a++    console.log(a)    setTimeout(fun,1000)&#125;setTimeout(fun,1000)//clearTimeout() //参数是定时器的名称let timer = 0let a = 0let fun=()=&gt;&#123;    a++    console.log(a)    timer = setTimeout(fun,1000)&#125;fun()document.onclick = ()=&gt;&#123;    console.log(&quot;定时器停止了&quot;)    clearTimeout(timer)&#125;\n\nsetInterval() 用来指定某个函数或字符串在指定的毫秒数之后执行 无限循环\n\nclearInterval() 清除定时器\n\n//传递参数是一样的结构let timer = setInterval(function()&#123;    console.log(1)&#125;,1000)document.onclick = ()=&gt;&#123;    console.log(&quot;定时器停止了&quot;)    clearInterval(timer)&#125;\n\nrequestAnimationFrame() 浏览器专门为动画提供的API 浏览器会自动优化方法的调用 页面不是激活的状态下 动画暂停 有效节省CPU开销 用法与setTimeout相似 只是不需要设置时间间隔\n\ncancelAnimationFrame()\n\n//复合动画帧的计时器,使得动画更流畅,也只是执行一次let timer = 0let a = 0function fun()&#123;    a++    console.log(a)    timer = requestAnimationFrame(fun)&#125;fun()document.onclick=()=&gt;&#123;    console.log(&quot;定时器停止了&quot;)    cancelAnimationFrame(timer)&#125;\n\n内置对象内置对象是系统预先提供的一些特殊对象，能实现不同的功能\nMathMath是数学对象，跟数学相关的api都在其身上\n下面来了解些常用对象\n\nMath.random() 随机生成0到1之间的数 包括0不包括1\ndocument.onclick = ()=&gt;&#123;    console.log(Math.random())&#125;//生成任意范围的随机数let getRandom = (min,max)=&gt; Math.random()*(max-min)+mindocument.onclick =()=&gt;&#123;    let x = getRandom(5,10)    console.log(x)&#125;\n\nMath.ceil() 向上取整(天花板值) 遇到小数向上取整\nconsole.log(Math.ceil(1.1)) //2\n\nMath.floor() 向下取整(地板值) 遇到小数向下取整\nconsole.log(Math.floor(1.9)) //1//返回整数部分function getInt(x)&#123;    x = Number(x)    return x&lt;0?Math.ceil(x):Math.floor(x)&#125;document.onclick = function()&#123;    console.log(getInt(0.5))&#125;//返回任意范围的随机整数function getIntRadom(min,max)&#123;    return Math.floor(Math.random()*(max-min)+min)&#125;console.log(getIntRandom(2,6))\n\nMath.round() 四舍五入\n\nMath.max() 取得最大值\n\nMath.min() 取得最小值\n//随机排序let arr = [2,4,8,7,1,6,9]document.onclick = function()&#123;    arr.sort(function()&#123;    \treturn Math.random()-0.5\t&#125;)\tconsole.log(arr)&#125;\n\nMath.pow() 指数 第一个参数为底数 第二个参数为幂\n\n\n数学弧度与角度//60° = π/3//90° = π/2  角度转弧度//弧度 = 角度 * π/180//求一个半径为5的圆心面积let x = 5let y = Math.PI*Math.pow(x,2) // 圆心面积算法注意:JS三角函数里面的参数值不是角度 是角度对应的弧度值//30度角对应的弧度制let angle = 30let randian = angle*Math.PI/180  //角度转换成弧度x/30\n\n三角函数\nMath.sin() 返回正弦 参数为弧度值\nMath.cos() 返回余弦\nMath.tan() 返回正切\nMath.asin() 返回反正弦\nMath.atan() 返回反正切\nMath.acos() 返回反余弦\n\n其他API可参考MDN\n第三方插件：mathjs安装&lt;script src=&#x27;https://cdn.bootcdn.net/ajax/libs/mathjs/9.3.2/math.min.js&#x27;&gt;&lt;/script&gt;\n\n上面代码放到head标签中即可\n该插件方法集成在对象math上，请注意math不是Math\n大写Math是内置的，math是插件\n该插件功能较多，建议查看官网：mathjs\n方法这里主要讲几个常用的api\n计算表达式结果math.evaluate(&#x27;1 + 2 * 3&#x27;) // 7math.evaluate(&#x27;(1 + 2) * 3&#x27;) // 9math.evaluate(&#x27;1 + 2^2&#x27;) // 5math.evaluate(&#x27;1 - sqrt(4)&#x27;) // -1            sqrt(4)开平方根\n\n解决0.1+0.2问题JS中的数字是用IEEE 754 双精度 64 位浮点数来存储的，它由64位组成，这种方式当十进制小数的二进制表示的有限数字超过 52 位时，在 JavaScript 里是不能精确存储的，这时候就存在舍入误差\n所以很多采用双精度64位浮点数方式存储数字的语言都是这个结果0.1+0.2=0.30000000000000004\n此时可以用mathjs提供的大数字进行运算，就能解决这种问题\nmath.config(&#123;  number: &#x27;BigNumber&#x27;,  precision: 64&#125;)math.evaluate(&#x27;0.1+0.2&#x27;).toString() // 0.3   //此时evaluate返回是一个对象，想要得到能理解的结果，调用toString方法即可\n\n随机数正常来说，原生Math.random只能随机0到1之间的数字，用起来很不方便\nmath.random(min, max)可随机指定区间的任意数字，min指定最小边界，max最大边界，区间为左闭又开\nmath.random(1, 5) // 随机1到5区间任意数字\n\nmath.randomInt(min, max)，可随机指定区间的任意整数，min指定最小边界，max最大边界，区间为左闭又开\nmath.randomInt(1, 5) // 随机1到5之间任意整数\n\n四舍五入math.round(浮点数，保留位数)保留小数位四舍五入\n// 保留三位小数math.round(3.1415926, 3) // 3.142  \n\n原生Math上的方法在mathjs上也存在，功能基本一致。\n日期对象创建日期对象//Date() 当前电脑时间戳console.log(Date())let nowT = new Date() //new一个时间对象,可以接受参数来设置时间戳console.log(nowT) //返回当前时间let nowT = new Date(123456789) //这个参数是一个毫秒值 从1970年1月1日00:00:00开始加上这个一个毫秒值let nowT = new Date(&quot;January 6,2014&quot;) //参数为日期字符串let nowT = new Date(2019,5,1,19,30,50,20) //参数为多个整数包括:年 月 日 时 分 秒 毫秒  注意:这里的月份是从0开始的let nowT = new Date(&quot;2019-5-1&quot;)let nowT = new Date(&quot;2019/5/1&quot;)//注意:字符串参数是时间节点 数字参数会默认为毫秒值\n\n日期对象运算let nowT1 = new Date(2019,5,1)let nowT2 = new Date()console.log(nowT1 - nowT2) //得到的是一个毫秒值console.log(nowT1 + nowT2) //字符串的拼接\n\n日期对象的静态方法let nowT = Date.now() //返回当前事件距离1970年1月1日00:00:00之间的时间戳距离let nowT = Date.parse(2019,5,1) //接收一个日期字符串 返回从1970-1-1 00:00:00到该日期的毫秒数let noeT = Date.UTC(2019,5,1) //接收以逗号隔开的日期参数 返回从1970-1-1 00:00:00到该日期的毫秒数 接收的月份是0-11\n\n日期格式化方法\ntoDateString() 返回的是星期 月 日 年\nlet nowT = new Date()let Time = nowT.toDateString()console.log(Time)\n\ntoTimeString() 返回的是时 分 秒 时区\nlet nowT = new Date()let Time = nowT.toTimeString()console.log(Time)\n\ntoLocaleDateString() 返回的是年 月 日\nlet nowT = new Date()let Time = nowT.toLocaleDateString()console.log(Time)\n\ntoLocaleTimeString() 返回本地时 分 秒\nlet nowT = new Date()let Time = nowT.toLocaleTimeString()console.log(Time)\n\ntoUTCString() 返回对应的UTC时间 也就是国际标准时间 比北京晚8个小时\nlet nowT = new Date()let Time = nowT.toUTCString()console.log(Time)\n\ntoLocaleString() 返回本地时间\nlet nowT = new Date()let Time = nowT.toLocaleString()console.log(Time)\n\n日期方法\ngetTime() 返回一个毫秒值 到时间零点的距离\ngetFullYear() 返回年\ngetMonth() 返回月 注意:得到的月份是从0开始 要返回当前月需要加1\ngetDate() 返回日期\ngetHours() 返回小时\ngetMinutes() 返回分钟\ngetSeconds() 返回秒\ngetDay() 返回星期\ngetTimezoneOffset() 返回是当前事件与UTC的时区差异 以分钟数表示(考虑夏令营时)\n\n获取当前时间let nowT = setInterval(()=&gt;&#123;    let oWrap = document.getElementById(&quot;wrap&quot;)    let date = new Date(),    \toYear = date.getFullYear(),    \toMonth = date.getMonth(),    \toDate = date.getDate(),    \toHours = date.getHours(),    \toMinut = date.getMinutes(),    \toSecond = date.getSeconds(),    \toDay = date.getDay(),    \taDayArr = [&quot;日&quot;,&quot;一&quot;,&quot;二&quot;,&quot;三&quot;,&quot;四&quot;,&quot;五&quot;,&quot;六&quot;];    oWrap.innerHTML = `现在的时间是$&#123;oYear&#125;年$&#123;oMonth&#125;月$&#123;oDate&#125;日,星期$&#123;aDayArr[oDay]&#125;,$&#123;oHours&#125;时$&#123;oMinut&#125;分$&#123;oSecond&#125;秒`&#125;,1000)let add0 = n =&gt; n=n&lt;10?&quot;0&quot;+n:n+&quot;&quot;\n\n第三方插件：date.js安装Datejs是一个用来操作日期的库，官方网站为datejs.com。\n下载后插入网页，就可以使用。\n&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/datejs/1.0/date.min.js&quot;&gt;&lt;/script&gt;\n\n官方还提供多种语言的版本，可以选择使用。\n// 美国版&lt;script type=&quot;text/javascript&quot; src=&quot;date-en-US.js&quot;&gt;&lt;/script&gt;// 中国版&lt;script type=&quot;text/javascript&quot; src=&quot;date-zh-CN.js&quot;&gt;&lt;/script&gt;\n\n方法Datejs在原生的Date对象上面，定义了许多语义化的方法，可以方便地链式使用。\n日期信息Date.today() // 返回当天日期，时间定在这一天开始的00:00 Date.today().getDayName() // 今天是星期几Date.today().is().friday()      // 今天是否为星期五，返回true或者falseDate.today().is().fri()         // 等同于上一行Date.today().is().november()    // 今天是否为11月，返回true或者falseDate.today().is().nov()         // 等同于上一行Date.today().isWeekday() // 今天是否为工作日（周一到周五）\n\n日期的变更Date.today().next().friday()    // 下一个星期五Date.today().last().monday()    // 上一个星期一new Date().next().march()       // 下个三月份的今天new Date().last().week()        // 上星期的今天Date.today().add(5).days() // 五天后Date.friday() // 本周的星期五Date.march() // 今年的三月Date.january().first().monday() // 今年一月的第一个星期一Date.dec().final().fri() // 今年12月的最后一个星期五// 先将日期定在本月15日的下午4点30分，然后向后推90天Date.today().set(&#123; day: 15, hour: 16, minute: 30 &#125;).add(&#123; days: 90 &#125;)(3).days().fromNow() // 三天后(6).months().ago() // 6个月前(12).weeks().fromNow() // 12个星期后(30).days().after(Date.today()) // 30天后\n\n日期的解析Date.parse(&#x27;today&#x27;) Date.parse(&#x27;tomorrow&#x27;) Date.parse(&#x27;July 8&#x27;)Date.parse(&#x27;July 8th, 2007&#x27;)Date.parse(&#x27;July 8th, 2007, 10:30 PM&#x27;)Date.parse(&#x27;07.15.2007&#x27;)\n\n获取想要的格式// 想要拿到当前时间的格式：2021-05-22 17:00:00new Date().toString(&#x27;yyyy-MM-dd HH:mm:ss&#x27;)\n\n参数写法参考\n\n\nFormat\nDescription\nExample\n\n\n\ns\nThe seconds of the minute between 0-59.\n0 to 59\n\n\nss\nThe seconds of the minute with leading zero if required.\n00 to 59\n\n\nm\nThe minute of the hour between 0-59.\n0 or 59\n\n\nmm\nThe minute of the hour with leading zero if required.\n00 to 59\n\n\nh\nThe hour of the day between 1-12.\n1 to 12\n\n\nhh\nThe hour of the day with leading zero if required.\n01 to 12\n\n\nH\nThe hour of the day between 0-23.\n0 to 23\n\n\nHH\nThe hour of the day with leading zero if required.\n00 to 23\n\n\nd\nThe day of the month between 1 and 31.\n1 to 31\n\n\ndd\nThe day of the month with leading zero if required.\n01 to 31\n\n\nddd\nAbbreviated day name. Date.CultureInfo.abbreviatedDayNames.\nMon to Sun\n\n\ndddd\nThe full day name. Date.CultureInfo.dayNames.\nMonday to Sunday\n\n\nM\nThe month of the year between 1-12.\n1 to 12\n\n\nMM\nThe month of the year with leading zero if required.\n01 to 12\n\n\nMMM\nAbbreviated month name. Date.CultureInfo.abbreviatedMonthNames.\nJan to Dec\n\n\nMMMM\nThe full month name. Date.CultureInfo.monthNames.\nJanuary to December\n\n\nyy\nDisplays the year as a two-digit number.\n99 or 07\n\n\nyyyy\nDisplays the full four digit year.\n1999 or 2007\n\n\nt\nDisplays the first character of the A.M.&#x2F;P.M. designator. Date.CultureInfo.amDesignator or Date.CultureInfo.pmDesignator\nA or P\n\n\ntt\nDisplays the A.M.&#x2F;P.M. designator. Date.CultureInfo.amDesignator or Date.CultureInfo.pmDesignator\nAM or PM\n\n\nS\nThe ordinal suffix of the current day.\nst, nd, rd, or th\n\n\nClass面向对象用法class跟let、const一样：不存在变量提升、不能重复声明…\nes5面向对象写法跟传统的面向对象语言（比如 C++ 和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑。\nES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。\nES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。\n//es5function Fn(x, y) &#123;  this.x = x;  this.y = y;&#125;Fn.prototype.add = function () &#123;  return this.x + this.y;&#125;;//等价于//es6class Fn&#123;  constructor(x,y)&#123;    this.x = x;    this.y = y;  &#125;    add()&#123;    return this.x + this.y;  &#125;&#125;var F = new Fn(1, 2);console.log(F.add()) //3\n\n构造函数的prototype属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面。\nclass Fn &#123;  constructor() &#123;    // ...  &#125;  add() &#123;    // ...  &#125;  sub() &#123;    // ...  &#125;&#125;// 等同于Fn.prototype = &#123;  constructor() &#123;&#125;,  add() &#123;&#125;,  sub() &#123;&#125;,&#125;;\n\n类的内部所有定义的方法，都是不可枚举的（non-enumerable），这与es5不同。\n//es5var Fn = function (x, y) &#123;  // ...&#125;;Point.prototype.add = function() &#123;  // ...&#125;;Object.keys(Fn.prototype)// [&quot;toString&quot;]Object.getOwnPropertyNames(Fn.prototype)// [&quot;constructor&quot;,&quot;add&quot;]//es6class Fn &#123;  constructor(x, y) &#123;    // ...  &#125;  add() &#123;    // ...  &#125;&#125;Object.keys(Fn.prototype)// []Object.getOwnPropertyNames(Fn.prototype)// [&quot;constructor&quot;,&quot;add&quot;]\n\n严格模式类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。\n考虑到未来所有的代码，其实都是运行在模块之中，所以 ES6 实际上把整个语言升级到了严格模式。\nconstructoronstructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。\nclass Fn &#123;&#125;// 等同于class Fn &#123;  constructor() &#123;&#125;&#125;\n\nconstructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。\nclass Foo &#123;  constructor() &#123;    return Object.create(null);  &#125;&#125;new Foo() instanceof Foo// false//constructor函数返回一个全新的对象，结果导致实例对象不是Foo类的实例。\n\n类必须使用new调用类必须使用new调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。\nclass Foo &#123;  constructor() &#123;    return Object.create(null);  &#125;&#125;Foo()// TypeError: Class constructor Foo cannot be invoked without &#x27;new&#x27;\n\nClass 表达式与函数一样，类也可以使用表达式的形式定义。\nconst MyClass = class Me &#123;  getClassName() &#123;    return Me.name;  &#125;&#125;;\n\n上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是MyClass而不是Me，Me只在 Class 的内部代码可用，指代当前类。\nlet inst = new MyClass();inst.getClassName() // MeMe.name // ReferenceError: Me is not defined\n\n如果类的内部没用到的话，可以省略Me，也就是可以写成下面的形式。\nconst MyClass = class &#123; /* ... */ &#125;;\n\n采用 Class 表达式，可以写出立即执行的 Class。\nlet person = new class &#123;  constructor(name) &#123;    this.name = name;  &#125;  sayName() &#123;    console.log(this.name);  &#125;&#125;(&#x27;张三&#x27;);person.sayName(); // &quot;张三&quot;\n\n上面代码中，person是一个立即执行的类的实例。\n私有方法和私有属性私有方法&#x2F;私有属性是常见需求，但 ES6 不提供，只能通过变通方法模拟实现。（以后会实现）\n通常是在命名上加以区别。\nclass Fn &#123;  // 公有方法  foo () &#123;    //....  &#125;  // 假装是私有方法（其实外部还是可以访问）  _bar() &#123;    //....  &#125;&#125;\n\n原型的属性class定义类时，只能在constructor里定义属性，在其他位置会报错。\n如果需要在原型上定义方法可以使用：\n\nFn.prototype.prop &#x3D; value;\nObject.getPrototypeOf()获取原型，再来扩展\nObject.assign(Fn.prototype,{在这里面写扩展的属性或者方法})\n\nClass 的静态方法类相当于实例的原型，所有在类中定义的方法，都会被实例继承。\n如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。\nES6 明确规定，Class 内部只有静态方法，没有静态属性。\nclass Foo &#123;  static classMethod() &#123;    return &#x27;hello&#x27;;  &#125;&#125;Foo.classMethod() // &#x27;hello&#x27;var foo = new Foo();foo.classMethod()// TypeError: foo.classMethod is not a function//静态属性只能手动设置class Foo &#123;&#125;Foo.prop = 1;Foo.prop // 1\n\nget、set存值函数和取值函数，不多说，看代码\nclass Fn&#123;\tconstructor()&#123;\t\tthis.arr = []\t&#125;\tget bar()&#123;\t\treturn this.arr;\t&#125;\tset bar(value)&#123;\t\tthis.arr.push(value)\t&#125;&#125;let obj = new Fn();obj.menu = 1;obj.menu = 2;console.log(obj.menu)//[1,2]console.log(obj.arr)//[1,2]\n\n继承用法class Fn &#123;&#125;class Fn2 extends Fn &#123;&#125;\n\n注意\n子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。\n\nclass Point &#123; /* ... */ &#125;class ColorPoint extends Point &#123;  constructor() &#123;    super()//必须调用  &#125;&#125;let cp = new ColorPoint(); // ReferenceError\n\n\n父类的静态方法也会被继承。\n\n\n嗯！就是这么让人绝望\n\nObject.getPrototypeOf()Object.getPrototypeOf方法可以用来从子类上获取父类。\nObject.getPrototypeOf(Fn2) === Fn// true\n\n因此，可以使用这个方法判断，一个类是否继承了另一个类。\nsuper 关键字super方法就是用来创建父类this对象的。 如果子类没有定义constructor方法，constructor方法会被默认创建，并默认调用super函数\n\nsuper这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。\n第一种情况，super作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。\n\n作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错。\n\nclass A &#123;&#125;class B extends A &#123;  constructor() &#123;    super();  &#125;&#125;\n\n上面代码中，子类B的构造函数之中的super()，代表调用父类的构造函数。这是必须的，否则 JavaScript 引擎会报错。\n注意，super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B，因此super()在这里相当于A.prototype.constructor.call(this)。\n第二种情况，super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。\nclass A &#123;  p() &#123;    return 2;  &#125;&#125;class B extends A &#123;  constructor() &#123;    super();    console.log(super.p()); // 2  &#125;&#125;let b = new B();\n\n上面代码中，子类B当中的super.p()，就是将super当作一个对象使用。这时，super在普通方法之中，指向A.prototype，所以super.p()就相当于A.prototype.p()。\n由于this指向子类，所以如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性。\nclass A &#123;  constructor() &#123;    this.x = 1;  &#125;&#125;class B extends A &#123;  constructor() &#123;    super();    this.x = 2;    super.x = 3;    console.log(super.x); // undefined    console.log(this.x); // 3  &#125;&#125;let b = new B();\n\n上面代码中，super.x赋值为3，这时等同于对this.x赋值为3。而当读取super.x的时候，读的是A.prototype.x，所以返回undefined。\n","categories":["WebFrontend"],"tags":["javascript"]},{"title":"js(学习日志)","url":"/2022/08/20/WebFrontend/JavaScript/js(%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97)/","content":"day01-开班典礼day02-基础知识js代码书写位置&lt;!--         js的书写位置        - 页面的 script 标签书写        - 外部js文件引入            1. 需要提前准备好一个js的文件            2. 通过script标签的src引入        - 标签内书写js代码            不推荐使用     --&gt;     &lt;!-- script 书写 --&gt;    &lt;script&gt;        //js代码书写位置        console.log(&#x27;hello word&#x27;)    &lt;/script&gt;    &lt;!-- 老版本的script引入方式 --&gt;    &lt;script type=&quot;text/javascript&quot; &gt;        console.log(&#x27;hello word&#x27;)    &lt;/script&gt;    &lt;!-- 写法 --&gt;    &lt;script language=&quot;javascript&quot;&gt;         console.log(&#x27;hello word&#x27;)    &lt;/script&gt;    &lt;!-- 外部js文件引入 --&gt;    &lt;script src=&quot;./bendi.js&quot;&gt;        // 外部引入文件的js 标签内是不允许再书写js代码的        console.log(&#x27;我是外部js标签内的代码&#x27;)//不能识别    &lt;/script&gt;\n\n简单交互行为 //弹窗功能 alert(msg)  msg你需要弹出的内容// alert(&#x27;你好 嘻嘻嘻&#x27;)//确认弹窗 跟普通弹窗一样, 知识多了个选项,可以选择确定或者取消confirm(qus) qus 需要用户确认的内容 也是一个字符串//confirm(&#x27;你确定要进入这个网站吗&#x27;)        /*             prompt(msg,default)             msg : 给用户的提示语            default : 默认值            带有交互确认弹窗, 用于收集用户信息的弹窗        *///prompt(&#x27;你今年多大了?&#x27;,18)//打印日志, 打印的内容会在控制台中展示通常用于代码调试//console.log(&#x27;打印的内容&#x27;)\n\njs的代码结构/*     语句    语句就是我们刚才所看到的 console.log() alert() 就是所有的语句    一句代码就是一条语句    分号    分号作为代码结束的标识符    但是分号不是必须加的  js 会隐式的将换行理解为分号    大部分情况下都是可以不加分号的     看一个特殊情况    alert(3 +3)  进行运算的时候 换行不会被解析为分号    必须加分号的情况    养成加分号的习惯    注释的写法    注释的作用 方便多人协作, 写注释后期你还能知道自己在干嘛    单行注释        写法 //需要注释的代码 快捷键 是 ctrl + /  command+/    多行注释        书写方式 /* * /  快捷键  可以自己设置, 设置---快捷键--搜索注释  默认是 shift+alt+a        需要注意多行注释里面不能再嵌套多行注释        *///alert(&#x27;hello world&#x27;)// alert(&#x27;hello&#x27;);// alert(&#x27;world&#x27;);// alert(&#x27;hello&#x27;)  // alert(&#x27;world&#x27;)// alert(3 +// 3)//必须加分号的情况// alert(&#x27;接下来给大家表演弹出123&#x27;);// [1,2,3].forEach(alert);// alert(&#x27;接下来给大家表演弹出123&#x27;)[1,2,3].forEach(alert);/*     undefined[1,2,3].forEach(alert);*/\n\n严格模式&#x27;use strict&#x27;;   /*        开启严格模式        开启方式 在js代码的最顶层写上 &#x27;use strict&#x27;;       开启严格模式以后代码就会按照最新的标签去解析   */   // x = 123   // console.log(x) //非严格模式下可以访问 x   // console.log(x) //严格模式下会报错 报错x未定义   // function fn()&#123;   //     console.log(this) //非严格模式是 window 对象   //     console.log(this) // 严格模式下 this 等于 undefined   // &#125;   // fn()\n\n变量&#x27;use strict&#x27;;    /*         变量        在做开发的时候我们可能会遇到的一些项目        1. 开发一个游戏             1.1 应该有每个英雄的基本信息 ,生命值 , 护甲值.....            1.2 还需要用到 攻击力, 防御力的变化            1.3 装备系统        2. 开发个聊天软件            2.1 考虑用户的信息            2,2 用户发送的信息        3. 开发个网上商城            3.1 商品信息            3.2 商品价格            3.3 用户信息    */    //创建一个容器来存储留言信息      //在js中存储信息靠的就是变量  变量也称为标识符    //创建变量  需要用到关键词 let    //创建    let message; //创建了一个名字叫message的变量    //存储数据    message = &#x27;你好&#x27; //变量赋值操作, 为message变量存储数据    message = &#x27;嘻嘻嘻&#x27;    console.log(&#x27;你好&#x27;)    console.log(message) //嘻嘻嘻    //创建一个生命值的变量    //创建变量的同事进行赋值    let hp = 100    //修改变量的值    hp = 90    console.log(hp) // 90    //变种写法    // let user = &#x27;wuxian&#x27;;    // let age = 19;    // let sex = &#x27;男&#x27;;    //简写    // let user = &#x27;七喜&#x27;,age = 50,sex = &#x27;女&#x27;;    // let user = &#x27;七喜&#x27;    // ,age = 50    // ,sex = &#x27;女&#x27;;    //先创建再赋值    // let user,age,sex;    // user = &#x27;七喜&#x27;;    // age = 19;    // sex = &#x27;女&#x27;    // console.log(user,age,sex)    //老版本创建变量的方式 var 用法和let 一模一样  不推荐使用    // console.log(age) //undefined    // var age = 19    // var age = 18    // console.log(age)    //let 不允许声明前调用也不允许重复声明    // console.log(goudan) //报错    // let goudan = &#x27;狗蛋&#x27;;    // let goudan = &#x27;狗蛋&#x27;;    // console.log(goudan)    /*         变量命名的规范        1. 变量名称只能包含数字,字母符号,$和,_        2. 首字母必须是非数字        3. 严格区分大小写, 不能使用关键词(保留词)        4. 见名知意        优秀的命名        如果命名包含多个单词 通常采用驼峰命名的规则命名,驼峰的规则就是首个单词字母小写后续单词的首字母统一大写        userName        productPic        myVeryGoodName        backgroundColor            */    //正确的示范    let _age,$123,abcd,goudan,你好;    // console.log(你好)    //错误的示范    // let 1age,max-age,(sex,let,window,return,***;\n\n常量&#x27;use strict&#x27;;    /*     1. 使用变量    要求    1 声明两个变量 admin 和 name    2.将值 无限 赋值给 name    3. 从name变量中将值拷贝给 admin    4. 使用弹窗alert 显示出 admin 的值    2. 根据需求自定义一个优秀的命名    1. 将我们所居住的星球创建一个变量     2. 创建一个用于存储当前浏览者的名称 */\n\nday03-数据类型专业术语&#x27;use strict&#x27;;/*     数据类型    数据类型值得是一门语言中对不同的数据的划分, 在js中有8种数据类型    数据类型可以分为两类    - 基本类型(值类型)    - 引用类型(对象类型)*/// 语句 字面量 表达式let age = 18;age = 18 + 1 ;/*     let age = 18;    let 变量声明     age 变量标识符    =  赋值操作    18 字面量 常见的就是数值字面量 字符串字面量 等等..    18 + 1  表达式 , 表达式通常为一个运算公式或者一个函数执行,最终表达式一定会得到一个结果 赋值给变量    语句   let age = 18; 完整的一条代码就是一条语句    还有 if for流程控相关的都成为语句*/\n\n基础类型之数值&#x27;use strict&#x27;;/*     数据类型    数据类型值得是一门语言中对不同的数据的划分, 在js中有8种数据类型    数据类型可以分为两类    - 基本类型(值类型)    - 引用类型(对象类型)*///Number 类型 /*     Number 类型表示一个数值类型,在js中数值类型是不区分整数,浮点数的统一都叫number 类型,一切数字都是数值类型(十进制,二进制,十六进制)指数类型*///创建一个数值类型//字面量创建数值类型let integer = 666 //创建了一个十进制的整数数值类型let decimal = 3.1415 //创建了一个小数的数值类型//通过内置方法创建数值let num = Number(10) //内置方法的应用// let userAge = prompt(&#x27;你今年多大&#x27;,19)// let user_age = Number(userAge)//一些列的进制展示 , 0b开头表示他是一个二进制的数值, 0x开头表示他是一个十六进制的数值, 0o开头表示他是一个8进制的数值//存储可以用进制存储, 但是在页面中展示一定是会被转换为十进制展示的let bin = 0b1101  //13 对应的二进制let hex = 0xa3 // 163 对应的十六进制let bahe = 0o12 //10 的八进制    let index = 5e6 //e表示指数 表示5*10的6次方/*     关于小数的问题    js中小数计算的时候会被转为二进制进行存储所以在计算的时候可能会出现计算误差的情况*/let result = 0.1 + 0.2 //0.30000000000000004//解决方法, 让小数转换为整数再进行计算let result2 = (0.1*100 + 0.2*100) / 100/*     特殊数值     除了常见的数值类型的以外js中还存在两个特殊的数值类型    - infinity        表示一个无穷大的数值,在js存储数据标准的问题, 在存储数据的时候如果存储的数值超过他能存储的最大范围就会出现正向溢出反之则是反向溢出, js中能展示的最大数值 为 2**1024    - NaN        not a number  表示一个不合法的数字,通常是由计算错误得到的结果*/let maxNum = -(2**1024) //2的1024次方let jsMaxNum = Number.MAX_VALUE //最大值let num2 = 1 / 0 //Infinitylet num3 = Infinity //Infinity 也可以作为值赋值给变量let res1 = &#x27;你好&#x27; / 2 //计算错误得到的结果就为 nanlet res2 = NaN + 1 //只要是跟NaN进行就计算得到的结果永远都是NaNlet nn = NaN //也可以用做值赋值给变量//console.log(NaN**0) //1 特殊情况 NaN的0次方等于1//js中的数学运算中有NaN这个值是非常好的一件事, 有他的存在就能保证在js中做数学运算他一定是非常安全的, 因为你无论怎么计算他都能得到一个结果不会报错,最坏的结果就是 NaN/*     最大安全整数值    也是由于js存储数据的规则问题, 在js中会出现精度确实的问题, 当计算超出 2**53-1的值的时候, 再进行运算就会出现计算错误    9007199254740991*/let maxInt = 2**53-1//9007199254740991maxInt = maxInt + 2 //9007199254740992console.log(Number.MAX_SAFE_INTEGER)//9007199254740991\n\n基础类型binint&#x27;use strict&#x27;;   /*        bigint类型 超大整数类型       由于最大安全整数的存在计算会出现精度确实, 所有es6以后引入了一个新的数据类型叫做bigint 专门用于超大的整数计算       注意事项       进行数学运算的时候必须两个值都为超大整数类型才可以计算   */     //创建方式 1. 字面量创建 在数值末尾加上一个n表示一个bigint类型   let bigInt = 9007199254740991n // 123n   //2 通过 内置方法创建 bigint   let big2 = BigInt(2) // 2n   let result = bigInt + big2 //9007199254740993n   console.log(3 &gt; big2) // 3 &gt; 2n  可以跟基础数值类型做比较\n\n基础类型string&#x27;use strict&#x27;;/*     String类型  字符串类型    用于存储一段文字信息    字面量创建有三种形式    1. 单引号    2. 双引号    3. 反引号*///创建方式1  字面量方式创建let str = &#x27;你好&#x27;let str1 = &quot;嘻嘻嘻&quot;let str2 = `你好你好嘻嘻嘻`//反引号也称为模板字符串(功能扩展引号) 他跟普通的引号有一定的区别, 模板字符串内可以通过 $&#123;&#125; 插入变量或者是表达式let myName = &#x27;yaya&#x27;;let age = 18;// alert(`大家好我叫 $&#123;myName&#125;`) //大家好我叫yaya// alert(`大家好我叫 $&#123;myName&#125;,我今年$&#123;age+1&#125;岁`) //大家好我叫yaya// alert(&quot;大家好我叫 $&#123;myName&#125;&quot;) //大家好我叫 $&#123;myName&#125;//+ 号在于字符串运算的时候会进行字符串的拼接let result = &#x27;大家好我叫&#x27; + myName + &#x27;我今年&#x27;+(age+1)+&#x27;岁&#x27;//引号嵌套引号的情况 的解决方法let str3 = &#x27;鲁迅说:&quot;今年很开心&quot;&#x27;;let str4 = `&#x27;鲁迅说&#x27;:&quot;今年很开心&quot;`;//使用转移符号解决let str5 = &#x27;鲁迅说:\\&#x27;今年很开心\\&#x27;&#x27;;/*     转移符号的扩展    \\ 普通的转移符号    \\n 表示换行符    \\r 表示回车符    \\t 表示一个制表符    \\b 表示一个退格符    \\f 表示换页符号*/\n\n基础类型boolean类型&#x27;use strict&#x27;;/*     Boolean 类型（布尔值类型 || 逻辑类型）    该数据类型里面一共就两个值 true 和 false     这种类型的值通常用语表示 yes 或者no , true 表示正确 ,false表示失败*/   //创建布尔值let bool = truelet bool2 = false//内置方法创建let bool3 = Boolean(true)//应用场景 ,通常用于记录一系列的状态let is180 = false//布尔值通常出现于数值比较的结果console.log(5 &gt; 3) //true\n\n基础类型null-undefined&#x27;use strict&#x27;;/*     null 类型 (值)    null 类型存储的值只有一个null 他自己就是一个数据类型同时值也就他一个    null 类型表示空对象或者是空值    其他语言成为空指针    应用场景就是用来释放内存*/let age = null; //表示 age 存储的值是一个空值,或者是一个未知的值,通常情况null 的应用场景就是用来释放内存/*     undefined 类型(值)    跟null一样自成一派,自己就是一个数据类型,值也就只有自己    特殊值表示 值未被赋值     如果一个变量或者对象的属性创建了但是你没有为它赋值,那他默认就是undefined*/let sex;// console.log(sex) //undefined// console.log(window.adsfsadf)//undefinedlet myName = &#x27;xuxing&#x27;;//过了一段时间不需要这个值了怎么处理myName = null;\n\n基础类型symbol&#x27;use strict&#x27;;    /*         symbol 类型        应用场景比较少,一般用于一些架构的设计,或者底层代码                symbol类型的值是不可以进行运算的        他的应用场景是用于创建一个独一无二的值    */       //创建方式    let  s1 = Symbol() //创建一个独一无法的symbol数据    let  s2 = Symbol() //创建一个独一无法的symbol数据    // let  s3 = s1    console.log(s1 === s2) //false    /* Object 类型 引用类型, , 后续再探讨引用类型 */\n\ntypeof运算符&#x27;use strict&#x27;;   /*        typeof 运算符       专用用于检测数据类型的运算符       语法 typeof 需要检测的数据   */   console.log(typeof &#x27;23&#x27;) //string   console.log(typeof 12) //number   console.log(typeof true) //boolean   console.log(typeof 123n) //bigint   console.log(typeof Symbol()) //symbol   console.log(typeof undefined) //undefined      //其他类型   console.log(typeof null) //object  type判断null的结构是object这是一个typeof 的错误判断,问题源自js早期兼容问题保留下来的 null 绝对不是一个对象   console.log(typeof alert) //function 判断alert得到的结果是 function 需要注意 function 不是一个数据类型他属于对象类型,这是一个非常好的错误   console.log(typeof window) //object   //typeof 的另一种写法 语法 typeof(需要检测的值)   console.log(typeof(1))//number\n\nday04-类型转换与运算符数据类型转换&#x27;use strict&#x27;;/*     数据类型转换        大多数情况下运算和函数会自动的将值转换成不同的类型 比如 alert 会将传入的值转换为字符串    还有prompt会将收集到的值也转换为字符串, 这种转换方式我们称为 隐式类型转换    很多需求下我们是需要手动的将值转换为我们需要的一个数据类型 , 这时候就需要用一些特定的方法进行数据类型的转换, 这种转换方式我们称为 显示类型转换*/// let age = prompt(&#x27;你今年多大了&#x27;,19)// console.log(typeof age) // string//需求是 增加用户的年龄增大一岁// console.log(age+1)//191//转换为字符串/*     将其他数据类型转换为字符串*/let num = 5;console.log(typeof num)//将5数值转换为字符串// 语法 xx.toString()   xx 表示你需要进行转换的变量console.log(num.toString()) // 5console.log(NaN.toString()) // NaNconsole.log(Symbol().toString()) // Symbol()console.log(Infinity.toString()) // Infinity/*     toSting 有个问题就是不能转换 undefined 和 null , 转换就报错*/// console.log(undefined.toString()) // 报错// console.log(null.toString()) // 报错/*     String(xx)  xx需要转换为字符串的值*/console.log(String(123))console.log(String(undefined))//undefinedconsole.log(String(null))//null/*     还可以通过 +号运算跟字符串做运算 也能转换为字符串    进行+号运算的时候有个规则, 只要运算符两边有一个字符串就会进行字符串拼接*/let und = undefinedconsole.log(typeof und) // undefinedund = und+&#x27;&#x27;console.log(typeof und) //stringlet x = 100 + &#x27;&#x27; + 100 //100100let y = 100 + 100 + &#x27;&#x27; + 100 //200100\n\n转换为数值类型&#x27;use strict&#x27;;/*转换为数值将其他类型转换为数值 - Number(value) value你需要转换为数值的值number一定会转换成数值,如果不是一个合法的数值或者特殊值那就直接转换为NaN特殊值, null 和 false在转为数值的时候会被转为0 , true在做转换的时候会被转换为 1undefined 转为数值为 NaNstring 转为数值的时候如果他是一个合法的数值字符串是可以进行转换的什么是合法的数值字符串: 字符串掐头去尾(指的是去除开头和结束的空格字符串)剩下的都是数值字符串中间都没有空格的情况就为合法数值字符串空字符串转为数值等于 0*///合法的数值字符串let str = &#x27;123&#x27;console.log(typeof str)//stringstr = Number(str)console.log(typeof str)//number//不是一个合法的数值字符串let str1 = &#x27;123abc&#x27;str1 = Number(str1)// 123 A 1 B  NaN C//其他数据类型转换为字符串 // console.log(Number(Symbol()))//特殊值console.log(Number(undefined))//NaNconsole.log(Number(null))//0console.log(Number(false))//0console.log(Number(true))//1console.log(Number(&#x27;&#x27;))//0//字符串的特殊情况console.log(Number(&#x27;          123&#x27;))//123console.log(Number(&#x27;          123    &#x27;))//123console.log(Number(&#x27;          1 23    &#x27;))//NaN\n\n转换为布尔值&#x27;use strict&#x27;;/*     转换为布尔值    语法  Boolean(xx)  把xx的数据转换为布尔值    布尔值的转换规则    - 除了以下的6个值以外其他的所有值都转换为 true    - &#x27;&#x27; 0 false null undefined NaN*/let bool = true;let bool2 = Boolean()console.log(Boolean(1))//trueconsole.log(Boolean(null))//falseconsole.log(Boolean(5+3))// trueconsole.log(Boolean([]))// trueconsole.log(Boolean(sessionStorage))// trueconsole.log(Boolean(NaN))// falseconsole.log(Boolean(&#x27; &#x27;))// trueconsole.log(Boolean(&#x27;&#x27;+0))// trueconsole.log(Boolean(&#x27;0&#x27;))// trueconsole.log(Boolean(3*&#x27;abc&#x27;))// false// console.log(Boolean(undefined))//false// console.log(Number(undefined))//NaN\n\n运算符&#x27;use strict&#x27;;/*     js中的运算符一共有5中    1. 算术运算符 + - * / ** /%    2. 赋值运算符 = += -= *=    3. 关系(比较)运算符 &gt; &lt; &gt;= &lt;= !=     4. 逻辑运算符 &amp;&amp; || ! ??    5. 自增自减运算符  ++ -- *//*     专业术语    运算元  -- 运算元应用的对象 比如 乘法 3 * 4 里面就有两个运算元, 左运算元叫3 右运算元叫 4 , 大部分人称它为 参数    一元运算符  运算符旁边只有一个运算元,就叫一元运算符  -5 +3    二元运算符  运算符旁边有两个运算元就叫 二元运算 3 * 4  就是二元运算*/let w = 100//希望将w取相反的负数\n\n算术运算符&#x27;use strict&#x27;;/*     算术运算符 就是一个数学运算符号    +    -    * 乘    / 除    ** 求幂    % 取余    运算规则    加法的规则, 只有两边都是数值的时候才会进行数学加法运算,如果有一边为字符串就进行字符串拼接    除了加法运算以为其他运算    跟其他类型进行数学运算的时候 会优先加其他类型的值转换为数值再进行数学运算    如果转换的值为nan那结果就一定是nan (nan 跟任何值做数学运算的时候结果都是nan)    运算符优先级 : https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence*/    console.log(3 % 5) //3console.log(5 % 3) //2console.log(5 / 3) //1.6666666666666667console.log(2**3) //8console.log(2**(1/3))//1.2599210498948732console.log(undefined+undefined)//NaNconsole.log(null+null,&#x27;null+null&#x27;)//0 //二元运算的 加法//数值跟字符串做加法运算的情况console.log(5+&#x27;3&#x27;)//53//数值跟数值做加法console.log(5+3)//8//跟特殊值运算console.log(5+null)//5console.log(5*&#x27;3&#x27;) // 5 * 3 = 15console.log(5+4+&#x27;3&#x27;) // 9+&#x27;3&#x27; = &#x27;93&#x27;console.log(3-true+&#x27;1&#x27;) // 3-1+&#x27;1&#x27; = 2+&#x27;1&#x27; = &#x27;21&#x27;console.log(3+undefined*5-3) // NaNconsole.log(&#x27;6&#x27;*&#x27;3&#x27;) // 18console.log(&#x27;5&#x27;+undefined)//5undefined//计算错误的情况 需要注意 跟 undefined 和 nan计算的时候得到的结构一定是nan   console.log(+true) //一元运算会隐式的将运算符旁边的值转换为数值//应用场景let a = &#x27;4&#x27;let b = &#x27;5&#x27;//需求计算 a 加 b 的值 期望得到数值9// console.log(a+b)//&#x27;45&#x27;//方式一console.log(Number(a)+Number(b))//9//方式二 利用一元运算console.log(+a + +b)//9// let age = +prompt(&#x27;今年多大&#x27;)// console.log(typeof age) //numberlet res = (5 + 2) * 3console.log(res)//31\n\n赋值运算符&#x27;use strict&#x27;;   /*        赋值运算符 =        let x = 2+2 先计算2+2 在进行赋值运算 将4赋值给 x   */   let w = 7   let x = 3   let c = 11 - (w = x * 2)   console.log(w) //? 6   console.log(c) //? 11 - 6 = 5   //链式赋值   let a,b,d;   //期望a和b和d 都相等都等于20   //方案一   // a = 20;   // b = 20;   // c = 20;   // a = 20   // b = a   // d = b   //链式赋值   a = b = d = 20;   //原地修改   let money = 1000;   //常规写法   // money = money + 1000;   //赋值并且修改 在原有值的基础上进行修改   money += 1000 // ==&gt; money = money + 1000;   money += 1000 // ==&gt; money = money + 1000;   money *= 2 // ==&gt; money = money * 2;   money *= 5-2 // ==&gt; money = money * 2;\n\n数据类型总结&#x27;use strict&#x27;;   /*        ### 总结           JavaScript 中有八种基本的数据类型（译注：前七种为基本数据类型，也称为原始类型，而 `object` 为复杂数据类型）。           -   `number` 用于任何类型的数字：整数或浮点数，在 `±(253-1)` 范围内的整数。           -   `bigint` 用于任意长度的整数。           -   `string` 用于字符串：一个字符串可以包含 0 个或多个字符，所以没有单独的单字符类型。           -   `boolean` 用于 `true` 和 `false`。           -   `null` 用于未知的值 —— 只有一个 `null` 值的独立类型。           -   `undefined` 用于未定义的值 —— 只有一个 `undefined` 值的独立类型。           -   `symbol` 用于唯一的标识符。           -   `object` 用于更复杂的数据结构。           我们可以通过 `typeof` 运算符查看存储在变量中的数据类型。           -   通常用作 `typeof x`，但 `typeof(x)` 也可行。           -   以字符串的形式返回类型名称，例如 `&quot;string&quot;`。           -   `typeof null` 会返回 `&quot;object&quot;` —— 这是 JavaScript 编程语言的一个错误，实际上它并不是一个 `object`。   */\n\nday05-运算符续集自增自减运算&#x27;use strict&#x27;;/*     自增自减运算    在原有的数值基础上增加1或者是减少1    语法分为     ++变量/--变量    后置自增/自减  变量++ 前置自增/自减/变量--    前置++ 和后置++的区别    最终所实现的效果是一模一样的都是在原变量的基础上进行自增或者自减    区别在于 后置++ 会将原变量变化前的值返回出来     前置++ 会将改变后的值返回出来    前置++返回的是最新的值,后置++返回的是变化前一次的值*/   let num = 19//方式一// console.log(num+=1)//方式 后置++let addNum = num++ //后置自增运算console.log(num)//20num--console.log(num)//19//前置++++numconsole.log(num) // 20let height = 150;//151 152 // console.log(height++)// 150 先进行赋值再去原有变量上进行+1// console.log(height++)// 151 先进行赋值再去原有变量上进行+1// console.log(height)// 152 先进行赋值再去原有变量上进行+1// console.log(++height)//151 先改变变量再进行赋值let age = 1let result = age++ + ++age * age++ ;/*     age = 4    1 + 3 * 3    1+9    10*/// console.log(19++) //报错, 自增自检只能用于变量let aa = 2let res = &#x27;5&#x27; + 3 * ++aa - 2 + aa++ + ++aa + &#x27;4&#x27;;/*     aa =5    &#x27;5&#x27; + 3 * 3 - 2 + 3 + 5 +&#x27;4&#x27;    &#x27;5&#x27;+9-2 + 3 + 5 +&#x27;4&#x27;    65+&#x27;4&#x27;    654*/\n\n位运算&#x27;use strict&#x27;;   /*        位运算       位运算会先把运算元做成32位二进制来表示       根据位运算符的规则进行进制的变化       位运算      **~ 按位非**      **&amp; 按位与**      **| 按位或 ^ 按位异或**      **&gt;&gt;&gt; 无符号右移 &gt;&gt; 有符号右移**   */   let a = 12;   let b = ~a;   // 12的二进制表示：     00000000 00000000 00000000 00001100   // 按位非得到最终结果： 11111111 11111111 11111111 11110011     //因为 第32位是1，代表负数，那这个负数是多少呢？按照上面的办法我们可以反推回来：   //负数码减-1：         11111111 11111111 11111111 11110010   //结果取反码：         00000000 00000000 00000000 00001101   //表示的正数是：13，所以该负数为  -13   // alert(b); //验证一下   let c = 123.2564564565   //去除小数   console.log(~~c) // 123\n\n逗号运算符&#x27;use strict&#x27;;/*     逗号运算符,    逗号运算符可以将多条语句分隔开,每一条语句都会执行,并且会返回最后一个逗号执行的结果    逗号运算符优先级非常低, 通常应用的时候都会加上括号*/// let a = (1+2,3+4)//7// let b = 3 // 4 7// let c = 4// let d = (++b,b+=3,c+b)// 4 + 7// console.log(b,c,d) // 7 4 11// let a,b,c;// //高级用法// for (a=1,b=3,c=a*b; a &lt; 10; a++,c=a*b) &#123;//     console.log(c)// &#125;\n\n比较运算符&#x27;use strict&#x27;;/*     比较运算符用于比较两个值的大小 或者是关系    用于做判断    大于小于 &gt; &lt;    大于等于小于等于 &gt;= &lt;=    检测相等 == 一个等号表示赋值两个等号表示判断 a == b 表示a和b想不想等    检测两个值不相等  在js中的表示形式为 !=  比如 a != b a是不是不等于b     比较运算符组成的表达式返回值永远是一个布尔值    - ture 成立    - false 不成立    字符串之间的比较    规则是根据字符串对应的 unicode 编码顺序(存储的值是一个数值)来进行比较    如果是单个字符串之间的比较就直接比较他的编码顺序    如果是多个字符串之间的比较*///数值之间的比较// console.log(2 &gt; 1)//true// console.log(2 == 1)// flse// console.log(2 &gt;= 2)// true// console.log(3 != 2)// true//字符串跟字符串比较// let a = &#x27;abd&#x27;// let b = &#x27;abcsdfafd&#x27;// console.log(a &gt; b) //true// //获取unicode中对应的编码顺序// console.log(a.charCodeAt(2))// console.log(b.charCodeAt(2))//不同类型之间的比较//不同类型js会优先转为数值在进行比较// console.log(5 &gt; &#x27;4&#x27;) // 5 &gt; 4 = true// //NaN 跟任何值做比较运算的时候得到的结果都为false// console.log(&#x27;s4&#x27; &gt; 5) // false// //Undefined 在做除了 == 判断的时候跟任何值做比较较运算都为false// console.log(undefined &gt; 5) // false// console.log( 5 &gt; true) // true/*     相等== 和 全等===    js 在做比较的时候分为两种情况相等和全等    相等就是只要长得一样那就相等        相等的规则是优先将两个不同的类型转换为数值类型再做比较    全等必须数据类型并且值一样才叫全等*/// console.log(5 == &#x27;5&#x27;)//truelet a = 0// console.log(Boolean(a)) // falselet b = &#x27;0&#x27;// console.log(Boolean(b)) //true// console.log(a == b)//true// console.log(true == 1)//true// console.log(true == &#x27;1&#x27;)//true//全等比较// console.log(&#x27;1&#x27; === &#x27;2&#x27;)//false// console.log(&#x27;1&#x27; === 1)//false//!= 表示不等于 跟相等的规则是一样的  !== 表示不全等于 规则跟全等一样的// console.log(&#x27;1&#x27; != 1)//false// console.log(&#x27;1&#x27; !== 1)//true//特殊情况// console.log(undefined == undefined)//true// console.log(NaN == NaN)//false// console.log(null == null)//true// console.log(undefined == null)//true js设计的时候认为两个值都表示空,所有在比较的时候就当做空来比较console.log(null &gt; 0)//falseconsole.log(null == 0)//false null在做相等比较的时候不会转换为数值console.log(null &lt; 0)//false//做大于等于运算的时候 是优先进行大于的运算 null = 0 然后再做等于判断 0 == 0 trueconsole.log(null &gt;= 0)//trueconsole.log(null &lt;= 0)//true\n\n逻辑运算符&#x27;use strict&#x27;;/*     逻辑运算符    js中一共有四种逻辑运算    || 或    &amp;&amp; 与    ! 非    ?? 空值合并    逻辑运算符是可以用于任意的数据类型并不仅仅只有布尔值    逻辑或 ||    书写格式 a || b    规则 在做逻辑运算的时候会临时将运算符两边的值转换为布尔值,再进行逻辑运算    逻辑或运算的规则就是 逐个判断,找到第一个为true 的值然后就停止后续的判断直接返回 为 true 的值,如果都不为true就返回最有一个值 */let a = &#x27;xixixi&#x27;;let b = false// console.log(a || b) // true || false// console.log(1 || 0) // true || false = 1 // console.log(null || undefined || 18 || 24) // 18// console.log(null || undefined ) // undefined//应用场景  如果用户输入了名字就用他自己的名字,如果没有输入就用默认的昵称// let name = prompt(&#x27;你叫什么名字?&#x27;) || &#x27;狗蛋&#x27;// alert(`$&#123;name&#125;登录成功`)/*     逻辑与    书写方式 a &amp;&amp; b    规则临时转换为布尔值 依次判断 如果遇到结果为 false 的值,就停止计算并且返回第一个为false的值    如果都为ture就返回最后ture*/console.log(1 &amp;&amp; 2 ) //2console.log(1 &amp;&amp; &#x27;xixixi&#x27; &amp;&amp; undefined ) //undefined//例 判断的用户的年龄 如果满足18以上就给用户一个弹窗// let age = +prompt(&#x27;你今年多大&#x27;)// let result =  age &gt; 18 &amp;&amp; alert(&#x27;恭喜你进入了这个网站&#x27;)//优先级的问题,  在逻辑判断的时候 逻辑 &amp;&amp; 比逻辑 || 优先级更高console.log(null || 2 &amp;&amp; 3 || 4)/*     null || 3 || 4    3*//*     逻辑非    书写方式 !    表示取反 非运算符得到的结果一定是一个布尔值*/console.log(!&#x27;123&#x27;) // falseconsole.log(!!&#x27;123&#x27;)//ture //应用场景 需要将ss 变量的值转换为布尔值let ss =&#x27;asdkfjhkasfd&#x27;console.log(Boolean(ss))console.log(!!ss)\n\n类型转换与与运算符总结数据类型总结有三种常用的类型转换：转换为 string 类型、转换为 number 类型和转换为 boolean 类型。\n字符串转换 —— 转换发生在输出内容的时候，也可以通过 String(value) 进行显式转换。原始类型值的 string 类型转换通常是很明显的。\n数字型转换 —— 转换发生在进行算术操作时，也可以通过 Number(value) 进行显式转换。\n数字型转换遵循以下规则：\n\n\n\n值\n转换后\n\n\n\nundefined\nNaN\n\n\nnull\n0\n\n\ntrue\n1\n\n\nfalse\n0\n\n\nstring\n去掉首尾空格后的纯数字字符串中含有的数字。如果剩余字符串为空，则转换结果为 0。否则，将会从剩余字符串中“读取”数字。当类型转换出现任何一个 非数字 时返回 NaN 。\n\n\n“按原样读取”字符串，两端的空白会被忽略。空字符串变成 0。转换出错则输出 NaN。\n布尔型转换 —— 转换发生在进行逻辑操作时，也可以通过 Boolean(value) 进行显式转换。\n布尔型转换遵循以下规则： 除了 0, null, undefined, NaN, &quot;&quot;\nfalse\n\n其他值都为\ntrue\n\n上述的大多数规则都容易理解和记忆。人值得注意的例子有以下几个：\n\n对 undefined 进行数字型转换时，输出结果为 NaN，而非 0。\n对 &quot;0&quot; 和只有空格的字符串（比如：&quot; &quot;）进行布尔型转换时，输出结果为 true。\n\n我们在本小节没有讲 object 类型的转换。在我们学习完更多关于 JavaScript 的基础知识后，我们会在专门介绍 object\n算术运算小总结\n如果一个侧为NaN，则结果为NaN\n如果两侧都是数字，则进行加法运算\n如果两侧都是字符串则进行字符串连接\n如果一侧为字符串，另一侧是其他类型，则转成字符串之后，然后进行字符串连接\n只要 + 旁边有一个为字符串就会变成字符串拼接\n除了加法以为其他的数学运算符都会转为数字进行计算，无法计算的都返回NaN\n\nday06-控制流程空值合并运算&#x27;use strict&#x27;;   /*        空值合并运算符       语法 a ?? b       空值合并是专门用于区分undefined 和 null 这两个特殊值的       运算流程 如果当前不是undefined 和 null 就返回当前值,如果是undefined 和 null就继续下一次判断,如果都是undefined 和 null就返回最后一个结果   */   // console.log(undefined ?? 123)//123   // console.log(undefined ?? null)//null   // console.log(123 ?? null)//123   // console.log(undefined ?? null ?? 456)//456   // console.log(NaN ?? 123)//NaN   //应用场景   let userName = 0;   //保护用户的昵称,如若用户没有输入昵称就给他个默认昵称   console.log(userName || &#x27;默认昵称&#x27;) //默认昵称   console.log(userName ?? &#x27;默认昵称&#x27;) //0    let a = 0;   let b;   //计算他们的乘积 如果没有值就用默认值 1计算   console.log(a ?? 1 * b ?? 1)//0   console.log(a || 1 * b || 1) //1   // 空值合并 不可以和逻辑运算 &amp;&amp; || 一起运算   // let xxx = 1 &amp;&amp; (2 ?? 3);\n\n流程控制语句 &#x27;use strict&#x27;; /*      流程控制语句     用于控制代码走向的语句     1. 顺序结构         代码从上到下执行     2. 分支结构         根据不同的情况执行不同的代码     3. 循环结构         重复的做某一些事情 *//*      条件语句 if     写法一     if(表达式)&#123;         代码块     &#125;     如果表达式成立那就执行代码块里的代码     写法二     if(表达式)&#123;         //条件满足代码块     &#125;else&#123;         //条件不满足执行的代码块     &#125;     写法三      if(表达式)&#123;         //条件满足代码块     &#125;else if()&#123;         //第二次判断     &#125;else&#123;     &#125;     分支语句永远只会执行一个结果内的代码 */ //张三遇到一个喜欢的妹妹 ,追求妹妹 , 如果张三有 1000块钱就可以约到心意的妹妹出来吃饭 let money = 5000 //张三的钱 let key = false //是否有钻戒 true有false表示没有 // if(money &gt; 1000)&#123; //     console.log(&#x27;约会成功&#x27;) // &#125; //如果约会不成功的话需要给出反馈比如骂张三一顿 // if(money &gt; 1000)&#123; //     console.log(&#x27;约会成功&#x27;) // &#125;else&#123; //     console.log(&#x27;今天身体不舒服不去了&#x27;) // &#125; //张三要进行求婚  /*      求婚需要准备一个戒指     还需要准备2w块钱     1. 如果你有2w块钱就可以去求婚     2. 如果你有5000块 并且 你有一个钻戒也可以考虑考虑     3. 如果你5000都没有那就求婚失败 */ // if(money &gt;= 20000)&#123; //     console.log(&#x27;求婚成功&#x27;) // &#125;else if(money &gt;= 5000 &amp;&amp; key)&#123; //     console.log(&#x27;考虑一下&#x27;) // &#125;else&#123; //     console.log(&#x27;求婚失败嘻嘻嘻&#x27;) // &#125; let grade = -120 //分数 /*      考试评分      grade &gt; 90 给出评分 A     grade &gt; 80 给出评分 B     grade &gt; 70 给出评分 C     grade &gt; 60 给出评分 D     grade &lt; 60 给出评分 E     把最难实现的放到判断的最前面 */ //错误示范 // if(grade &gt; 60)&#123; //     console.log(&#x27;E&#x27;) // &#125;else if(grade &gt; 70)&#123; //     console.log(&#x27;D&#x27;) // &#125; //正确示范 // if(grade &gt;= 90)&#123; //     console.log(&#x27;A&#x27;) // &#125;else if(grade &gt;= 80)&#123; //     console.log(&#x27;B&#x27;) // &#125;else if(grade &gt;= 70)&#123; //     console.log(&#x27;C&#x27;) // &#125;else if(grade &gt;= 60)&#123; //     console.log(&#x27;D&#x27;) // &#125;else &#123; //     console.log(&#x27;E&#x27;) // &#125; let result = &#x27;E&#x27; if(grade &lt;= 100 &amp;&amp; grade &gt;= 0)&#123;     if(grade &gt;= 90)&#123;         result = &#x27;A&#x27;     &#125;else if(grade &gt;= 80)&#123;         result = &#x27;B&#x27;     &#125;else if(grade &gt;= 70)&#123;         result = &#x27;C&#x27;     &#125;else if(grade &gt;= 60)&#123;         result = &#x27;D&#x27;     &#125;else &#123;         result = &#x27;E&#x27;     &#125; &#125; console.log(result)\n\n三目表达式&#x27;use strict&#x27;;/*     三目运算 || 三元运算符    就是 if else 的简写方案    语法 表达式 ? 表达式成立结果 : 表达式失败的结果*/// let age = +prompt(&#x27;age&#x27;,19)//if写法// if(age &gt; 18)&#123;//     console.log(&#x27;成年人&#x27;)// &#125;else&#123;//     console.log(&#x27;未成年&#x27;)// &#125;//优化1// age &gt; 18 ? console.log(&#x27;成年人&#x27;) :  console.log(&#x27;未成年&#x27;)//优化2// console.log(age &gt; 18?&#x27;成年人&#x27;:&#x27;未成年&#x27;)//多个 ? 一起使用, 循环判断 , 判断年龄阶段 age &lt; 3 就是婴儿, age &lt; 18 未成年 age &lt; 25 青年 , age &lt; 50 中年 ,age &lt; 100 老年let message = &#x27;&#x27;// if(age &lt;= 3)&#123;//     message = &#x27;婴儿&#x27;// &#125;else if(age &lt;= 18)&#123;//     message = &#x27;未成年&#x27;// &#125;else if(age &lt;= 25)&#123;//     message = &#x27;青年&#x27;// &#125;else if(age &lt;= 50)&#123;//     message = &#x27;中年&#x27;// &#125;else&#123;//     message = &#x27;老年&#x27;// &#125;//优化// message = (age &lt;= 3) ? &#x27;婴儿&#x27; : (age &lt;= 18) ?  &#x27;未成年&#x27;:(age &lt;= 25)? &#x27;青年&#x27; : &#x27;其他情况&#x27;// console.log(message) /*      if(a)&#123;        code    &#125;     //逻辑运算写法    a &amp;&amp; code    if(a &gt; b)&#123;        c    &#125;else&#123;        d    &#125;    //三目    a&gt;b?c:d    //逻辑运算    a &amp;&amp; c || d*///应用场景  数字补0let num = 8 // 补0以后 01   10 补0 = 10//if写法 // if(num &lt; 10)&#123;//     num = &#x27;0&#x27;+num// &#125;else&#123;//     num = String(num)// &#125;//三目// num &lt; 10 ? num = &#x27;0&#x27;+num : num = String(num)// num = num &lt; 10 ? &#x27;0&#x27;+num : String(num)//逻辑运算// num = num &lt; 10 &amp;&amp; &#x27;0&#x27;+num || String(num)\n\nswith语句&#x27;use strict&#x27;;/*     swith 语句可以用于替代多个if的判断    swith 语句是大量分支语句组成的一种语句, 比if更加直观    语法    swith(判断的值)        case vlaue1 //判断 值是否等于 value1            代码块 // 如果满足条件就执行代码块的内容        break//跳出当前case判断        case vlaue2 //下一次判断该值是否等于 vlaue2        break    break 是跳出当次判断, 这个值不是必须的, 可以不写,不写就是落空的情况, 落空可以用于多次判断 可以理解为逻辑或*///数字转大写 输入 1 最终转换为 一 输入2 转换为二let num = 1let result = &#x27;一&#x27;;// if(num === 1)&#123;//     result = &#x27;一&#x27;// &#125;else if(num === 2)&#123;//     result = &#x27;二&#x27;// &#125;else if(num === 3)&#123;//     result = &#x27;三&#x27;// &#125;//swith 写法// switch(num)&#123;//     case 1: //if(num === 1)//         result = &#x27;一&#x27; //     break //跳出当次判断//     case 2://num === 2//         result = &#x27;二&#x27;//     break//     case 3://         result = &#x27;三&#x27;//     break// &#125;//num 表示星期几 输入是否是工作日switch(num)&#123;    case 1:     case 2://当num 为1或者num 为2 的时候执行代码块的内容        console.log(&#x27;上班&#x27;)    break    case 3:        console.log(&#x27;解答&#x27;)    break    case 4:    case 5:        console.log(&#x27;上班&#x27;)    break    case 6:    case 7:        console.log(&#x27;休息&#x27;)    break&#125;//非主流的玩法//switch 的值可以传入一个布尔值true ,无论什么情况都能进入swithc let jifen = 100000switch (true) &#123;    case jifen &gt; 10000: //swith为true 的情况内部的case可以为表达式        console.log(&#x27;贵族5&#x27;)        break;    case jifen &gt; 8000:        console.log(&#x27;贵族4&#x27;)        break;   case jifen &gt; 5000:        console.log(&#x27;贵族3&#x27;)        break;    case jifen &gt; 2000:        console.log(&#x27;贵族2&#x27;)        break;    case jifen &gt; 1000:        console.log(&#x27;贵族1&#x27;)        break;    default: //default 最终值,如果上面的所有case都没成功就会走 defalut 的结果        console.log(&#x27;重置1000以上才有贵族&#x27;)        break;&#125;\n\n运算符总结\n比较运算符始终返回布尔值。\n字符串的比较，会按照“词典”顺序逐字符地比较大小。\n当对不同类型的值进行比较时，它们会先被转化为数字（不包括严格相等检查）再进行比较。\n在非严格相等 == 下，null 和 undefined 相等且各自不等于任何其他的值。\n在使用 &gt; 或 &lt; 进行比较时，需要注意变量可能为 null/undefined 的情况。比较好的方法是单独检查变量是否等于 null/undefined。null是可以在比较的时候转为数值的,但是undefined不可以\nNaN 跟任何值都想等\n\n逻辑运算总结\n逻辑运算 &amp;&amp; 和 || 在运算的时候 会将运算元 临时转换为布尔值\n逻辑&amp;&amp; 如果条件为真走下一次判断,如果条件为假返回当前结果并且停止后续判断,全为真返回最后一次判断的结果\n逻辑|| 如果条件为假走下一次判断,如果条件为真返回当前结果并且结束后续判断,全为假返回最后一次判断的记过\n逻辑! 将运算的值转换为布尔值并且取相反的结果\n\nday07-循环语句循环语句&#x27;use strict&#x27;;/*     循环语句    应用场景 适用于处理一些需要重复执行的操作, 比如打印1-10的所有整数    循环就是一种重复运行同一个代码的方法    循环在js中一共有    for    while    do while    //讲对象和数组的时候讲    for in    for of    while 循环    语法    while(condition)&#123; // condition 判断条件        //body 代码块区域    &#125;    当判断条件为真的时候执行代码块区域的所有代码 为假跳出循环    循环体的单词执行就称为一次迭代*///例如输入1-10之间的整数// let index = 0 // 1 2 9 10 11// while (index &lt;= 10) &#123; //条件必须要有机会能成为false 不然就会死循环//     console.log(index)//0 1 9 10 //     index++  // 9 10 11 // 必须有改变判断条件的语句 ,改变的目的是为了让循环能有终止的情况// &#125;// console.log(index)//11//循环的判断条件不一定非要是表达式, 也可以是一个变量,当然你要确定这个变量有机会转换为布尔值 false,  0 null false undefined &#x27;&#x27; NaN//打印10-1之间的所有整数// let index = 10// while (index) &#123;//     console.log(index--) //10 9 .... 1// &#125;/* while (index) (console.log(index), index--); */  //循环内还可以嵌套其他任何语句//打印1-100之间的所有偶数// let indx = 0// while(indx &lt;= 100)&#123;//     // if(indx % 2 == 0)&#123; //满足 % 2等于0 说明是偶数//     //     console.log(indx)//     // &#125;//     console.log(indx)//     indx+=2// &#125;/*     do while 语句    跟 while 语句非常类似 , 但是它的代码块区域不在whiel的&#123;&#125;内,而是在do的花括号内    do &#123;        //body循环体代码块区域    &#125; while (condition);//condition 终止条件    跟while的区别在于 dowhile会先进行一次代码块的执行再进行条件判断*/// let index = 0// do &#123;//     //body循环体代码块区域//     //改变条件的值 //     index++//     console.log(index)// &#125; while (index &lt;= 10);//condition 终止条件\n\nfor循环&#x27;use strict&#x27;; /*     for 循环     语法    for(begin;condition;step)&#123;        //body    &#125;    begin 初始化表达式    condition 判断条件    step 更新初始值    body 循环体 */ //打印 0 - 3 之间的整数 ,不包含3 , 一共需要迭代3次//  let index = 3//  while (index &lt;= 0) &#123;//     index--//     console.log(&#x27;你好&#x27;)//  &#125;// for (let index = 0; index &lt; 3; index++) &#123;//     console.log(index)// 0 1 2 // &#125;//内置变量 , 循环内初始表达式创建的变量外部是无法访问的// console.log(index)//执行规则/* 第一次迭代- 初始化变量 let index = 0- 判断表达式是否成立 index &lt; 3 , 如果成立就运行body- 执行 更新初始值index++第二次迭代- 判断表达式是否成立 index &lt; 3 , 如果成立就运行body- 执行 更新初始值index++*///初始化变量// let index = 0// //判断条件是否为真// if(index &lt; 3)&#123; console.log(index);index++&#125;// if(index &lt; 3)&#123; console.log(index);index++&#125;// if(index &lt; 3)&#123; console.log(index);index++&#125;//for 循环的每一个区域都可以省略 或者抽离出来// let index = 0//初始化表达式抽离到外面// for (;index &lt; 3 ;index++ ) &#123;//    console.log(index,&#x27;循环体内&#x27;)// &#125;// console.log(index,&#x27;循环外&#x27;)// for (let index = 0; ;index++ ) &#123;//    if(index &lt; 3)&#123;//     console.log(index)//    &#125;else&#123;//      break//    &#125;// &#125;//省略step // for (let index = 0; index &lt; 3; ) &#123;//     console.log(index)//     index++// &#125;//3条语句都省略 就是一个死循环 , 但是不能省略分号// for (;;) &#123;    // &#125;//嵌套循环 10*10 = 100for (let index = 0; index &lt; 10; index++) &#123; // 0 1 2    for (let k = 0; k &lt; 10; k++) &#123; // 1 - 10 1-10  1-10         console.log (&#x27;坐标&#x27;,index,k)    &#125;&#125;\n\nfor循环break&#x27;use strict&#x27;;/*     循环控制语句    当你需要手动提前从循环过程中结束或者跳出的时候就可以使用循环控制语句    分别是    continue 表示跳出当次循环继续下一次循环    break 表示跳出整个循环*///找 0 - 100 之间第一个能被13整除的数, 除了13自身以外let num = 0//记录已经找到了几个 满足条件for (let i = 1; i &lt;= 100; i++) &#123;    if(i % 13 == 0 &amp;&amp; i != 13)&#123;        console.log(i)        num++ //更新当前找到了几个        //找到第一个以后停止后续循环        //新增需求, 我还需要找到第二个能被13整除的数怎么操作        if(num == 2)&#123;            break //跳出了所有的循环        &#125;    &#125;&#125;//跳出当次循环 ,应用场景  找50-100的所有偶数for (let i = 50; i &lt;= 100; i++) &#123;    if(i % 2 != 0)&#123;        continue //如果他不是偶数就跳出当次循环    &#125;    console.log(i)&#125;\n\nday08-函数基础函数基础&#x27;use strict&#x27;;    /*         函数基础        函数的主要作用就是用于构建模块, 函数可以使一段大量的代码存储到一起, 在合适的地方执行        通俗一点函数就是一堆语句的集合, 可以独立执行的程序单元, 本质上就是一个子程序, 函数是js的核心        创建语法        function fnName()&#123;  // fnName 表示函数的名称            //函数体内的代码        &#125;    */       ///创建函数 函数声明    // function name()&#123;    //     //函数体代码块区域    //     console.log(&#x27;123&#x27;)    //     console.log(&#x27;446&#x27;)    //     let age = 18    //     console.log(age)    // &#125;    // //执行函数    // name()     // console.log(typeof alert) //function    //自己写一个log方法用于简化console.log    let age = 19    function log()&#123;        //函数体内是一个全新的环境        let age = 18 //内部变量和外部变量相同时我们称为变量遮罩,出现这种情况的时候函数会优先使用内部的变量        console.log(&#x27;123&#x27;,age) //函数内是可以访问函数外部的变量    &#125;    log()    log()    // console.log(age)// 函数外是无法访问函数内的变量\n\n函数的参数&#x27;use strict&#x27;;    /*         函数的参数        形参  形式参数 , 在函数创建的时候可以以变量的形式接受外界传递过来的一些数据        实参  实际参数, 在函数调用的时候传递过去的数据,对应的是函数的形参接受        语法         function fnName(parme1,parme2....)&#123; //形参        &#125;        fnName(parme1,parme2....)//实参        实参跟形参必须一一对应    */    // function log(txt)&#123; // txt 表示一个形参变量    //     // let txt = &#x27;123&#x27;    //     console.log(txt)    // &#125;    // // console.log(&#x27;123&#x27;)    // log(&#x27;123&#x27;) //123就是实参数    //需求 需要一个函数 用于计算 1+1 的结果    function sum()&#123;        let ss = 1 + 1        console.log(ss)    &#125;    //需求, 计算3+4怎么办    function sum2()&#123;        let ss = 3 + 4        console.log(ss)    &#125;    //计算99+33呢    function sumPam(a,b,c)&#123;        //形参没有对应的实参接受 , 他的默认值就是undefined        console.log(c)// undefined        //a = 33 b = 99        let ss = a + b         console.log(ss)    &#125;    // sum()    // sum2()    // sumPam(33,99)    // sumPam(123,456)    // sumPam(123)    //函数参数默认值 es6 可以支持设置参数默认值    // function sumPam2(a=0,b=1)&#123;//b 参数的默认值为1 , 没有实参对应就用默认值    //     let ss = a * b     //     console.log(ss)    // &#125;    // sumPam2(1,2)    // sumPam2()    //后备参数    function sumPam2(a,b)&#123;//b 参数的默认值为1 , 没有实参对应就用默认值        //解决方案1        a = a || 0        //b = b || 1 //存在一个问题就是无法判断0        //解决方法        // if(typeof b != &#x27;number&#x27;)&#123;        //     b = 1        // &#125;        b = b ?? 0        let ss = a * b         console.log(ss)    &#125;    sumPam2(1,1)\n\n断点测试&#x27;use strict&#x27;;     let num = 0     for (let big = 0; big &lt;= 50; big++) &#123; // 1 2       //中马        for (let middle = 0; middle &lt;= 100; middle++) &#123; //1            //小马            for (let small = 0; small &lt;= 200; small++) &#123; // 1 - 200                // debugger                if(small+middle+big == 100 &amp;&amp; small*0.5+middle*1 + big*2 == 100)&#123;                    ///最优分配方法                    console.log(`大马用了$&#123;big&#125;头,中马用了$&#123;middle&#125;,小马用了$&#123;small&#125;头`)                    num++                &#125;            &#125;        &#125;    &#125;    console.log(num)\n\n循环总结三种循环：while()&#123;&#125; —— 每次迭代之前都要检查条件。do&#123;&#125;..while() —— 每次迭代后都要检查条件。for (1begin;2con;3step)&#123;4&#125; —— 每次迭代之前都要检查条件，可以使用其他设置。通常使用 while(true) 来构造“无限”循环。这样的循环和其他循环一样，都可以通过 break 指令来终止。如果我们不想在当前迭代中做任何事，并且想要转移至下一次迭代，那么可以使用 continue 指令。\n\nday09-继续函数学习函数的命名&#x27;use strict&#x27;;    /*         函数通常是用于标识某个行为, 一般情况他们的命名都是动词加名词的组成        例        get -- 获取或者是返回某个值        calc -- 用于计算某些内容        create -- 创建某些内容        check -- 检测内容返回布尔值        is -- 判断内容漫步满足条件 返回布尔值        .....        showMessage()         calcSum()        createTable()        checkUser()        checkAdmin()    */\n\n函数的返回值&#x27;use strict&#x27;;    /*         函数返回值        函数返回值 可以将函数内部的值作为函数表达式的结果返回出去        默认情况下函数没有手动指定返回值的时候默认是返回 undefined        借助关键词return 可以再函数内部任意的位置执行,当执行到return语句的时候 会立马终止函数的执行,并且将return关键词后面的表达式或者字面量内容作为表达式的结果返回出去    */    //函数声明  = 函数表达式    function fn()&#123;        let  message = &#x27;123&#x27;        return 123 //函数停止执行 并且将 123 这个数值作为结果返回出去        console.log(456)// 不会打印    &#125;    let fnRes = fn()    console.log(fn()) // 123    console.log(fnRes) // 123    let age = 13    // let age = +prompt(&#x27;你今年多大&#x27;)    function isAdult(age)&#123;        //期望函数检测年龄是否成年,并且返回一个布尔值        // return num &gt;= 18 ? true : false        // if(age &gt;= 18)&#123;        //     return true        // &#125;else&#123;        //     return confirm(&#x27;你父母是否在旁边陪同&#x27;)        // &#125;    &#125;    // console.log(isAdult(1))    // if(isAdult(age))&#123;    //     alert(&#x27;欢迎用户进入&#x27;)    // &#125;else&#123;    //     alert(&#x27;未成年人进制入内&#x27;)    // &#125;\n\n函数表达式&#x27;use strict&#x27;;    //函数声明    function fn1()&#123;        console.log(&#x27;123&#x27;)    &#125;    //函数表达式创建    let fn2 = fn1     //函数表达式创建2  格式 let fnname = 匿名函数    let fn3 = function()&#123;        console.log(&#x27;456&#x27;)    &#125;    // fn1()    // fn2()    // fn3()    //函数声明和函数表达式的区别    // fff()//函数声明创建的函数可以再创建函数之前调用函数    function fff()&#123;        console.log(&#x27;ffff&#x27;)    &#125;    // kkk()//函数表达式创建的函数不可以在创建之前调用    let kkk = function()&#123;        console.log(&#x27;kkkk&#x27;)    &#125;    // kkk()    let age = 14    //用户年龄检测的程序, 根据用户年龄的大小决定欢迎语句    // if(age &lt; 18)&#123;    //     function welcome()&#123;    //         console.log(&#x27;欢迎小朋友光临&#x27;)    //     &#125;    // welcome()            // &#125;else&#123;    //     //函数只在内部能访问到    //     function welcome()&#123;    //         console.log(&#x27;欢迎光临&#x27;)    //     &#125;    // &#125;    // // welcome()// 报错    let welcome;    if(age &lt; 18)&#123;        welcome =  function ()&#123;            console.log(&#x27;欢迎小朋友光临&#x27;)        &#125;    &#125;else&#123;        //函数只在内部能访问到        welcome =  function ()&#123;            console.log(&#x27;欢迎光临&#x27;)        &#125;    &#125;    welcome()\n\n箭头函数&#x27;use strict&#x27;;/*     箭头函数     箭头函数就是普通函数的另一种写法 , 而且这种写法比普通的函数表达式效果更好    箭头函数就是普通函数的简写方案    标准简化规则    1. 省略function关键词和函数名称    2. 保留函数参数部分    3. 参数部分新增一个 箭头写法 =&gt;    4. 箭头后面书写代码块和代码块内的内容*/// function fn(a,b,c)&#123;//     console.log(&#x27;1asdf&#x27;)//     return true// &#125;//标准简化// let fn =  (a,b,c)=&gt;&#123;//     console.log(&#x27;1asdf&#x27;)//     return true// &#125;// let fn2 =  function()&#123;//     console.log(&#x27;1asdf&#x27;)//     return true// &#125;//简化// let fn2 = ()=&gt;&#123;//     console.log(&#x27;1asdf&#x27;)//     return true// &#125;// fn2()//变种写法//1. 当传递参数只有一个的时候 是可以省略括号的// let ff2 = function(a)&#123;//     console.log(a)//     return a// &#125;// let ff22 = a=&gt;&#123;console.log(a);return a &#125;// ff22(1)//2.当函数体内只有一条语句的的时候可以省略花括号// let ff3 = function(a)&#123;//     console.log(a)// &#125;// ff3(1)// let ff33 = a=&gt;console.log(a);//3. 可以通过逗号运算符进行大量的简化let ff4 = function(x,y)&#123;    x = x+2    y = x * y    return y&#125;let ff44 = (x,y)=&gt;(x = x+2,y = x * y,y)console.log(ff4(3,4))console.log(ff44(3,4))S\n\n回调函数&#x27;use strict&#x27;;/*     回调函数    当函数作为参数传递给另一个函数的时候,我们就称这个函数的参数为回调函数*/// function fn(cb)&#123;//cb对应的函数 就称为回调函数//     console.log(cb) // function...//     cb()// &#125;// let f = function()&#123;//     console.log(&#x27;回调函数执行成功&#x27;)// &#125;// fn(f)//编辑问答函数 ask(question,yes,no) /*     question 提问的问题     yes 回答正确需要做的事情     no 回答错误需要做的事情*/function showYes() &#123;    for (let index = 0; index &lt; 5; index++) &#123;        console.log(&#x27;我吃了我吃了&#x27;)        console.log(&#x27;我吃了我吃了&#x27;)    &#125;&#125;function showYes2() &#123;    for (let index = 0; index &lt; 5; index++) &#123;        console.log(&#x27;睡醒了睡醒了&#x27;)        console.log(&#x27;睡醒了睡醒了&#x27;)    &#125;&#125;function showNo2()&#123;    for (let index = 0; index &lt; 5; index++) &#123;        console.log(&#x27;还没睡醒&#x27;)        console.log(&#x27;还没睡醒&#x27;)    &#125;&#125;function showNo() &#123;    for (let index = 0; index &lt; 5; index++) &#123;        console.log(&#x27;还没吃饱还没吃饱&#x27;)        console.log(&#x27;还没吃饱还没吃饱&#x27;)    &#125;&#125;function ask(question,yes,no) &#123;    if (confirm(question)) &#123;        //选择正确        yes()    &#125; else &#123;        //选择错误        no()    &#125;&#125;ask(&#x27;你吃饭了吗&#x27;,showYes,showNo)ask(&#x27;你睡着了吗&#x27;,showYes2,showNo2)\n\n纯函数和非纯函数&#x27;use strict&#x27;;    /*         纯函数 : 函数的执行的过程中不会影响到到外界环境中的变量只依赖于自身函数内的数据执行的函数就称为纯函数        非纯函数 : 函数的内部的执行需要依赖外界的参数或者函数的执行会改变外检的参数 就叫非纯函数    */       //纯函数    function padLeft(num)&#123;        return num &lt; 10? &#x27;0&#x27;+num : num    &#125;    console.log(padLeft(3))    console.log(padLeft(10))    //非纯函数    let result = 0    function sum(a,b)&#123;        result = a+b    &#125;    sum(2,3)    console.log(result)\n\n柯里化函数&#x27;use strict&#x27;;    /*         柯理化 currying        当函数的返回值还是一个函数的时候,那这个函数就称为柯理化函数        柯理化函数的应用场景是用于将复杂的功能分解成多个小功能    */    function add(x,y)&#123;        return x+y    &#125;    console.log(add(3,3))    function addCury(x)&#123;        return function(y)&#123;            return x+y         &#125;    &#125;    //需求每次计算的值都是 125 加y的值    console.log(add(125,5))    console.log(add(125,6))    console.log(add(125,10))    // console.log(addCury(1)(2))    let curAdd = addCury(125) // function(y)&#123;return x+y &#125;    console.log(curAdd(5))    console.log(curAdd(6))    console.log(curAdd(123))    /*         更多的高级函数 后续了解 工厂函数 ,偏函数, 递归函数....    */\n\nday10-对象与数组对象&#x27;use strict&#x27;;/*     基础数据类型 number null undefined string....     引用数据类型 Object    万物皆对象    对象是一个无序的集合, 用于存储一堆杂乱的数据    创建方式     1. 通过字面量创建 let xx =  &#123;&#125;    js中的对象分为三种    - 内置对象(Number Boolean,Array,Math ...)    - 浏览器对象(XMLM , window , Navigator,...)    - 自定义对象(构造函数对象)    对象中的属性名只能是一个字符串*/   //对象的创建 内置方法创建let obj = new Object()obj.age = 19//字面量创建对象let yaSuo = &#123;&#125;// console.log(obj)// console.log(xx)//对象数据的新增  对象内数据的存储都是以键值对的形式作为存储 格式属性名 : 属性值//通过 .操作符存储数据yaSuo.ph = 100 // 在yasuo变量中存储了一个属性叫ph 值为 100yaSuo.name = &#x27;疾风剑豪&#x27; // 在yasuo变量中存储了一个属性叫name 值为 &#x27;疾风剑豪&#x27;// yaSuo.font-size = 200 //错误写法不能用点操作符存储 有连字符的属性名//中括号存储数据 语法 obj[string] = xxx  存储的string 就表示在obj对象中的属性名  中括号可以解析变量yaSuo[&#x27;max-ph&#x27;] = 200;let heightName = &#x27;height&#x27; yaSuo[heightName] = &#x27;200px&#x27;; //yaSuo[&#x27;height&#x27;] = &#x27;200px&#x27;;let ageName = &#x27;age&#x27;yaSuo.ageName = &#x27;123&#x27;//在yaSuo变量中存储一个 ageName 的属性名值为 123yaSuo[ageName] = &#x27;16&#x27;//对象的取值 , 语法  不赋值直接访问对象的属性名就是取值console.log(yaSuo.age) //16console.log(yaSuo[&quot;max-ph&quot;])//200console.log(yaSuo[heightName])//200px//可以创建的时候就添加对象的值let teacher = &#123;    name : &#x27;夏栀&#x27;,    age : 18,    marry : false,    fd : &#123;        xuxing : &#123;            name : &#x27;xuxing&#x27;,            age : 39        &#125;,        luyao : &#123;            name : &#x27;luyao&#x27;,            age : 19        &#125;,        afei : &#123;            name : &#x27;afei&#x27;,            age : 20        &#125;    &#125;&#125;//嵌套结构访问规则 必须层访问console.log(teacher.fd.xuxing.age)//访问对象中不存在的值默认是undefinedconsole.log(teacher.color)//undefined //重复添加相同的属性名会覆盖//对象的修改值teacher.color = &#x27;blue&#x27;teacher.color = &#x27;red&#x27;teacher[&#x27;age&#x27;] += 1 //对象删除属性 语法  delete obj.attr 删除obj下的attr属性delete teacher.color;delete teacher.fd;// delete teacher; //错误示范, 不可以直接删除对象//删除整个对象// teacher = null//对象属性的计算属性let ballName = &#x27;lnaqiu&#x27;;let ball = &#123;    [ballName+&#x27;Count&#x27;] : 6&#125;\n\n对象的简写方案&#x27;use strict&#x27;;/* 对象的简写*/function makeUser(name,age)&#123;    // return &#123;    //     &quot;name&quot; : name,    //     &quot;age&quot; : age    // &#125;    //属性值和属性名相同的时候可以简写为只写一个属性值    return &#123;        name,        age    &#125;&#125;let user1 = makeUser(&#x27;xuxing&#x27;,20)let user2 = makeUser(&#x27;xiazhi&#x27;,19)//对象新增属性user1.sex = &#x27;sex&#x27;//特殊值 __proto__ 不可以用于做属性名// user1.__proto__ = &#x27;123&#x27;//为用户添加一个id值, 如果用户已经有了id值就不能再添加function setId(obj,idStr)&#123;    // if(!obj.id)&#123;    //     //不存在id值    //     obj.id = idStr    //     console.log(&#x27;添加成功&#x27;)    // &#125;else&#123;    //     console.log(&#x27;id已经存在不要重复添加&#x27;)    // &#125;    //检测对象中是否存在 该属性 语法 attr in obj 检测 attr属性是否存在于obj   attr 必须是一个字符串 ,返回值是一个布尔值存在返回true    if(!(&#x27;id&#x27; in obj))&#123;        //不存在id值        obj.id = idStr        console.log(&#x27;添加成功&#x27;)    &#125;else&#123;        console.log(&#x27;id已经存在不要重复添加&#x27;)    &#125;    &#125;user2.id = undefined;console.log( &#x27;id&#x27; in user2)//tureconsole.log( &#x27;id123&#x27; in user2) //falsesetId(user1,&#x27;xxxxx&#x27;)setId(user1,&#x27;kkkk&#x27;)setId(user2,&#x27;23324&#x27;)\n\n对象遍历&#x27;use strict&#x27;;/*     for in 循环用于专门遍历对象的一个循环    语法    for (let key in object) &#123; //key表示属性名 object需要遍历的对象    &#125;*/let user = &#123;    name : &#x27;xuxing&#x27;,    age : 19,    sex : &#x27;nan&#x27;,    isAdmin : true&#125;for (const key in user) &#123;    console.log(key,&#x27;属性名&#x27;)//name age sex isAdmin    // console.log(user[key],&#x27;属性值&#x27;)//xuxing 19&#125;//遍历的顺序  , 如果属性名都是合法的数值字符串就会按照数值字符串的大小进行顺序迭代 从小到大的顺序, 不满足这个条件就会根据创建属性的先后顺序遍历let idObj = &#123;    &#x27;12&#x27;:&#x27;xxxx&#x27;,    &#x27;23&#x27;:&#x27;yyyy&#x27;,    &#x27;15&#x27;:&#x27;wwww&#x27;,    &#x27;88&#x27;:&#x27;dddd&#x27;,&#125;for (const key in idObj) &#123;    console.log(key,&#x27;属性名&#x27;)&#125;\n\n对象与基础类型的区别&#x27;use strict&#x27;;/* 关于数据类型的引用和复制 */let message = &#x27;hello&#x27;let copyMes = message //hello//修改copyMes的内容copyMes = &#x27;word&#x27;console.log(message,copyMes)//引用类型let  user = &#123;name:&#x27;xuxing&#x27;&#125;let  copyUser = user//需要给copyUser新增一个年龄属性copyUser.age = 19user.sex = &#x27;男&#x27;// console.log(user === copyUser)/*     js存储数据的规则    - 基础类型    1. 在内存中的栈内存中直接存储变量的标识符和变量的值    2. 基础类型是可以直接访问内存中存储的实际值    3. 不能给基础类型添加属性和方法    - 引用类型    1. 引用类型是按照引用地址来进行存储的    2. 引用类型有自己的属性和方法, 并且是可以动态修改的    3. 引用类型的存储数据会同时使用到栈内存和堆内存    4. 会在栈内存中存储数据的引用地址,真实数据存储于堆内存中*/let obj111 = &#123;&#125;let obj222 = &#123;&#125;let str1 = &#x27;123&#x27;let str2 = 123// console.log(obj111 === obj222)//false// console.log(obj111 == obj222)//fasle// console.log(str1 == str2)//浅拷贝, 需求拷贝一个对象, 并且不和原有的对象有关联let xuxing = &#123;    name : &#x27;xuxing&#x27;,    age : 10,    sex : &#x27;男&#x27;,    fd : &#123;        name : &#x27;123&#x27;    &#125;&#125;// let copyX = &#123;&#125;// copyX.name = xuxing.name// console.log(xuxing == copyX)//浅拷贝对象function coypeObj(obj)&#123;    let newObj = &#123;&#125;    //方案一利用循环拷贝    //将obj对象的属性和值添加到 newObj中    // for (const key in obj) &#123;    //    newObj[key] = obj[key]    // &#125;    //方案二利用 Object.assgin() 方法    /*      Object.assgin(target,obj1,obj2...)用于做对象合并      作用将 obj1 和 obj2 对象合并到 target对象    */    Object.assign(newObj,obj)    return newObj&#125;let coyX = coypeObj(xuxing)coyX.height = 150console.log(coyX === xuxing) //ture//浅拷贝无法切断对象嵌套对象的情况console.log(coyX.fd === xuxing.fd) //ture\n\n函数基础总结函数总结函数就是一堆 语句的集合， 可以独立执行的程序单元\n\n函数是值。它们可以在代码的任何地方被分配，复制或声明。\n如果函数在主代码流中被声明为单独的语句，则称为“函数声明”。\n如果该函数是作为表达式的一部分创建的，则称其“函数表达式”。\n在执行代码块之前，内部算法会先处理函数声明。所以函数声明在其被声明的代码块内的任何位置都是可见的。\n函数表达式在执行流程到达时创建。\n函数执行一定会有一个返回值默认是 undefined 可以使用关键词return手动指定返回的内容\n\n在大多数情况下，当我们需要声明一个函数时，最好使用函数声明，因为函数在被声明之前也是可见的。这使我们在代码组织方面更具灵活性，通常也会使得代码可读性更高。\n箭头函数总结对于一行代码的函数来说，箭头函数是相当方便的。它具体有三种种：\n\n不带花括号：(...args) =&gt; expression — 右侧是一个表达式：函数计算表达式并返回其结果。\n带花括号：(...args) =&gt; &#123; body &#125; — 花括号允许我们在函数中编写多个语句，但是我们需要显式地 return 来返回一些内容。\n不带参数括号 a=&gt;&#123;body&#125; 当传递的参数只有一个时可以省略括号\n\nday11-深入对象垃圾回收&#x27;use strict&#x27;;/*     垃圾回收    js中的内存管理是自动打开的 , 在js中垃圾回收是自动执行的    执行上下文    值得就是代码当前执行阶段 , 执行完成以后,js就需要对不在需要的变量进行一些列的回收操作    当程序结束不在需要用到内存的时候,就需要及时的释放内存,如果没有释放,就会造成内存泄漏    垃圾回收是一个定期性周期性执行的程序,他会自动去找不再需要使用的内存(变量)然后释放他的内存    常见的垃圾回收机制有两种, 引用计数 标记清除*///引用计数/*     规则当数据存储到变量中的时候,就为变量添加一个引用计数为1,当他的数据拷贝给别人重复建立引用的时候 引用计数就+1 ,较少一个引用 计数-1    当引用计数为0的时候就将这个变量进行回收*/// let obj1 = &#123;name : &#x27;xixi&#x27;&#125;; // 对象的引用计数 2 - 1  // 1// let obj2 = obj1 // 此时obj2引用了obj1的数据,此时的引用计数就增加1 ,变为 2  自身引用为1// // 接触obj2的引用 // obj2.sex = &#x27;男&#x27;// obj2 = null // obj2 没有引用对象// obj1 = null // obj1的引用设置为 0 //标记清除/*     当变量进入环境的时候, 给变量做上一个标记,标记为进入环境    当环境不存在的时候,就将变量标记为离开环境    内存定期去清空标记为离开环境的变量*/// function go()&#123;//     let a = 1 //标记为进入//     let b = &#x27;hello&#x27; //标记为进入//     return//表示函数执行完成  将内部的变量标记为离开环境// &#125;// go()// console.log(a)/*     可达性    js内存管理的一个概念    可达性值得就是可以以为某种方式访问到或者使用到这个内存中的值,我们就认为这个数据是可达的    当一个数据不可达的时候js就会自动进行垃圾回收    js中有个跟对象叫做全局对象 global*/let user = &#123;    name : &#x27;快乐的小树&#x27;&#125;// console.log(window) // global// console.log(window.user) // global// console.log(window.alert) // global// console.log(window.fnfn) // global//user不需要user = nulllet student = &#123;    name : &#x27;葡萄哥&#x27;&#125;//存储谁是管理员let admin = student//取消了student对象student = null// console.log(admin)//复杂情况的垃圾回收案例function marry(man,woman)&#123;    woman.husband = man //女方的老公是 man    man.wife = woman //男方的老婆是 woman    return&#123;        father : man,        mother : woman    &#125;&#125;//女let lin = &#123;    name : &#x27;林晨曦&#x27;&#125;//男let tang = &#123;    name : &#x27;汤子星&#x27;&#125;let family = marry(tang,lin)console.log(family)//汤子星去世了// delete family.father// delete family.mother.husbandlet san = &#123;    name : &#x27;三月尽&#x27;,    friend : tang&#125;//家庭删除family = nullconsole.log(family)console.log(san)\n\n对象的this&#x27;use strict&#x27;;let user = &#123;    name : &#x27;罗超&#x27;,    age : 18,    money : 200,    say : function()&#123;        //函数内内的 this , this表示当前函数的调用主体        // console.log(`my name is $&#123;user.name&#125;`)        console.log(this.name)        // function setSex()&#123;        //     this.sex = &#x27;nan&#x27;        // &#125;        // setSex()    &#125;,    buy : function()&#123;        this.money -= 20        console.log(`购买了一个奥特曼花了20块钱还剩下$&#123;this.money&#125;`)    &#125;,    //函数在对象内的简写方案    getAge()&#123;        console.log(this.age)    &#125;&#125;//编程的时候通常将事物抽象成一个对象, 分别用属性来描述他的特征,函数来标识事物的行为user.say()user.buy()user.getAge()//坑坑let getBuy = user.buy // 你把user下面的函数拷贝了一份过来// getBuy() //this =  undefined// let fn =  function()&#123;//     console.log(this) //undefined //     // console.log(&#x27;韩式执行&#x27;)// &#125;// fn()/*     1. this 是函数内的一个关键词 ,表示调用函数的主体对象    2. this 创建的时候是不确定的, 是在函数执行的过程中获取的    3. 没有明确的调用主体this指向undefined(严格模式下)*/\n\n箭头函数的this&#x27;use strict&#x27;;let user = &#123;    name : &#x27;于森&#x27;,    sayHi()&#123;        console.log(&#x27;你好&#x27;)        // let sayName = function()&#123;        //     console.log(this.name) //报错        // &#125;        //箭头函数是没有this,如果在箭头函数中使用了this那他他会去找外层环境中的this        // let sayName = ()=&gt;&#123;        //     console.log(this.name)//于森        // &#125;        //this 是一个值可以存储起来        let _this = this        let sayName = function()&#123;            console.log(_this.name) //报错        &#125;        sayName()    &#125;&#125;user.sayHi()\n\nsymbol作为属性名&#x27;use strict&#x27;;// const symbol = Symbol()// let obj = &#123;//     [symbol] : &#x27;123&#x27;// &#125;// console.log(obj[&#x27;Symbol()&#x27;])//undefined// console.log(obj.Symbol())//报错// console.log(obj[symbol])//报错// function creatObje()&#123;//     let obj = &#123;&#125;//     let obj2 = &#123;&#125;//     obj.name = &#x27;徐星&#x27;//     obj.age = 19//     //期望外界只能看到obj 不能修改obj//     let symbol = Symbol()//     obj2[symbol] = obj//     return obj2// &#125;// let obj = creatObje()\n\n对象总结对象是具有一些特殊特性的关联数据集合。\n它们存储属性（键值对），其中：\n\n属性的键必须是字符串或者 symbol（通常是字符串）。\n值可以是任何类型。\n\n我们可以用下面的方法访问属性：\n\n点符号: obj.property。\n方括号 obj[&quot;property&quot;]，方括号允许从变量中获取键，例如 obj[varWithKey]。\n\n其他操作：\n\n删除属性：delete obj.prop。\n检查是否存在给定键的属性：&quot;key&quot; in obj。\n遍历对象：for(let key in obj) 循环。\n\n我们在这一章学习的叫做“普通对象（plain object）”，或者就叫对象。\nJavaScript 中还有很多其他类型的对象：\n\nArray 用于存储有序数据集合，\nDate 用于存储时间日期，\nError 用于存储错误信息。\n……等等。\n\n它们有着各自特别的特性，我们将在后面学习到。有时候大家会说“Array 类型”或“Date 类型”，但其实它们并不是自身所属的类型，而是属于一个对象类型即 “object”。它们以不同的方式对 “object” 做了一些扩展。\nJavaScript 中的对象非常强大。这里我们只接触了其冰山一角。在后面的学习中，我们将频繁使用对象进行编程，并学习更多关于对象的知识。\nday12_数组与函数进阶构造函数&#x27;use strict&#x27;// let cat1 = &#123;//     name : &#x27;xuxing&#x27;,//     color : &#x27;red&#x27;,//     age : 2,//     like : &#x27;小鱼干&#x27;,//     speak : function()&#123;//         console.log(&#x27;喵喵喵&#x27;)//     &#125;// &#125;// let cat2 = &#123;//     name : &#x27;jiuwei&#x27;,//     color : &#x27;blue&#x27;,//     age : 3,//     like : &#x27;小鱼干&#x27;,//     speak : function()&#123;//         console.log(&#x27;喵喵喵&#x27;)//     &#125;// &#125;//工厂函数创建对象function createCat(name,color,age)&#123;    let obj = new Object()    obj.name = name;    obj.color = color    obj.age = age    obj.like = &#x27;小鱼干&#x27;;    obj.speak = function()&#123;        console.log(&#x27;喵喵喵&#x27;)    &#125;    return obj&#125;let  xuxing =  createCat(&#x27;xuxing&#x27;,&#x27;red&#x27;,2)let  jiuwei =  createCat(&#x27;jiuwei&#x27;,&#x27;blue&#x27;,3)/*     new 操作符的作用    1. 用于调用函数创建一个新的对象    构造函数约定函数的首字母必须大写*/   //构造函数  function CreateCat(name,age,color)&#123;    // 用于检测是否是通过new 调用的该函数    if(new.target === undefined)&#123;        //是通过普通函数调用        return createCat(name,color,age)    &#125;    // this 就指向new 创建出来的对象    // let this = &#123;&#125;    this.name = name;    this.color = color    this.age = age    this.like = &#x27;小鱼干&#x27;;    this.speak = function()&#123;        console.log(&#x27;喵喵喵&#x27;)    &#125;    //构造函数内的return 默认是返回this,也可以手动指定返回一个对象    // return this    /*         new 操作符调用函数的时候会执行3个步骤        1. 在函数内创建一个空对象并且分配给this        2. 可以直接通过修改this的内容为对象添加新的属性或者方法        3. 返回this    */&#125;let wuxian = CreateCat(&#x27;wuxian&#x27;,2,&#x27;pink&#x27;)//实例化对象 new操作符创建的对象称为实例化对象let yaya = new CreateCat(&#x27;yaya&#x27;,1,&#x27;blue&#x27;)let goudan = new CreateCat(&#x27;goudan&#x27;,1,&#x27;blue&#x27;)goudan.goujiao = function()&#123;    console.log(&#x27;汪汪汪&#x27;)&#125;\n\n可选链操作符&#x27;use strict&#x27;;let user = &#123;    address : &#123;        street : &#123;            name : &#x27;123&#x27;        &#125;    &#125;&#125;// console.log(user.address) // undefined// console.log(user.address.street) // 报错// console.log(user.like.animal) //报错//解决方案// let street = user.address ? user.address.street : undefined;//逻辑运算let street = user.address &amp;&amp; user.address.street &amp;&amp; user.address.street.name    //可选链 vlaue?.prop/*     - 如果 vlaue存在则结果与value.prop相同    - 如果value 不存在为 undefined或者null时 就直接返回 undefined    可选链是一种安全访问对象属性的最好方法*/let  stet =  user?.address?.street?.name//变体写法//短路操作// let abc = null// let x = 1// abc?.sayHi(x++)//安全的调用函数let admin = &#123;    setAdmin()&#123;        console.log(&#x27;设置成功&#x27;)    &#125;&#125;let uu = &#123;&#125;uu?.setAdmin?.()admin?.setAdmin()//访问属性let uu2 = &#123;    name : &#x27;xuxing&#x27;,    address : &#123;        street:&#x27;123&#x27;    &#125;&#125;let kye = &#x27;age&#x27;console.log(uu2?.[kye])//删除属性delete uu2?.address?.streetconsole.log(typeof uu2)console.log(String(uu2)) //[object Object]console.log(Number(uu2)) //[object Object]console.log(Boolean(uu2)) //[object Object]\n\n数组&#x27;use strict&#x27;;/*     数组    当我们需要一些有序的集合的时候就可以用数组来创建    数组是属于object类型的其中一个数据结构 Array    数组存储的值没有属性名只需要存储单个值就可以了*///创建方式 构造函数let arr = new Array(&#x27;luyao&#x27;,&#x27;yaya&#x27;,&#x27;xiazhi&#x27;)//字面量创建let arr2 = [&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;]//取值  arr[index] 表示取arr数组中的第几个数据, 数据是从0开始计算let name1 = arr[0] //luyaolet name2 = arr[1] //yaya//修改值和新增值arr2[0] = &#x27;一&#x27;// arr2[5] = &#x27;五&#x27;//length 的属性 用于获取数组的长度 , 长度是从1开始计数console.log(arr2.length)arr2[arr2.length] = &#x27;六&#x27;arr2[arr2.length] = &#123;    name : &#x27;xuxing&#x27;,    age : 123&#125;console.log(arr2[4].age)//下标的长度默认是根据创建的值自动计算生成,当然也可以手动来设置长度//以下的方法都是一些不好的做法,不推荐这样使用arr2.length = 200arr2[999] = &#x27;九九九&#x27;arr2.age = &#x27;18&#x27;//length修改值的应用场景 length 的值是会自动更新数据let fruits = [&#x27;apple&#x27;,&#x27;banana&#x27;,&#x27;orange&#x27;]//length 小于数组内的数据, 他就会自动去更新数据把多余的部分进行删除fruits.length = fruits.length - 1//清空数组// fruits = []// fruits.length = 0// fruits = null\n\n数组遍历&#x27;use strict&#x27;;let arr = [&#x27;一&#x27;,&#x27;二&#x27;,&#x27;三&#x27;,&#x27;四&#x27;,&#x27;五&#x27;]//for of 遍历数组 这个遍历方法只能用于数组for (const item of arr) &#123;    console.log(item)&#125;//for in 进行遍历for (const key in arr) &#123;  console.log(arr[key])&#125;//for 循环遍历for (let index = 0; index &lt; arr.length; index++) &#123;    console.log(arr[index])&#125;//数据类型转换console.log(String(arr)) //一,二,三,四,五console.log(Number(arr)) //NaNconsole.log(Number([&#x27;2&#x27;])) //1 数组中只有一个数值或者空值的时候是可以直接转换为数值的console.log(Boolean([&#x27;123123&#x27;,&#x27;123213&#x27;]))//tureconsole.log([] == []) //falseconsole.log(0 == []) //true\n\n复习&#x27;use strict&#x27;; /*     1. this 是函数内的一个关键词 ,表示调用函数的主体对象    2. this 创建的时候是不确定的, 是在函数执行的过程中获取的    3. 没有明确的调用主体this指向undefined(严格模式下)*/var obj = &#123;    name : &#x27;obj&#x27;,    fn : function()&#123;        console.log(this === obj)    &#125;,    bb : &#123;        name : &#x27;bb&#x27;,        cc : &#123;            name : &#x27;cc&#x27;,            dd : function()&#123;                console.log(this)            &#125;        &#125;    &#125;&#125;obj.ff = obj.bb.cc.ddlet nice = obj.bb.cc.ddnice()//undefinedobj.ff() // obj 函数的this是调用的时候确定obj.bb.cc.dd() // ccfunction aa()&#123;    console.log(this)&#125;//没有明确的调用主体就是window调用, this指向window(非严格模式, 如果在严格模式下指向undefined)aa()console.log(aa == window.aa) //tureobj.fn()//函数的调用主体就是函数执行前的那个对象window.obj.fn()\n\nday13-函数进阶感受递归&#x27;use strict&#x27;;/*     递归函数 就是函数自身调用自身*///pow(x,n) 计算x的n次方//普通函数function pow(x,n)&#123;    let result = 1    for (let i = 0; i &lt; n; i++) &#123;        result *= x    &#125;    console.log(result)&#125;pow(2,3)//递归函数function pow2(x,n)&#123;    //递归一定要有个终点, 每次递归都会逐渐的接近终点    if(n == 1)&#123;        return x    &#125;else&#123;        return x * pow2(x,n-1)    &#125;&#125;console.log(pow2(2,3)) // 2*2*2  2 * pwo(2,2)  2 * pow2(x,1) = x/* 1. pow(2,3) = 2 * pow2(2,2) = 82. pow2(2,2) = 2 * pow2(2,1)  = 43. pow2(2,1) = 2递归调用次数我们称为递归的深度, 深度是有限制的,不能大于10000*/\n\n执行上下文&#x27;use strict&#x27;; /*      执行上下文 是js代码执行前, js引擎需要做的准备工作 , 创建执行上下文     js的上下文分为3了类     - 全局执行上下文     - 函数上下文     - eval 上下文 */ // console.log(eval(&#x27;1*3+6&#x27;)) //全局执行上下文 , 就是所谓的全局对象 // console.log(window) // function fu()&#123; // &#125; // var a = 1 //函数执行上下文 // let a = 1 // function fn()&#123; //     let a = 2 //     console.log(a) // &#125; // fn() //执行栈  /*      执行上下文栈也叫执行栈,执行栈用于存储函数执行期间的上下文     栈是一个数据结构 具备 LIFO 先进后出 的特性     js首次执行的时候就会创建一个执行栈, 并且最先把全局执行上下文压栈,之后如果有新的函数调用,就会把函数的执行上下文压入栈中     当函数内嵌套函数调用的时候     - 当前函数暂停执行     - 与他关联的上下文会被执行栈中保存起来(压栈)     - 执行嵌套函数     - 嵌套函数结束后,在从堆栈中恢复之前的上下文, 并从停止的位置恢复函数的执行(出栈)     创建上下文做的事情     1. 确定this     2. 词法环境组件         1. 就是一个包含标量标识符的映射结构         2. 全局的词法环境组件 : 建立词法环境的引用 null         3. 函数词法环境组件 建立外部词法环境的引用关系     3. 变量环境组件         规定变量生效的范围,也具备记录外部变量的引入 */ let a = 1 function f1()&#123;     f2()     console.log(1,a) &#125; function f2()&#123;     f3()     console.log(2) &#125; function f3()&#123;     console.log(3) &#125; f1() //  /*      f1  = f2 = 1     f2 = f3 = 2     f3 = 3 */\n\n继续研究递归&#x27;use strict&#x27;;function nice(x)&#123;    if(x === 1)return 1;    console.log(x) // 654312  进栈    nice(x-1)    console.log(x) // 123456  出栈&#125;nice(4)/* 进栈nice(4) == console.log(4),nice(3)nice(3) == console.log(3),nice(2)nice(2) =  console.log(2),nice(1)nice(1) =  return 1出栈234*/\n\n作用域&#x27;use strict&#x27;;/*     作用域就是变量生效的范围    js每次执行或者&#123;&#125;的创建都会被称为一个词法环境的组件, 内部隐藏的映射关联对象就会产生    词法环境由两个部分组成    - 环境记录  存储所有局部变量作为其属性 包括this    - 外部词法环境的引用  建立与外部词法环境的关联    js中有三种作用域    - 全局作用域    - 函数作用域    - 块级作用域*///块级作用域 如果在代码块 &#123;&#125; 内部创建了变量,name这个变量所在的花括号内就是块级作用域&#123;    //块级作用域    let message = &#x27;hello&#x27; //只在花括号内能访问     // var hello = &#x27;123&#x27;&#125;// console.log(hello)//if语句if(true)&#123;    let message = &#x27;hello&#x27; //只在花括号内能访问 &#125;for (let i = 0; i &lt; 2; i++) &#123;    let message = &#x27;hello&#x27; //只在花括号内能访问 &#125;//函数作用域 函数内部的变量就是函数作用域 ,函数内部的变量只在函数内部能访问到, 函数的作用域是创建的时候就已经确定的let name = &#x27;global&#x27;function fn()&#123;    let name = &#x27;infn&#x27; // out就是一个函数作用域    console.log(name)&#125;fn()/* 作用域存在的机制1. 使用变量    当访问变量的时候有限查看自身作用域有没有,有就用,没有就向外查找    如果最顶层都没有就报错 xxx is not defined2. 赋值变量    跟访问同理*/\n\n作用域练习&#x27;use strict&#x27;;// let num = 22// function fn1()&#123;//     let num = 666//     console.log(num)//666// &#125;// fn1()// let num = 22// function fn1()&#123;//     num = 666// &#125;// console.log(num)//22// fn1()// let num = 22// function fn1()&#123;//     let num = 666// &#125;// fn1()// console.log(num)//22// let num = 22// function fn1()&#123;//     console.log(num)////     let num = 666// &#125;// fn1()// let num = 22// function fn1()&#123;//     let num = 666//     fn2()//     console.log(num) // 666// &#125;// function fn2()&#123;//     num = 567// &#125;   // fn1()// console.log(num) // 567\n\n作用链接&#x27;use strict&#x27;;/*     只有函数会产生作用域结构, 每一个函数的创建都是一个作用域, 当作用域嵌套作用域的时候, 组成的结构结构就叫作用域链    变量的访问规则,自身作用域没有就会沿着作用域链向上查找上一个作用域中有没有*/let xxx = &#x27;123&#x27;function fn()&#123;    let width = &#x27;123&#x27;    function fn2()&#123;        xxx = 789    &#125;    fn2()&#125;fn()console.log(xxx)\n\nday14-函数补充递归练习&#x27;use strict&#x27;;/*     深拷贝练习    深拷贝就是 复制一个引用类型,并且切断与原有变量的引用关系*/let user = &#123;    name : &#x27;张宏杨&#x27;,    age : 21,    say : function()&#123;console.log(&#x27;hello&#x27;)&#125;,    friend : [&#x27;三月尽&#x27;,&#x27;葡萄哥&#x27;,&#x27;林晨曦&#x27;],    like : &#123;        game : [&#x27;lol&#x27;,&#x27;cf&#x27;],        eat : true    &#125;&#125;let coypUsr = Object.assign(&#123;&#125;,user)//浅拷贝console.log(coypUsr.like.game === user.like.game ) // true// let depUser = deepClone(user)//深拷贝函数function deepClone(obj)&#123;    //返回一个拷贝后的结果    let result; //&#123;name,age ,say,fired:[xxx,xxx],like:&#123;game:[xxx],ett&#125;&#125;    //判断数据类型    if(typeof obj === &#x27;object&#x27;)&#123;        //说明是数组或者对象        result = Array.isArray(obj)?[]:&#123;&#125; //判断是不是一个数组        //是引用类型       for (const key in obj) &#123;         result[key] = deepClone(obj[key])       &#125;    &#125;else&#123;        //不是引用类型        result = obj    &#125;    return result&#125;let oo = &#123;    name : &#x27;xuxing&#x27;,    like : &#123;        eat : true,        fd : &#123;            name : &#x27;123&#x27;        &#125;    &#125;&#125;console.log(deepClone(oo).like === oo.like)console.log(deepClone(user).like.game === user.like.age)\n\n闭包&#x27;use strict&#x27;;/*     执行上下文有一个生命周期,     创建阶段 == 进行预编译 ,预解析    执行阶段 == 根据上下文顺序执行代码    回收阶段 == 垃圾回收*///复杂情况function f()&#123;    let value = 1     return function inner()&#123; //闭包函数        console.log(++value)//value访问了外层函数的变量,导致外侧函数变量被保留了下来    &#125;&#125;/*     内部函数使用了外部作用域的变量,导致变量没有被垃圾回收这种情况就称闭包*/// f()() // 2// f()() // 2// f()() // 2// let ff = f() //得到的是f的返回函数inner  &#123;value:1 , inner()&#123;&#125;&#125;// ff() // 2// ff() // 3// ff() // 4//购买东西的函数function xuxingBuy()&#123;    let money = 100 //总金额    return function buy(name,pic)&#123;        money -= pic //更新总金额        console.log(`徐星购买了$&#123;name&#125;,花费了$&#123;pic&#125;,还剩下$&#123;money&#125;`)    &#125;&#125;//购买东西let buyXuxing = xuxingBuy()// money = 100buyXuxing(&#x27;美女写真&#x27;,60) //40buyXuxing(&#x27;奥特曼&#x27;,20) //20function qiXiBuy()&#123;    let money = 100 //总金额    return function buy(name,pic)&#123;        money -= pic //更新总金额        console.log(`七喜购买了$&#123;name&#125;,花费了$&#123;pic&#125;,还剩下$&#123;money&#125;`)    &#125;&#125;let buyQixi =  qiXiBuy()buyQixi(&#x27;牙刷&#x27;,5)buyQixi(&#x27;牙膏&#x27;,15)\n\n参数rest参数与spread&#x27;use strict&#x27;;/*     rest 参数 和 spread 语法*/// function max()&#123;//     let maxNum = -Number.MAX_SAFE_INTEGER//     console.log(arguments) //存储已经接收到的所有参数    //     for (const num of arguments) &#123;//         if(num &gt; maxNum)&#123;//             maxNum = num//         &#125;//     &#125;//     return maxNum// &#125;// console.log(max(5,6,567,567,87))// function sum(name,sex)&#123;//     let sum = 0//     console.log(arguments) //存储已经接收到的所有参数    //     for (let i = 1; i &lt; arguments.length; i++) &#123;//         sum += arguments[i]//     &#125;//     console.log(sum)//     return sum// &#125;// //求和函数, 第一个参数用户的名称, 后续参数是用户的工资, 要求用户的所有工资之和// sum(&#x27;程力&#x27;,100,200,500,1000,2000)// // sum(&#x27;程力&#x27;,&#x27;男&#x27;,100,200,500,1000,2000)/*     ...rest 用作参数的时候表示剩余参数 , 会将参数剩余的部分整合成一个数组*/function sum(name,sex,...rest)&#123; //接受name参数和sex参数剩余的参数统一 为 rest接受    let sum = 0    console.log(name,sex,rest)       for (const iterator of rest) &#123;        sum += iterator    &#125;    console.log(name,sum)    return sum&#125;//求和函数, 第一个参数用户的名称, 后续参数是用户的工资, 要求用户的所有工资之和// sum(&#x27;程力&#x27;,&#x27;男&#x27;,100,200,500,1000,2000)// function fn(...rest)&#123;//     console.log(rest)// &#125;// fn(1,23,12,31,2312,3)/*     arguments 获取到的是所有参数的集合 ,不可以手动规定范围    ...rest 获取的是剩余参数集合, 可以手动规定从什么位置开始获取剩余参数    注意    ...rest 后面不允许再出现形参*/// function fnfn(...rest,age)&#123;&#125; //错误写法/*  spread 语法(扩展运算)*/function max()&#123;    let maxNum = -Number.MAX_SAFE_INTEGER        if(typeof arguments[0] === &#x27;object&#x27;)&#123;        for (const num of arguments[0]) &#123;            if(num &gt; maxNum)&#123;                maxNum = num            &#125;        &#125;    &#125;else&#123;        for (const num of arguments) &#123;            if(num &gt; maxNum)&#123;                maxNum = num            &#125;        &#125;    &#125;    console.log(maxNum)    return maxNum&#125;function max2()&#123;    let maxNum = -Number.MAX_SAFE_INTEGER    for (const num of arguments) &#123;        if(num &gt; maxNum)&#123;            maxNum = num        &#125;    &#125;    console.log(maxNum)    return maxNum&#125;//传入的参数是数组let age = [1,23234,34,53,45,243,52,436,456,34,6554,76,6587]//找到age中最大的年龄max(age)// max(1,23,1,23)/*     扩展运算    通过 ...arr的形式将数组的每一项单词拆解出来*/console.log(...age) //1 23234 34 53 45 243 52 436 456 34 6554 76 6587let age2 = [32432,345,34,6456,9999999]max2(...age)//23234max2(...age,...age2,82379847298437928374)//9999999//花样玩法 合并数组let arr1 = [1,2,3]let arr2 = [4,5,6]// for (const value of arr1) &#123;//     arr2[arr2.length] = value// &#125;let arr3 = [...arr1,...arr2,...&#x27;axadsfasdf&#x27;] // [1, 2, 3, 4, 5, 6]\n\nvar创建变量&#x27;use strict&#x27;;   /*        var跟let 类似都是创建变量的方式   */   //1. var 没有块级作用域   &#123;       var messge = &#x27;123&#x27;   &#125;   console.log(messge)   for (var index = 0; index &lt; 5; index++) &#123;       // console.log(index)   &#125;   // console.log(index)//5   // let ali =  document.querySelectorAll(&#x27;li&#x27;)   // var i = 0//5   // for (let i = 0; i &lt; ali.length; i++) &#123;   //     ali[i].onclick = function()&#123;   //         console.log(i)   //         ali[i].style.background = &#x27;red&#x27;   //     &#125;   // &#125;   //2. 变量可以重复声明   // var index = 1   // var index = 2   //3. 变量可以声明前使用   // console.log(age)   // var age = 19   //4. 变量存储的位置是window   // var age = 19   // console.log(window.age)   // console.log(window.age = 20)   // let sex = &#x27;男&#x27; // let存储的位置是 script标签内部   // console.log(window.sex)   //函数声明提升   /*        函数声明会出现作用域提升,会将函数声明提升到作用域的最顶层   */   fn()   function fn()&#123;       console.log(&#x27;fnnfnfnf&#x27;)   &#125;\n\nday15-解答课case01&#x27;use strict&#x27;;// function fn()&#123;    // &#125;// console.log(typeof fn) //function// console.log(typeof null) //object// console.log(new fn()) //&#123;&#125;/*     循环使用来批量多次的执行某一些代码或者是行为    循环还可以用来获取对象或者数组中的每个值(遍历)    while(表达式)&#123; 代码块 &#125;    do&#123;代码块&#125; while(表达式)    for(初始化变量;循环终止条件;更新初始值)&#123;代码块&#125;    当表达式为真的时候执行代码块的内容    forin 遍历对象的循环    forof 遍历数组的循环*/let obj = &#123;    name : &#x27;xuxing&#x27;,    age : 19,    sex : &#x27;男&#x27;&#125;let arr = [&#x27;123&#x27;,&#x27;456&#x27;,&#x27;asfd&#x27;]// console.log(obj.name)// console.log(obj.age)// console.log(obj.sex)for (const key in obj) &#123;    console.log(key,obj[key])&#125;for (const key in arr) &#123;    console.log(key,arr[key])&#125;for (const value of arr) &#123;    console.log(value)&#125;let index = 0while (index != arr.length) &#123;    console.log(arr[index])    index++&#125;let str = &#x27;按时发大水发打算复读&#x27;for (const valu of str) &#123;    console.log(valu)&#125;/*     深拷贝和浅拷贝    浅拷贝只会拷贝对象中的基础数据类型,引用类型的数据拷贝会建立引用关系    深拷贝将对象中的所有类型都进行拷贝,并且切断引用关系*/// let obj1 = &#123;name:1&#125;// let obj2 = obj1// for (let i = 0; i &lt; 5; i++) &#123; // 5//     for (let k = 0; k &lt; 5; k++) &#123; // 5 5*5  25//       //6  5*5*6//     &#125;// &#125;/*     var 的特征    1. 不会创建快级作用域    2. 会变量声明提升    3. 变量可以重复命名    4. 变量挂在的位置是window    let    1. 会创建快级作用域    2. 不会变量提升    3. 变量不能重复命名    4. 变量存储的位置在全局global标签内部*/    let  message = &#x27;123&#x27;    /*         作用域        本质就是规定变量生效的范围        作用域是一个静态的存在,函数在创建的时候作用域就已经创建好了        作用域有3        全局作用域        函数作用域        快级作用域        建立当前作用域与外部作用域的关联        作用域可能会有多层的嵌套, 多层嵌套称为作用域链    */    let age = 123    function fn1()&#123;        fn2()        let age = 19        console.log(age) // 19    &#125;    function fn2()&#123;        age = 456        console.log(age) // 456    &#125;    fn1()\n\ncase02&#x27;use strict&#x27;;/*     预解析的原理    预解析是代码执行的顺序    1. 语法分析 ,快速的检查你的js代码,有没有语法错误,或者单词拼写错误    2. js预解析, 在这个阶段js 会去创建A0对象和GO对象    3. 解释性执行代码,代码逐条执行    js预解析(代码执行前做的一件事)    1. 创建AO对象 指的是活性对象,也叫作执行上下文,也可以说是创建作用域,AO表示创建函数执行的上下文和作用域    2. 找函数形参和函数内部的变量声明,将形参和变量声明作为AO对象的属性名,并且赋值为undefined    3. 将实参形参进行统一,实参赋值给形参    4. 在函数体内找函数声明,值赋值给函数体*/// for (let index = 0; index &lt; 1000000; index++) &#123;//     console.log(index)// &#125;// let message = &#x27;123&#x27;// let message = &#x27;123&#x27;function nice()&#123;    let good = 20    console.log(good)&#125;// nice()/* GO对象 全局执行上下文GO = &#123;&#125;2. 找参数和变量GO = &#123;    nice = undefined&#125;3. 统一参数GO = &#123;    nice = function&#125;4. 变量声明5. 执行上下文代码逐条执行1. 创建AO对象AO = &#123;&#125;2/ 找函数的形参和内部变量赋值为undefinedAO = &#123;    good : undefined&#125;3. 实参形参统一AO = &#123;    good : 20&#125;4. 在函数体内找函数声明5. 执行上下文代码逐条执行*/function fn(a)&#123;    console.log(a) //ƒ a()&#123;&#125;    a = 123;    console.log(a)//123    function a()&#123;&#125;     console.log(a) // 123    // a()    let b = function b()&#123;&#125;&#125;fn(1)/*     1. 创建AO对象    AO = &#123;&#125;    2. 找函数形参和内部的变量声明赋值undefined    AO = &#123;        a : undefined,        b : undefined    &#125;    3. 实参形参统一    AO = &#123;        a : 1,        b : undefined    &#125;    4. 函数内部的函数声明和赋值    AO = &#123;        a : function,        b : function b()&#123;&#125;    &#125;    5. 代码执行, 预解析就是为变量设置初始值    a = 123    console.log(a) // func    a = 123;    console.log(a)//123    function a()&#123;&#125;     console.log(a) // 123*/\n\ncase03-自执行函数IIFE&#x27;use strict&#x27;;    /*     IIFE 叫自执行函数 也就是自己会执行的函数,不需要额外调用, 或者说是自己创建的时候就已经调用的函数*/// function fn()&#123;//     let aa = 1//     console.log(aa)// &#125;// fn()//自执行函数(function()&#123;    var aa = 1    console.log(aa)&#125;)();let cc =  (function()&#123;    var aa = 2    console.log(aa)    return function()&#123;        aa++        console.log(aa)    &#125;&#125;)();// cc()// cc()//iife函数的其他写法(function()&#123;    console.log(&#x27;aaa&#x27;)&#125;)();(function()&#123;    console.log(&#x27;bbb&#x27;)&#125;());!function()&#123;    console.log(&#x27;ccc&#x27;)&#125;();+function()&#123;    console.log(&#x27;ddd&#x27;)&#125;();-function()&#123;    console.log(&#x27;eee&#x27;)&#125;();\n\ncase04-函数的NFE&#x27;use strict&#x27;;/*     函数本身就是一个对象*/sayHi.age = 1function sayHi()&#123;    console.log(&#x27;hi&#x27;,sayHi.age++)&#125;   //name 属性表示函数的名称console.log(sayHi.name)//sayHisayHi()sayHi()sayHi()console.log(sayHi.age)let ss = &#123;    sayHi ()&#123;        console.log(&#x27;hi&#x27;)    &#125;,    sayBye (a,b,c,...rest)&#123;        console.log(&#x27;bye&#x27;)    &#125;&#125;console.log(ss.sayBye.length)//3  函数一共接受多少个参数\n\ncase05&#x27;use strict&#x27;;//阶乘递归  fn(5) = 5*3*2*1// function fn(x)&#123;//     //递归的出口//     if(x === 1)return 1;//     return x * fn(x-1)// &#125;// console.log(fn(5))function showYes() &#123;        for (let index = 0; index &lt; 5; index++) &#123;            console.log(&#x27;我吃了我吃了&#x27;)            console.log(&#x27;我吃了我吃了&#x27;)        &#125;    &#125;    function showYes2() &#123;        for (let index = 0; index &lt; 5; index++) &#123;            console.log(&#x27;睡醒了睡醒了&#x27;)            console.log(&#x27;睡醒了睡醒了&#x27;)        &#125;    &#125;    function showNo2()&#123;        for (let index = 0; index &lt; 5; index++) &#123;            console.log(&#x27;还没睡醒&#x27;)            console.log(&#x27;还没睡醒&#x27;)        &#125;    &#125;    function showNo() &#123;        for (let index = 0; index &lt; 5; index++) &#123;            console.log(&#x27;还没吃饱还没吃饱&#x27;)            console.log(&#x27;还没吃饱还没吃饱&#x27;)        &#125;    &#125;    function ask(question,yes,no) &#123;        if (confirm(question)) &#123;            //选择正确            yes()        &#125; else &#123;            //选择错误            no()        &#125;    &#125;    // ask(&#x27;你吃了吗&#x27;,showYes,showNo)    ask(&#x27;你睡着了吗&#x27;,showYes2,showNo2)\n\nday16-api常用api-数值&#x27;use strict&#x27;;/*     api 就是js 向开发人员提供的一些列处理数据类型的方法(function)    学习api的时候需要关注三个信息    - api 的作用    - 是否会改变原数据    - api 的返回值是什么*/let num = 1_000_00_0 //_可以用在数值让数值可读性更强不影响数值的具体指//num.toFixed(index) 作用将数值小数部分超出index位的部分删除,不会改变元数据let num1 = 123123.345354653657// console.log(num1.toFixed(2)) //123123.35//自己封装function tofixed(num,index)&#123;    let str = &#x27;&#x27;    let i = 0    let numStr = String(num)    //检索下标    function indexOf(str,ta)&#123;        for (let k = 0; k &lt; str.length; k++) &#123;            if(str[k] === ta)&#123;                return k            &#125;        &#125;        return -1    &#125;    //获取到点后面的index位    let max = indexOf(numStr,&#x27;.&#x27;)+index       for (let k = 0; k &lt;= max; k++) &#123;       str += numStr[k]    &#125;    console.log(str)&#125;// tofixed(num1,2)//num.toString(base) 方法将数值转换为字符串 , base 表示进制,以某种进制进行转换为字符串 , 返回值是字符串// console.log(num.toString(2))//11110100001001000000// console.log(num.toString(10))//1000000// console.log(num.toString(16))//f4240//Number.parseInt(str) 方法会将str取整数,抹去小数部分,返回值是一个数值 , 从第一个数值开始转换转换到第一个不是数值的字符串就停止// console.log(Number.parseInt(123.123))// console.log(Number.parseInt(&#x27;123.456&#x27;))// console.log(Number.parseInt(&#x27;adsf&#x27;)) //nan// console.log(Number.parseInt(&#x27;123a&#x27;)) //123// console.log(Number.parseInt(&#x27;123$&#x27;)) //123//Number.parseFloat(str) 保留小数 逐个转换,保留第一个.以后后续再出现其他的非数值字符串就停止转换console.log(parseFloat(&#x27;123.456&#x27;)) //123.456// console.log(Number.parseFloat(&#x27;123.456a1&#x27;)) //123.456// console.log(Number.parseFloat(&#x27;123.45.6a1&#x27;)) //123.456// console.log(Number.parseFloat(&#x27;123a456a1&#x27;)) //123//isFinte 和 isNaN 专门用于检测值是不是一个finte或者是一个nan// console.log(isNaN(123))//false// console.log(isNaN(&#x27;a1sfd&#x27;))//true// console.log(isNaN(NaN))//true// console.log(isFinite(123.123))//true// console.log(isFinite(&#x27;1asdfa&#x27;))//false// console.log(isFinite(39489083495435)) //true// console.log(isFinite(true)) // treu// console.log(isFinite(Infinity)) // false// let  arr = [&#x27;123&#x27;,&#x27;465&#x27;,&#x27;78.9&#x27;,NaN,123,Infinity]// let sum = 0// for (let i = 0; i &lt; arr.length; i++) &#123;//     if(isFinite(arr[i]))&#123;//         sum += Number(arr[i])//     &#125;   // &#125;\n\n常用api-字符串&#x27;use strict&#x27;; let str = &#x27;asdfasfdAAAA&#x27; //字符串长度//  console.log(str.length) //字符串长度//  console.log(str[1]) //访问字符串的某个值//str.charAt(index) 访问字符串中的第几个字符串// console.log(str.charAt(1)) //s//str.charCodeAt(index) 返回字符串的第index字符的 unicode 编码// console.log(str.charCodeAt(0)) //97// console.log(str.charCodeAt(1)) //115let name = &#x27;徐星&#x27;// console.log(name.charCodeAt(1)) //26143//String.fromCharCode(unicode) 将unicode准换为字符串// console.log(String.fromCharCode(26143)) // s//字符串大小写之间的转换  toLowerCase()字符串全转小写 toUpperCase() 字符串全转大写// console.log(str.toUpperCase())// console.log(str.toLowerCase())//substring(indexStart,[,indexEnd]) 截取字符串 indexStart开始下标indexEnd结束的下标 , 范围包含起始不包含结束let stt = &#x27;徐星真是太可爱了&#x27;// console.log(stt.substring(5,7))//可爱// console.log(stt.substring(0,2))//徐星// console.log(stt.substring(3)) //是太可爱了// console.log(stt.substring(5,3)) //是太// console.log(stt.substring(3,5)) //是太// console.log(stt.substring(-3,5)) //徐星真是太// console.log(stt.substring(-5,3)) //徐星真/*     只有start的时候表示从开始截取到结束    参数内部会进行一个调整,如果参数第一个大于第二个,在内部会将参数统一为第一个小于第二个    如果传入的值小于0 或者是NaN会被当做0处理*///substr(startIndex,[,length]) 从 startIndex 下标开始,截取 length 位// console.log(stt.substr(0,2)) //徐星// console.log(stt.substr(5,3)) //可爱了// console.log(stt.substr(2)) //真是太可爱了//slice(startIndex,[,endIndex]) 跟 substing 参数一模一样//参数如果是负数值 ,表示 str.length-Index// let str2 = &#x27;今天真的太开心了&#x27; // 8 - 2 = 6  // 2// console.log(str2.slice(2,4)) // 真// console.log(str2.slice(-3,6)) // 开// split(string,[,lenght]) 将字符串以为string字符作为切割,切割为一个数组 , length 转换后的数组保留几个let str3 = &#x27;张三|男|16|180&#x27;// console.log(str3.split(&#x27;|&#x27;,2))//[&#x27;张三&#x27;, &#x27;男&#x27;, &#x27;16&#x27;, &#x27;180&#x27;]// console.log(str3.split(&#x27;|&#x27;))//[&#x27;张三&#x27;, &#x27;男&#x27;, &#x27;16&#x27;, &#x27;180&#x27;]// console.log(str3.split())//[&#x27;张三|男|16|180&#x27;]// console.log(str3.split(&#x27;&#x27;))//[&#x27;张&#x27;, &#x27;三&#x27;, &#x27;|&#x27;, &#x27;男&#x27;, &#x27;|&#x27;, &#x27;1&#x27;, &#x27;6&#x27;, &#x27;|&#x27;, &#x27;1&#x27;, &#x27;8&#x27;, &#x27;0&#x27;]//trim() 清除字符串左右两边的空格// let ueerName = prompt(&#x27;你的网名是什么&#x27;,&#x27;张三&#x27;)// if(ueerName.trim() === &#x27;张三&#x27;)&#123;//     console.log(&#x27;欢迎张三进入直播间&#x27;)// &#125;//检索字符串的方法/*     str.indexOf(searchEle,[,fromeIndex])    - searchEle 表示需要检索的字符串或者元素    - fromeIndex 从第几个开始检索    返回值找到第一个满足的就返回他的下标位置    如果找不到返回 -1     str.lastIndexOf(searchEle,[,fromeIndex]) 跟indexof一样不过他是反着回去找*/let str5 = &#x27;你好我叫徐星,我今年8岁&#x27;// console.log(str5.indexOf(&#x27;我&#x27;)) //2 默认从下标0开始找,找到第一个满足的就返回他的下标位置// console.log(str5.indexOf(&#x27;我&#x27;,3)) //7// console.log(str5.lastIndexOf(&#x27;我&#x27;)) //7/*     str.includes(ele) 检索字符串中是否存在ele元素     str.startsWith(ele) 检索字符串中的开头字符换是不是ele    str.endsWith(ele) 检索字符串中的结尾字符换是不是ele    返回值为布尔值 有就返回true*/   // console.log(str5.includes(&#x27;徐星&#x27;)) //true// console.log(str5.includes(&#x27;许星&#x27;)) //false// console.log(str5.includes(&#x27;许星&#x27;)) //falselet urlStr = &#x27;https://www.baidu.com&#x27;// console.log(urlStr.startsWith(&#x27;https&#x27;)) // true// console.log(urlStr.startsWith(&#x27;http&#x27;)) // true// console.log(urlStr.endsWith(&#x27;com&#x27;)) // true// console.log(urlStr.endsWith(&#x27;cn&#x27;)) // false// console.log(urlStr.endsWith(&#x27;png&#x27;)) // false//str.repeat(index) 将str重复拼接index次 ,返回一个新的字符串// console.log(str5.repeat(10))/*     replace(seStr,newstr) || replaceAll    seStr 需要替换的值    newstr 替换后的值    作用 将 seStr 选中的字符串替换为 newstr 字符串    返回值是一个新的字符串    replace只能替换满足条件的第一个 , replaceAll替换满足条件的所有*/let str6 = &#x27;徐星真可爱,超级可爱&#x27;console.log(str6.replace(&#x27;可爱&#x27;,&#x27;丑陋&#x27;)) //只会替换第一个满足条件的选项//全部替换while (str6.includes(&#x27;可爱&#x27;)) &#123;    str6 = str6.replace(&#x27;可爱&#x27;,&#x27;丑陋&#x27;)   &#125;//全部替换console.log(str6.replaceAll(&#x27;丑陋&#x27;,&#x27;美丽&#x27;)) \n\n常用api-数组类型&#x27;use strict&#x27;;//Array.isArray(ele) 用于判断ele是不是一个数组,如果是返回true// console.log(Array.isArray(&#x27;123&#x27;))// fase// console.log(Array.isArray([]))// fase//Array.from(iterEle) 将iterEle数据转换为一个数组 // console.log(Array.from(&#x27;123&#x27;)) //[&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;]// function fn()&#123;//     console.log(arguments)//     console.log(Array.from(arguments))// [&#x27;123&#x27;, 123, 12, 31, 23, 1]// &#125;// fn(&#x27;123&#x27;,123,12,31,23,1)/*     数组增删四件套    push(..data) 为数组最后一项添加一个或者多个data数据,返回值是数组的长度    pop()删除数组中最后一项数据, 返回值是删除的那个值    unshift(...date) 头部添加一个或者多个数据,回值是数组的长度    shift() 删除第一个数据返回删除的数据    重点该系列的方法都会改变原数据*/let arr = [1,2,3]//push(...data) 为数组的最后一项添加一个data数据// console.log(arr.push(4)) // 4// console.log(arr.push(5,6)) //6// console.log(arr.push(&#x27;7&#x27;)) //7//删除最后一项console.log(arr.pop())arr.unshift(&#x27;5&#x27;,&#x27;6&#x27;,&#x27;7&#x27;)arr.shift()\n\nday17-api下数组api&lt;script&gt;   &#x27;use strict&#x27;;   /*        concat(arr1,[,arr2,....]) 数组合并        作用: 将多个数组合并为一个数组       返回值是合并后的新数组,不会改变原数据   */   let arr1 = [123,45]   let arr2 = [65,77]   // let newArr1 = [].concat(arr1,arr2)   let newArr2 = arr1.concat(arr2)//[123, 45, 65, 77]   /*        flat(num) 数组降维       将多维数组降低num维度   */   let arr3 = [123,456] //一维数组   let arr4 = [123,456,[67,89]] //二维数组   let arr5 = [123,456,[67,[56,67],89]] //三维数组   let arr7 = [123,456,[67,[56,[565665,[123123,[12313,[213]]]],67],89]] //三维数组   let arr6 = [[1,1],[1,2],[9,9]] //二维数组   // console.log(arr4.flat(1))   // console.log(arr5.flat(2))   // //降低到一维数组   // console.log(arr7.flat(Infinity))   /*        join(str) 方法       作用:将数组以str作为分隔拼接成为一个字符串       不会改变原数组   */   let arr8 = [&#x27;你好&#x27;,&#x27;我好&#x27;,&#x27;大家好&#x27;]   // console.log(arr8.join(&#x27;&#x27;)) //你好我好大家好   // console.log(arr8.join(&#x27;-&#x27;)) //你好-我好-大家好   /*    slice(beginIndex,[,endIndex])   数组切割 从 beginIndex 开始切割到 endIndex 包含起点不包含终点   不会改变原数组   */     // console.log(arr8.slice(0,2))   // console.log(arr8.slice(1,2))   /*        splice(startIndex,deleteCount,[,item1,...item2n])       既可以截取也可以替换还可以用来新增数据       - startIndex 从什么位置开始截取       - deleteCount 截取几位       - item1-itemn 需要替换的数据       会改变原数据       返回值是截取部分的内容   */   let numArr = [7,56,234,54,875,9,0,2,354,7]   //截取功能   // console.log(numArr.splice(2,2)) //[234, 54]   //替换 将截取部分的内容换为你传入的替换内容   numArr.splice(2,2,&#x27;234&#x27;,&#x27;54&#x27;,&#x27;78&#x27;) // [7, 56, &#x27;234&#x27;, &#x27;54&#x27;, &#x27;78&#x27;, 875, 9, 0, 2, 354, 7]   //添加   numArr.splice(3,0,&#x27;你好&#x27;)   // //pop()   numArr.splice(numArr.length-1,1)   //shift()   numArr.splice(0,1)   //unshift()   numArr.splice(0,0,&#x27;unshift&#x27;)   //push()   numArr.splice(numArr.length,0,&#x27;push&#x27;)   /*        reverse()       翻转数组       123 =&gt; 321       会改变原数组   */   // console.log(arr8.reverse())          &lt;/script&gt;\n\n数组api2&lt;script&gt;&#x27;use strict&#x27;;/*     数组遍历高级方法    arr.forEach(callback,thisArg)    callback(item,index,arr)     - 接受一个回调函数作为参数    - 该回调函数的参数分别为 item 表示当前数组的每一项值,index 当前数组值对应的下标, arr 当前遍历的数组    thisArg 手动指定 this    默认 thisArg 是undefined    可以手动指定回调函数内部的this    回调函数是普通函数的时候第二个参数才有用    foreach没有返回值*/let arr = [6,4,7,8,45,66,789,46]let arr2 = [999,888]let arr3 = [&#x27;name&#x27;,&#x27;age&#x27;,&#x27;sex&#x27;]let arr4 = [&#x27;程力&#x27;,18,&#x27;未知&#x27;]let obj = &#123;&#125;// arr.forEach((item,index,arr)=&gt;&#123;//     console.log(item)//     // console.log(index,&#x27;值对应的下标&#x27;)//     // console.log(arr,&#x27;当前遍历的数组&#x27;)// &#125;)arr3.forEach( function(item,index,arr)&#123;    obj[item] = this[index]    // console.log(index,&#x27;值对应的下标&#x27;)    // console.log(arr,&#x27;当前遍历的数组&#x27;)&#125;,arr4)/*     map 参数跟foreach一模一样    map的返回值是每个数据都进行一次回调函数处理后的新数组*/let ageArr = [23,5,45,78,12,8]//期望值将 agearr = &gt; [&#x27;23岁&#x27;,&#x27;5岁&#x27;...]let newAgeArr = ageArr.map((item,index)=&gt;&#123;    // return item+&#x27;岁&#x27;    return item+&#x27;岁&#x27;&#125;)//手写一个mapfunction myMap(arr,callback,thisArg)&#123;    let newArr = []    for (let i = 0; i &lt; arr.length; i++) &#123;        let newItem =  callback(arr[i],i,arr)        newArr.push(newItem)    &#125;    return newArr&#125;let newAge =  myMap(ageArr,function(item,index,arr)&#123;    // console.log(item)    return item+&#x27;岁&#x27;&#125;)&lt;/script&gt;\n\nday18-api下下数组api    &lt;script&gt;    &#x27;use strict&#x27;;    /*         filter()传入的参数和foreach一样        返回值是一个新的数组, 这个数组是满足filter回调函数返回值的所有结果组成的一个新数组    */   let ageArr = [17,78,45,67,12,,&#x27;123&#x27;,&#x27;465&#x27;,3,4,69,55,8,0]   //删选出小于18岁的用户年龄   //原生写法//    let arr = []//    for (let index = 0; index &lt; ageArr.length; index++) &#123;//         const element = ageArr[index];//         if(element &lt; 18)&#123;//             arr.push(element)//         &#125;//    &#125;    //高级方法    let newArr =  ageArr.filter(item=&gt;&#123;        //return 一定还要返回一个表达式,如果表达式成立就会将这个值作为新数组的一项返回出去        // return item &lt; 18 //返回item小于18的值,组成一个新的数组        return typeof item === &#x27;string&#x27;    &#125;)    //手写一个myFilter    function myFilter(arr,callback,thisArg)&#123;        let newArr = [] //新数组        for (let i = 0; i &lt; arr.length; i++) &#123;            let bol =  callback(arr[i],i,arr)            bol &amp;&amp; newArr.push(arr[i]) //item满足条件就添加        &#125;        return newArr    &#125;    let arrNew = myFilter(ageArr,item=&gt;&#123;        return  typeof item === &#x27;string&#x27;    &#125;)    let str = &quot;张三|男|李四|女|王五|男|赵六|女|田七|女&quot;    //首先考虑改为数组处理    //过滤出所有用户名    let strArr = str.split(&#x27;|&#x27;).filter((item,index)=&gt;&#123;        // return item.length &gt; 1        return index % 2 == 0    &#125;)    /*         reduce(callback,Initialvalue) 归并        callback(acc,curr,index,arr)        - acc 初始值        - curr 当前值        - index 当前值的下标        - arr 当前遍历的数组        Initialvalue 初始值        返回值是最终归并后的结果 也就是acc的值    */    let numArr = [1,2,3,4]    //计算数组中所有数值的和    //原生的写法    function renduce(arr)&#123;        let  result = 0        for (const vlaue of arr) &#123;            result += vlaue        &#125;        return result    &#125;    renduce(numArr)        //reduce 写法    let sum =  numArr.reduce((acc,curr,indx,arr)=&gt;&#123;                return acc + curr    &#125;,0)    //原理    function myReduce(aThis,callback,Initialvalue)&#123;//1        for (let i = 0; i &lt; aThis.length; i++) &#123;                        Initialvalue =  callback(Initialvalue,aThis[i],i)        &#125;    &#125;    let result =  myReduce(numArr,(acc,curr,indx,arr)=&gt;&#123;        return acc + curr    &#125;,0)    let url = &#x27;https://www.baidu.com?name=afei&amp;age=18&amp;sex=nan&#x27;    function parseUrl(urlStr)&#123;        return urlStr.split(&#x27;?&#x27;)[1].split(&#x27;&amp;&#x27;).reduce((acc,curr)=&gt;&#123;            let paramArr = curr.split(&#x27;=&#x27;)            acc[paramArr[0]] = paramArr[1]            return acc        &#125;,&#123;&#125;)    &#125;    // console.log(parseUrl(url))    /*         some() 参数和foreach一样        返回值: 数组中至少有一个元素通过some回调函数返回值的测试,就返回true,否则返回false        检测数组中有没有满足条件(回调函数的返回值)的值,有一个满足就返回true    */    //检测数组中有没有值大于18    let res =  [1,3,4,546,657,34,2].some(item=&gt;&#123;        return item &gt; 18 //返回条件,如果有元素满足这个条件就返回true    &#125;)    /*         every() 写法和some一模一样,区别在于some是只要有一个满足条件就返回true        every是必须每个元素都满足条件才会返回ture    */    let res1 =  [1,3,4,546,657,34,2].every(item=&gt;&#123;        return item &gt; 0 //如果每个元素的值都大于0就返回true    &#125;)    /*         find 和 findIndex        find() 跟some 很像,区别在于他返回的值是满足条件的第一个值,没有满足条件的值返回 undefined         findIndex() 跟find功能一样,但是返回的值是满足调价你的第一个值的下标    */    let res2 =  [34,456,456,34,3,5,7].find(item=&gt;&#123;        return item &gt; 300//返回第一个满足条件的值    &#125;)    let res3 =  [34,456,456,34,3,5,7].findIndex(item=&gt;&#123;        return item &gt; 300//返回第一个满足条件的下标    &#125;)    &lt;/script&gt;\n\n数组api&lt;script&gt;    &#x27;use strict&#x27;;    /*         [1,2,3,4,5].reverse() 数组翻转        会改变原数组    */    // let arr = [1,2,3,4,5]    // arr.reverse()    /*         sort(callback) 数组排序        callback(a,b)         a 表示第一个用于比较的值        b 表示第二个用于比较的值        calllback 返回值 为 a - b 那就是升序排列                返回值 b - a 那就是降序排列        根据callback 返回值决定第一个比较的值和第二个比较的值是否需要更换位置 如果 小于0不更换位置, 大于0互换位置        会改变原数组    */    let arr = [5, 1, 3, 2, 4]    // arr.sort((a,b)=&gt;&#123;    //     // return a - b //升序排列    //     return b - a //降序排列    // &#125;)    //冒泡排序    /*         实现的逻辑        1. 让数组的每一个数据与他的后方一个数据进行比较            - 用循环让他们进行一次对比            - 判断当前项和下一项的大小关系        2. 如果当前数据大于后面的数据那就互换位置            - 如果当前值大于后面的值需要借助中间变量进行值的交换            - 循环为每一个数据进行比较    */    let temp = null    for (let index = 0; index &lt; arr.length; index++) &#123;        for (let i = 0; i &lt; arr.length - index; i++) &#123;            if (arr[i] &gt; arr[i + 1]) &#123;                //当前项大于后面的值                //互换位置                //借助一个中间变量临时存储一个值                temp = arr[i]                arr[i] = arr[i + 1]                arr[i + 1] = temp            &#125;        &#125;    &#125;&lt;/script&gt;\n\nday19-api下下下对象api    &lt;script&gt;    &#x27;use strict&#x27;;    /*         对象就是一系列无序的属性和方法的集合    */        //1. 字面量    let myCat = &#123;        name:&#x27;无限&#x27;,        color:&#x27;black&#x27;,        speak:function()&#123;            console.log(&#x27;喵喵喵&#x27;)        &#125;    &#125;    //2. 通过原生构造函数创建一个对象    let xuxingCat = new Object()    xuxingCat.name = &#x27;嘻嘻&#x27;    xuxingCat.color = &#x27;red&#x27;    xuxingCat.speak = function()&#123;        console.log(&#x27;喵喵喵&#x27;)    &#125;    //3. 工厂函数    function createCat(name,color)&#123;        let xuxingCat = new Object()        xuxingCat.name = name        xuxingCat.color = color        xuxingCat.speak = function()&#123;            console.log(&#x27;喵喵喵&#x27;)        &#125;        return xuxingCat    &#125;    let jiuweiCat = createCat(&#x27;jiujiu&#x27;,&#x27;blue&#x27;)    //4. 构造函数创建对象    function Cat(name,color)&#123;        this.name = name        this.color = color        this.speak = function()&#123;            console.log(&#x27;喵喵喵&#x27;)        &#125;    &#125;        let zhuqueCat = new Cat(&#x27;miaomiao&#x27;,&#x27;pink&#x27;)    //instanceof 关键词用于检测该对象是属于哪个构造函数创建的    console.log(zhuqueCat instanceof String ) //false    console.log(zhuqueCat instanceof Cat ) //true    console.log(zhuqueCat instanceof Object ) //true    let str = &#x27;123&#x27;    let ssttrr = new String(&#x27;adsfafds&#x27;)    console.log(str instanceof String) // false    console.log(ssttrr instanceof String) // false    /*     hasOwnProperty(prop)    obj.hasOwnProperty(prop) 作用是检测属性prop是否在obj对象中    */    let obj = &#123;        name : &#x27;xuixing&#x27;,        age : 18    &#125;        console.log(obj.sex)    // console.log(obj.__proto__)    console.log(obj.hasOwnProperty(&#x27;sex&#x27;)) //fasle    console.log(obj.hasOwnProperty(&#x27;age&#x27;)) //true    console.log(obj.hasOwnProperty(&#x27;__proto__&#x27;)) //true    /*         in 操作符        语法 prop in obj        检测prop属性(包含原型上看不到的属性)是否存在于obj对象中    */   console.log(&#x27;__proto__&#x27; in obj) //true   console.log(&#x27;toLocaleString&#x27; in obj) // true   console.log(&#x27;hasOwnProperty&#x27; in obj) // true   /*         assgin(obj1,obj2,obj3) 方法         作用将 多个对象合并到第一个参数的对象身上   */   let a = &#123;name:&#x27;a&#x27;&#125;   let b = &#123;age:&#x27;12&#x27;&#125;   let c = &#123;sex:&#x27;nan&#x27;&#125;//    console.log(Object.assign(a,b,c))//&#123;name: &#x27;a&#x27;, age: &#x27;12&#x27;, sex: &#x27;nan&#x27;&#125; a对象也被修改了   console.log(Object.assign(&#123;&#125;,a,b,c))//&#123;name: &#x27;a&#x27;, age: &#x27;12&#x27;, sex: &#x27;nan&#x27;&#125; a对象也被修改了            &lt;/script&gt;\n\n对象api&lt;script&gt;&#x27;use strict&#x27;;/*     Object.is(value1,value2)    作用 : 用于做值的比较,比较value1和value2是不是同一个值*/// console.log(&#x27;123&#x27; == 123)// console.log(Object.is(&#x27;123&#x27;,123))//false// console.log(Object.is(0,false))//false// console.log(Object.is(NaN,NaN))//true// console.log(Object.is(NaN,123-&#x27;asdf&#x27;))//true// console.log(undefined == null)//true// console.log(Object.is(undefined,null))//false// console.log(-0 == +0)//true// console.log(-0 === +0) //true// console.log(Object.is(-0,+0)) //false/*     Object.keys(obj)    作用将对象中的所有属性名抽离出来返回一个数组*/   let obj = &#123;    name : &#x27;xuxing&#x27;,    age : 19,    sex : &#x27;男&#x27;,    like : [&#x27;唱歌&#x27;,&#x27;跳舞&#x27;,&#x27;rap&#x27;,&#x27;打篮球&#x27;]&#125;let objKeyArr = Object.keys(obj)objKeyArr.forEach(item=&gt;&#123;    // console.log(obj[item])&#125;)/*     Object.values()    作用将对象中的所有属性值抽离出来返回一个数组*/let objValueArr = Object.values(obj)/*     Object.entries(obj)    作用:将obj对象的属性名和属性值组合成一个数组,最终返回一个二维数组*/let entries = Object.entries(obj)entries.forEach(item=&gt;&#123;    // console.log(item[0],item[1])&#125;)let data = &#123;name: &quot;afei&quot;, age: &quot;18&quot;,sex:&#x27;nan&#x27;&#125;//地址栏优化function disUrl(data)&#123;    return Object.entries(data).map(item=&gt;item.join(&#x27;=&#x27;)).join(&#x27;&amp;&#x27;)&#125;disUrl(data)/*     Object.freeze(obj)    作用:用于将obj对象进行冻结,冻结以后的对象不可以再进行任何的修改    返回值就是冻结后的对象*/Object.freeze(data)/*     Object.isFrozen(obj)    检测对象是否是冻结的对象    返回值布尔值,true表示已经被冻结*/   console.log(Object.isFrozen(data)) // treu/*     obj.valueOf()    方法会返回指定对象的原始值*/let arr = [1,&#x27;2&#x27;,false]console.log(arr.valueOf()) // [1, &#x27;2&#x27;, false]let date = new Date(2013,10,1)console.log(date.valueOf()) // 1383235200000    &lt;/script&gt;\n\njson对象&lt;script&gt;    &#x27;use strict&#x27;;    /*         JSON 对象,表示对象的通用格式,(对象的标准写法)        总结, JSON 就是对象的标准版写法,用于不同语言的数据传输        josn对象的写法        对象的属性名必须是一个字符串        例如 &quot;name&quot; : &quot;xuxing&quot;        每个数据之间必须有逗号隔开        使用大括号保存对象,对象可以包含若干数据        使用方括号保存数组, 数组用,进行分割        JONS的方法        JSON.stringfy()将对象转换为 JSON 字符串        JSON.pares() 将JSON格式的字符串转换为普通对象                JSON格式支持的数据类型        - Object &#123;&#125;        - Arrays []        - 原始类型            string            number            boolean            null    */    let data = &#123;        name: &quot;afei&quot;,         age: 18,         sex: &#x27;nan&#x27;,         eat : &#123;            xixi : &#x27;苹果&#x27;        &#125;,        marry : undefined,        say() &#123;            console.log(&#x27;xixixi&#x27;)        &#125;,         like: [&#x27;唱歌&#x27;,&#x27;跳&#x27;],        Symbol : Symbol()    &#125;    let dataJSON = JSON.stringify(data)    console.log(JSON.parse(dataJSON))    //循环引用无法转换JOSN格式    let user = &#123;        name : &#x27;afei&#x27;    &#125;    let admin = &#123;        jiuwei : &#123;            name : &#x27;jiuwei&#x27;            ,age : 19        &#125;    &#125;    //建立循环引用    admin.afei = user    user.jiuwei = admin    // console.log(JSON.stringify(admin)) //报错    //数组去重    let arr = [1,2,3,1,2,,NaN,3,NaN,null,null,&#123;a:1&#125;,&#123;a:1&#125;]    function unique(arr)&#123;        let newArr = []        let tempARr = []//存储json格式的数据        arr.forEach(element =&gt; &#123;            if(!newArr.includes(element))&#123;                if(!tempARr.includes(JSON.stringify(element)))&#123;                    newArr.push(element)//真实数据添加到newArr                    tempARr.push(JSON.stringify(element))//存储json字符串格式的数据                &#125;            &#125;        &#125;);        console.log(newArr)    &#125;    unique(arr)    //数组去重    let newARr = arr.filter((item,index)=&gt;&#123;        return arr.indexOf(item) === index// 当前遍历的下标和他在数组中第一次出现的下标相同,我就保留    &#125;)    //去重2    function uniq(arr)&#123;        return arr.reduce((acc,curr)=&gt;&#123;            acc.some(item=&gt;Object.is(item,curr))?acc:acc.push(curr)            return acc//[]        &#125;,[])    &#125;    console.log(uniq(arr))&lt;/script&gt;\n\nday20-内置对象数学对象&lt;script&gt;&#x27;use strict&#x27;;    /*         Math 数学对象        Math 对象下存储了一些列处理数学计算的一些方法和一些常用的数学特殊值    */    //静态方法    Math.E  //属性表示自然对数的底数（或称为基数），e，约等于 2.718。    Math.LN10 //属性表示 10 的自然对数，约为 2.302：    Math.LN2 // 属性表示 2 的自然对数，约为 0.693：    Math.LOG10E //属性表示以 10 为底数，e 的对数，约为 0.434：    Math.LOG2E //属性表示以 2 为底数，e 的对数，约为 1.442：    Math.PI //表示一个圆的周长与直径的比例，约为 3.14159：    Math.SQRT1_2 // 属性表示 1/2 的平方根，约为 0.707：    Math.SQRT2 //属性表示 2 的平方根，约为 1.414：    //数学方法    //Math.abs(num) 用于取一个数值的绝对值    // console.log(Math.abs(1)) //1    // console.log(Math.abs(-10)) // 10    // console.log(Math.abs(null))//0    // console.log(Math.abs(&#x27;abc&#x27;))//NaN    // console.log(Math.abs(&#x27;-123&#x27;))//123    // console.log(Math.abs(&#x27;-123abc&#x27;))//NaN    /*         Math.cos(x) 余弦值        Math.sin(x) 正弦值        Math.tan(x) 正切值                x 参数需要传入一个弧度值        返回值就是 -1 - 1 之间的数值 ,单位弧度    */    // console.log(Math.cos(1)) //0.5403023058681398    // console.log(Math.sin(1)) //0.8414709848078965    // console.log(Math.tan(0.5)) //0.5463024898437905    /*         Math.pow(base,exp)        函数返回bae的exp次幂的结果    */    // console.log(Math.pow(2,3))//8    // console.log(Math.pow(10,3))//1000\\    /*         Math.sqrt(x) 平方根 开方        函数返回一个数的平方根的结果 ,  a*a + b*b = Math.sqrt(a*a + b*b )     */    // console.log(Math.sqrt(9)) //3    // console.log(Math.sqrt(1)) //1    //勾股定理    function calcGouGu(a,b)&#123;        return Math.sqrt((a*a)+(b*b))    &#125;    // console.log(calcGouGu(5,12)) //13    // console.log(calcGouGu(5,5)) //7.0710678118654755    /*         Math.floor() 向下取整数        Math.ceil() 向上取整        Math.round() 四舍五入    */    // console.log(Math.floor(3.5))//3    // console.log(Math.floor(3.6))//3    // console.log(Math.floor(-3.5))//-4    // console.log(Math.ceil(2.4))//3    // console.log(Math.ceil(-2.9))//-2    // console.log(Math.round(3.5))//4    // console.log(Math.round(3.3))//3    // console.log(Math.round(3.4))//3    // console.log(Math.round(-3.4))//-3    // console.log(Math.round(-3.6))//-4    /*         Math.max(p1,p2....pn)        Math.min(p1,p2....pn)        获取最大值和最小值        返回值是传入的所有值里面的最大值或者最小值    */    // console.log(Math.max(1,2,3,46,65,2))    // console.log(Math.min(1,2,3,46,65,2))    // let xxx = 100    // console.log(Math.min(xxx,200))    // let age = [12,45,34,78,3,5,67]    // console.log(Math.max(age[0],age[1]))    // console.log(Math.max(...age))//78    /*         Math.random() 随机数        方法会返回一个小数,该小数产生的范围是0-1之间随机产生一个小数值,        包含0 但是不包含1    */    let nameArr = [&#x27;林晨曦&#x27;,&#x27;缇按&#x27;,&#x27;汤子星&#x27;,&#x27;王旭&#x27;,&#x27;刘学云&#x27;,&#x27;张辉&#x27;,&#x27;快乐的小数&#x27;,&#x27;徐星&#x27;]    //需要随机生成一个 0 - 6之间的整数    // let  index =  parseInt(Math.random()*7)    // let  index =  parseInt(Math.random()*nameArr.length)    // console.log(nameArr[index])    //生成一个范围的随机值  5-10 之间的随机值  (10 - 5+1)    let  index =  parseInt(Math.random()*6+5)    console.log(index)    function getRandomInt(min,max)&#123;        return parseInt(Math.random()*(max-min+1)+min)    &#125;    console.log(getRandomInt(200,205))    console.log(nameArr[getRandomInt(3,7)])&lt;/script&gt;\n\n日期对象&lt;script&gt;&#x27;use strict&#x27;;/*     Date对象    创建一个日期时间, Date对象获取到的时间是基于1970年1月1日到至今的毫秒数,又称为世界标准时间,协调世界时间*///创建和获取时间let dateNow = new Date()//获取当前计算机时间//手动设置一个时间/*     设置时间的参数    - new Date(年,月,日,时,分,秒) 不传递的参数默认是0     通过参数设置的月份会比原来更大1 ,因为时间的月份是从0开始计算的    - 通过日期对象能识别的字符串格式传递         - 年-月-日        - 年/月/日        - 通过字符串形式设置的日期月份不会+1*/let oldDay = new Date(2022,7,25)let oldDay2 = new Date(&#x27;2022/8/25&#x27;)let oldDay4 = new Date(&#x27;1970/1/2&#x27;)let oldDay3 = new Date(&#x27;2022-8-25&#x27;)//Thu Aug 25 2022 00:00:00 GMT+0800 (中国标准时间)//Date.parse() 解析时间日期字符串并且返回毫秒数console.log(Date.parse(&#x27;2022-1-1&#x27;)) //1640966400000console.log(Date.parse(&#x27;Thu Aug 25 2022 21:39:30 GMT+0800 (中国标准时间)&#x27;)) //1640966400000//Date.now() 获取当前的时间戳console.log(Date.now())console.log(oldDay4.valueOf())console.log(dateNow)//访问时间console.log(dateNow.getTime(),&#x27;将日期转换为毫秒数&#x27;)console.log(dateNow.getFullYear(),&#x27;日期的年&#x27;)console.log(dateNow.getMonth()+1,&#x27;日期的月&#x27;) //获取到的月份是从0开始计算需要+1console.log(dateNow.getDate(),&#x27;日期的日&#x27;)console.log(dateNow.getDay(),&#x27;星期几&#x27;)console.log(dateNow.getHours(),&#x27;小时&#x27;)console.log(dateNow.getMinutes(),&#x27;分钟&#x27;)console.log(dateNow.getSeconds(),&#x27;秒钟&#x27;)//设置日期 方法跟 get系列一模一样, 但是换成了 set系列console.log(dateNow.setFullYear(2023),&#x27;将日期转换为毫秒数&#x27;)&lt;/script&gt;\n\n日期对象&lt;script&gt;&#x27;use strict&#x27;;/*     日期对象的运算    data获取到的时间都是可以转换为时间戳进行运算的,    时间对象在做运算的时候会默认调用valueOf转换为时间戳数值进行计算*/let now = new Date()//获取当前时间let guoqing = new Date(&#x27;2022-10-1&#x27;)// now.valueOf()// now.getTime()// console.log(+now) //1661435643079let timeG = guoqing - now//将毫秒值转换为年月日// console.log(timeG / 1000 / 60 / 60 / 24) //天// console.log(timeG / 1000 / 60 / 60 % 24 ) //小时// console.log(timeG / 1000 / 60 % 60 ) //分钟// console.log(timeG / 1000 % 60 ) //分钟//时间格式化//1. toDateString() 返回的是星期,月,日,年console.log(now.toDateString())//2 toTimerString() 返回时分秒时区console.log(now.toTimeString())//3, toLocaleDateString() 返回年月日console.log(now.toLocaleDateString())//2022/8/25//5, toLocaleTimerString() 时分秒console.log(now.toLocaleTimeString())//22:01:53//6 toUTCString() 返回对应的utc时间,也就是国际标准时间console.log(now.toUTCString())//tolocalesting() 格式化本地时间console.log(now.toLocaleString())//2022/8/25 22:04:37//时间戳可以进行比较运算console.log(now &gt; guoqing)&lt;/script&gt;\n\nmap集合&lt;script&gt;&#x27;use strict&#x27;;/*     对象 存储无序结合通过键值对    数组 存储有序结合, 直接存储具体的值    map数据结构    对象属性名只能存在字符串,map集合可以允许在数据结构中以 任意类型的数据作为键名进行存储    mpa就是一个带键值对存储数据的集合,  和object 一样,但是他可以用任意数据类型作为属性名进行存储,并且每个属性名只能存在一个    自带的方法    - 创建map  new Map()    - map.set(key,value) 新增数据    - map.get(key) 获取数据    - map.delete(key) 删除数据    - map.has(key) 检索数据是否存在    - map.ckear() 清空集合    - map.size  当前集合一共有多少条数据*/let map = new Map()//新增数据map.set(&#x27;a&#x27;,&#x27;113&#x27;)map.set(true,&#x27;adf&#x27;)let fn = function()&#123;&#125;map.set(fn,&#x27;baffd&#x27;)map.set([1,23,4],&#x27;arrr&#x27;)//取值// console.log(map.get(&#x27;a&#x27;))// console.log(map.get(true))// console.log(map.get(fn)) //baffd//检索值是否存在// console.log(map.has(fn))//true//删除一个值map.delete(true)//删除所有值// map.clear()//检查数据长度// console.log(map.size)//创建并且存储值let map1 = new Map([    [&#x27;key&#x27;,&#x27;vlaue&#x27;],    [false,&#x27;boolean&#x27;],    [function()&#123;&#125;,&#x27;function&#x27;],])let obj  = &#123;    name : &#x27;徐星&#x27;,    age : 19,    sex : &#x27;男&#x27;&#125;//将对象转换为map集合let map2 = new Map(Object.entries(obj))map2.set(&#x27;name&#x27;,&#x27;afei&#x27;)//遍历map集合/*     keys() 遍历所有的键名    values() 遍历所以逇值    entries()     返回值是一个可迭代对象, 可以用forof来进行遍历*/// for (const item of map2.keys()) &#123;//     console.log(item)// &#125;// for (const item of map2.values()) &#123;//     console.log(item)// &#125;// for (const item of map2.entries()) &#123;//     console.log(item)//[&#x27;name&#x27;, &#x27;afei&#x27;]// &#125;// for (const item of map2) &#123;//     console.log(item)//[&#x27;name&#x27;, &#x27;afei&#x27;]// &#125;// map2.forEach(item=&gt;&#123;//     console.log(item)//只能获取到属性值// &#125;)//利用map进行数组去重let arrr = [1,1,2,2,&#123;a:1&#125;,&#123;a:2&#125;,&#123;a:1&#125;,NaN,NaN,undefined,undefined,function a()&#123;&#125;,function a()&#123;&#125;,function b()&#123;&#125;]function uniqu(arr)&#123;    //新数组和map集合    let newArr = [],map = new Map()    for (let i = 0; i &lt; arr.length; i++) &#123;        if(typeof arr[i] === &#x27;object&#x27;)&#123;            ///是一个对象\\            let deep = JSON.stringify(arr[i])            //将数据存储到map集合中            map.set(deep,arr[i])        &#125;else&#123;            //不是引用类型            map.set(`$&#123;arr[i]&#125;`,arr[i])        &#125;    &#125;    //把map中的所有值添加到数组    for (const item of map.values()) &#123;        newArr.push(item)    &#125;    console.log(newArr)&#125;uniqu(arrr)&lt;/script&gt;\n\nday21-map-set解构赋值set集合&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-cn&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;          *&#123;margin: 0;padding: 0;&#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;    &lt;script&gt;    &#x27;use strict&#x27;;    /*         set 也是一个特殊的集合 , 这个集合跟map类型但是他没有key值 , 存储的方式类似于数组, set集合中的值永远只能出现一次, 可以理解为set集合就是一个自带去重效果的类数组        方法集合        - new Set() 创建set集合        - set.add(value) 添加一个value值, value值可以是任意类型的值        - set.delete(value) 删除value值        - set.has(value) 检测value是否存在        - set.clear() 清空集合        - set.size  返回元素个数    */    let set = new Set()    //创建的同时添加数据    let set1 = new Set([1,2,2,3,4])        //遍历set集合    /*         keys()        values()        entries()    */           //存储值    set.add(&#x27;xuxing&#x27;)    set.add(&#x27;jiuwei&#x27;)    set.add(&#x27;wuxian&#x27;)    set.add(&#x27;wuxian&#x27;) //重复添加没有效果    set.add(&#x27;qixi&#x27;)    set.add(&#123;a:1&#125;)     let arr = []    arr.push(1)    arr.push(1) // [1,1]    //删除值    set.delete(&#x27;jiuwei&#x27;)    //检测    set.has(&#x27;jiuwei&#x27;) //fasle        //数组去重    let oob = &#123;a:1&#125;    let arrr = [1,1,2,2,oob,oob,&#123;a:1&#125;,NaN,NaN,undefined,undefined,function a()&#123;&#125;,function a()&#123;&#125;,function b()&#123;&#125;]    //利用set进行数组去重方案一    let set2 = new Set(arrr)    let newArr = []    for (const item of set2) &#123;        newArr.push(item)    &#125;    //数组去重方案二    let newArr2 = [...new Set(arrr)]    // console.log([...&#x27;asdfsafd&#x27;])    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\nweakMap&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-cn&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;          *&#123;margin: 0;padding: 0;&#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;    &lt;script&gt;    &#x27;use strict&#x27;;    /*         set 也是一个特殊的集合 , 这个集合跟map类型但是他没有key值 , 存储的方式类似于数组, set集合中的值永远只能出现一次, 可以理解为set集合就是一个自带去重效果的类数组        方法集合        - new Set() 创建set集合        - set.add(value) 添加一个value值, value值可以是任意类型的值        - set.delete(value) 删除value值        - set.has(value) 检测value是否存在        - set.clear() 清空集合        - set.size  返回元素个数    */    let set = new Set()    //创建的同时添加数据    let set1 = new Set([1,2,2,3,4])        //遍历set集合    /*         keys()        values()        entries()    */           //存储值    set.add(&#x27;xuxing&#x27;)    set.add(&#x27;jiuwei&#x27;)    set.add(&#x27;wuxian&#x27;)    set.add(&#x27;wuxian&#x27;) //重复添加没有效果    set.add(&#x27;qixi&#x27;)    set.add(&#123;a:1&#125;)     let arr = []    arr.push(1)    arr.push(1) // [1,1]    //删除值    set.delete(&#x27;jiuwei&#x27;)    //检测    set.has(&#x27;jiuwei&#x27;) //fasle        //数组去重    let oob = &#123;a:1&#125;    let arrr = [1,1,2,2,oob,oob,&#123;a:1&#125;,NaN,NaN,undefined,undefined,function a()&#123;&#125;,function a()&#123;&#125;,function b()&#123;&#125;]    //利用set进行数组去重方案一    let set2 = new Set(arrr)    let newArr = []    for (const item of set2) &#123;        newArr.push(item)    &#125;    //数组去重方案二    let newArr2 = [...new Set(arrr)]    // console.log([...&#x27;asdfsafd&#x27;])    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\nweakMap练习&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-cn&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;          *&#123;margin: 0;padding: 0;&#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;    &lt;script&gt;    &#x27;use strict&#x27;;    /* /        记录用户访问次数的函数        创建一个集合 用于存储用户的信息, 和用户访问的次数        当用户访问的时候记录用户访问了几次        用户重复访问的时候更新用户访问的次数        用户注销了账号,清空用户的所有访问记录    */    let userCountMap = new WeakMap()    let tangzixing = &#123;name : &#x27;汤子星&#x27;&#125;    //记录和更新用户放的次数    function countSet(user)&#123;        //检测用户是否访问过,如果访问过就增加一次访问次数,没有访问过就设置默认1        let count =  userCountMap.get(user) || 0        userCountMap.set(user,count+1)    &#125;    countSet(tangzixing)    countSet(tangzixing)    countSet(tangzixing)    countSet(tangzixing)    //tangzixing注销了账号    tangzixing = null    //WeakSet 存储方式跟 set 一模一样, 区别就是 弱映射和强映射, 存储的值也必须是对象    let xx = &#123;name:&#x27;xx&#x27;&#125;    let yy = &#123;name:&#x27;yy&#x27;&#125;    let weakSet = new WeakSet()    weakSet.add(xx)    weakSet.add(yy)    yy = null            &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n解构赋值&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-cn&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;          *&#123;margin: 0;padding: 0;&#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;    &lt;script&gt;    &#x27;use strict&#x27;;    /*         解构赋值        解构赋值是一种特殊语法, 可以方便快速的对数组或者对象进行取值的一种方式,        也可以为对象数组设置初始值    */    let userListLoginArr = [&#x27;徐星&#x27;,&#x27;久违&#x27;]    //将数组中的两个值分别取出来方便后续使用    let xuxing1 = userListLoginArr[0]    let jiuwei1 = userListLoginArr[1]    //解构取值 解构的顺序必须一一对应    let [xuxing2,jiuwei2] = userListLoginArr//解构出来的值就是一个变量    //解构出来的结果不会影响原数据    xuxing2 = null    //如果我只想拿到久违,不想解构徐星     // , 作为站位符跳过某个数据    let [,jiuwe3] = userListLoginArr    //可以解构的对象非常多, set 集合也可以结构    let set = new Set([&#x27;aaa&#x27;,&#x27;bbb&#x27;])    let [aaa] = set;    //先声明变量再进行结构    let jiu,xu;    [xu,jiu] = userListLoginArr    //解构的过程中设置默认值    let arr1 = [&#x27;xuxing&#x27;,&#x27;18&#x27;] //用户信息    //当解构的值不存在 可以使用 = 赋值一个默认值    let [name,age,sex=&#x27;nan&#x27;] = arr1    //参数过多也可以使用 rest 参数进行接受    let [praName,...rest] = [&#x27;奥特曼&#x27;,&#x27;199&#x27;,&#x27;180cm&#x27;,&#x27;60kg&#x27;,&#x27;balck&#x27;]    //对象遍历    let user = &#123;        name : &#x27;xxx&#x27;,        age : 11,        sex : &#x27;anan&#x27;    &#125;    //应用场景1    for (const [key,value] of Object.entries(user)) &#123;        console.log(key,value)//name xxx    &#125;    //应用场景2 user转换为地址栏拼接格式    let pareUrl = Object.entries(user).map(([key,value])=&gt;&#123;        return key+&#x27;=&#x27;+value    &#125;).join(&#x27;&amp;&#x27;)    //变量位置交换    let a = 1;    let b = 2;    //中间变量的写法    // let temp = a;    // a = b    // b = temp    //应用场景3 解构交换位置    [a,b] = [b,a]    let arrList = [1,3,[3,4,[5]]]    //嵌套结构    let [,,[,,[five]]] = arrList            &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n对象类型结构&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-cn&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;          *&#123;margin: 0;padding: 0;&#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;    &lt;script&gt;    &#x27;use strict&#x27;;    /*     对象解构赋值 语法  let &#123;val1,val2&#125; = &#123;val2,val1&#125;    解释 创建一个变量val1 和 val2 赋值为对象 中的 属性叫 val1的值和 val2的值    */    let option = &#123;        title : &#x27;Menu&#x27;,        width : 100,        height : 200,        color : undefined    &#125;    //解构取值    // let &#123;height,width,title&#125; = option    //重命名    // let &#123;height:h,width:w,title:t&#125; = option    //设置默认值    // let &#123;height:h,width:w,title:t,color=&#x27;black&#x27;&#125; = option    //设置剩余参数    // let &#123;title,...rest&#125; = option //rest 就是剩余所有值组成的一个对象    //对象申明解构需要加括号    let title,height;    (&#123;title,height&#125; = option)    //函数参数结构    function showMenu(&#123;w,h=1&#125;)&#123;        // obj.h = obj.h || 1        // console.log(obj.w * obj.h)        console.log(w * h)    &#125;    showMenu(&#123;        w : 100,        h : undefined    &#125;)            &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\nday22-面向对象什么是面向对象&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-cn&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;          *&#123;margin: 0;padding: 0;&#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;    &lt;script&gt;    &#x27;use strict&#x27;;    /*         js 中 任务事物都可以抽象成为一个对象, 行为, 特征        行为 : 用function表示        特征 : 对象的属性名和属性值        编程模式        1. 面向对象 OOP        2. 面向过程 POP        区分面向对象和面向过程        大象 装 冰箱 (业务需求)        代码实现大象装冰箱的过程        1. 面向过程的形式来实现 将需求分析出几个步骤,按照函数一步一步的实现, 最终有条有序的执行完成效果            1.1 打开冰箱门(代码实现)            1.2 把大象放进去            1.3 冰箱门关闭                    2. 面向对象 面向对象首先要将需要处理事物抽象成为一个对象, 然后对象之间分工明确合作完成效果            2.1 抽象出大象的对象                - 大象有体貌特征的属性                - 大象要有一个移动的行为            2.2 抽象出冰箱的对象                - 冰箱有尺寸大小的属性                - 冰箱有打开冰箱门的行为                - 关闭冰箱门的行为            执行大象装冰箱的行为 , 执行冰箱打开门的行为 - 执行大象移动的行为 - 执行冰箱关闭门的行为            面向对象是以功能进行划分,而不是步骤进行划分        面向对象的特征        1. 抽象对象的公共属性和行为封装成为一个类        2. 对象的实例化 获取类的实例化对象        面向对象的特征        - 封装性        - 继承性        - 多态性  同一个对象在不同的状态下有不同的效果        面向对象和面向过程对比        面向过程:         优点:性能高,适合跟硬件相关的程序,单片机        缺点:不容易维护,不方便扩展和复用                面向对象        优点:方便复用和维护,方便扩展         缺点:性能比较低        创建一个空调a        新增空调a温度控制的功能()&#123;&#125;        创建一个遥控        打开空调a()&#123;&#125;        关闭空调a的函数()&#123;&#125;        新增为空调a增加温度的功能()&#123;&#125;        空调 = &#123;        &#125;                遥控器 = &#123;            打开空调()&#123;&#125;            关闭空调()&#123;&#125;            温度增加()&#123;&#125;            温度减少()&#123;&#125;        &#125;    */            &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; \n\n面向对象es5&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-cn&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;          *&#123;margin: 0;padding: 0;&#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;    &lt;script&gt;    &#x27;use strict&#x27;;    /*         方式一 let obj = &#123;&#125;        方式二 let obj = new Object()        需要大量创建对象的时候        方式一 工厂函数创建对象        方式二 new关键词配合构造函数创建对象    */    //创建一个学生类    function Student(name,age)&#123;        //学员共有特征        this.name = name        this.age = age        //共有的行为        this.say = function()&#123;            console.log(`我是$&#123;this.name&#125;,我今年$&#123;this.age&#125;岁`)        &#125;    &#125;        //创建类的实例化对象    let xuxing = new Student(&#x27;xuxing&#x27;,19)    let wuxian = new Student(&#x27;wuxian&#x27;,18)    xuxing.say()    wuxian.say()    console.log(xuxing.name === wuxian.name)//false    console.log(xuxing.say === wuxian.say) //fase            &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n静态成员实例成员es5&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-cn&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;          *&#123;margin: 0;padding: 0;&#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;    &lt;script&gt;    &#x27;use strict&#x27;;    /*         类的成员分为两类        - 静态成员        - 动态成员(实例成员)            1. 类中挂载到this上的所有属性和方法            2. 实例成员只能通过实例化出来的对象才能访问    */    //创建一个学生类    function Student(name,age)&#123;        //实例成员(动态成员)        this.name = name        this.age = age        //共有的行为        this.say = function()&#123;            console.log(`我是$&#123;this.name&#125;,我今年$&#123;this.age&#125;岁`)        &#125;    &#125;    //在构造函数下直接挂载属性    //类的静态成员    Student.height = &#x27;180cm&#x27;        //创建类的实例化对象    let xuxing = new Student(&#x27;xuxing&#x27;,19)    let wuxian = new Student(&#x27;wuxian&#x27;,18)    xuxing.say()    wuxian.say()    console.log(Student.name)//Student    console.log(Student.age)//undefined    console.log(Student.height)//180cm            &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n原型对象和对象原形&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-cn&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;          *&#123;margin: 0;padding: 0;&#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;    &lt;script&gt;    &#x27;use strict&#x27;;     //函数每次实例化出来得都是一个全新的函数, 但是每个函数的功能都是一模一样的, 存在一个浪费空间的问题, 希望函数是同一个函数    //全局创建了一个函数    // function sayInfo()&#123;    //     console.log(`我是$&#123;this.name&#125;,我今年$&#123;this.age&#125;岁`)    // &#125;        //创建一个学生类    function Student(name,age)&#123;        this.name = name        this.age = age        //共有的行为        // this.sayHi = Student.sayHi  //每次实例化都添加的同一个函数        this.say = Student.fnObj.sayInfo  //每次实例化都添加的同一个函数        this.sayHi = Student.fnObj.sayHi  //每次实例化都添加的同一个函数        this.sayLength = Student.fnObj.length  //每次实例化都添加的同一个函数    &#125;    //添加静态属性    /*   Student.sayInfo =  function sayInfo()&#123;            console.log(`我是$&#123;this.name&#125;,我今年$&#123;this.age&#125;岁`)        &#125;        Student.sayHi =  function()&#123;            console.log(`Hi我是$&#123;this.name&#125;`)        &#125; */    //共有方法    Student.fnObj = &#123;        sayInfo()&#123;            console.log(`我是$&#123;this.name&#125;,我今年$&#123;this.age&#125;岁`)        &#125;,        length()&#123;            console.log(&#x27;我是length&#x27;)        &#125;,        sayHi : function()&#123;            console.log(`Hi我是$&#123;this.name&#125;`)        &#125;    &#125;    //为学生类添加共有方法 在原型对象下 prototype    Student.prototype.sayName = function()&#123;        console.log(this)    &#125;        //创建类的实例化对象    let xuxing = new Student(&#x27;xuxing&#x27;,19)    let wuxian = new Student(&#x27;wuxian&#x27;,18)    xuxing.say()    wuxian.say()    wuxian.sayHi()    wuxian.sayLength()    console.log(xuxing.say === wuxian.say)    //原型对象, 和 对象原型    //原型对象是 每个构造函数(函数) 内都有的一个对象 叫做 prototype    /*     constructor 构造器 存储一个指针,指向原型对象的创建者    挂载到原型对象下的方法是所有实例化出来的对象都能访问到的    */    let arr1 = new Array(1,2,3)    console.log(arr1.join(&#x27;-&#x27;))    console.log(Student.prototype)    console.log(Array.prototype)            &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n原型对象和对象原形2&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-cn&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;          *&#123;margin: 0;padding: 0;&#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;    &lt;script&gt;    &#x27;use strict&#x27;;        //原型对象, 和 对象原型    /*     原型对象是 每个构造函数(函数) 内都有的一个对象 叫做 prototype    -  constructor 构造器 存储一个指针,指向原型对象的创建者    对象原型 每个对象下都有的一个对象(实例化对象)__proto__就叫做对象原型    - 对象原型存储的就是原型对象    - constructor 属性指向创建该对象的构造函数\\    原型链    规定原型和对象原型下的查找规则    1. 自身对象下有没有这个方法,有就用没有就继续往下查找    2. 自身对象的对象原型下有没有这个方法,没有就根据对象原型下的constructor 找到创建他的构造函数身上的原型对象继续查找    3. 如果自身有那就用自己身上的    挂载到原型对象下的方法是所有实例化出来的对象都能访问到的    */    //创建一个学生类    function Student(name,age)&#123;        this.name = name        this.age = age    &#125;    //为学生类添加共有方法 在原型对象下 prototype    // Student.prototype.sayName = function()&#123;    //     console.log(this.name) //指向实例化出来的对象    // &#125;    //多个共有方法的添加 方式一 继续使用.操作添加    //方式二利用对象覆盖批量添加    /*         批量添加会存在一个问题就是会丢失constructor属性    */    Student.prototype = &#123;        //手动添加回constructor        constructor : Student,        sayName()&#123;            console.log(this.name) //指向实例化出来的对象        &#125;,        sayAge()&#123;            console.log(this.age) //指向实例化出来的对象        &#125;    &#125;    //创建类的实例化对象    let xuxing = new Student(&#x27;xuxing&#x27;,19)    let wuxian = new Student(&#x27;wuxian&#x27;,18)    xuxing.__proto__.aaa = function()&#123;        console.log(&#x27;aaa&#x27;)    &#125;    xuxing.aaa()    wuxian.aaa()    //当你访问的方法或者属性是自身实例化没有的,那他就会根据原型链往上一次进行查找    console.log(wuxian.toString())//[object Object]    //调用共有方法    xuxing.sayName()    xuxing.sayAge()    let arr = []    // console.log(xuxing.say === wuxian.say)    // console.log(xuxing.sayName === wuxian.sayName)    console.log(xuxing.__proto__ === Student.prototype) //true    console.log(Object.prototype.__proto__) //null 原型链的尽头              &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n继承&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-cn&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;          *&#123;margin: 0;padding: 0;&#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;    &lt;script&gt;    &#x27;use strict&#x27;;    /*         对象的继承 就是将父类的属性和方法继承给子类    */    //父类    function Father(name,age,money)&#123;        this.age = age        this.name = name        this.money = money    &#125;    //父类的方法    Father.prototype.say = function()&#123;        console.log(this.name,&#x27;我是父类的方法&#x27;)    &#125;    //子类    function Son(name,age,sex)&#123;        //继承父类的属性        Father.call(this,name,age) //属性继承        //子类独有的属性        this.sex = sex    &#125;    //方法继承 方式一 , 缺点就是建立了引用关系,子类更新会影响到父类    // Son.prototype = Father.prototype    //方式二 利用__proto__继承 缺点就是会把属性也给继承到自身的原型上    // Son.prototype = new Father()    // Son.prototype.constructor = Son    //方式三 创建一个新的类,类专门用来继承    // function Fn()&#123;    // &#125;    // Fn.prototype = Father.prototype //自身原型的值设置为父类的值    // Son.prototype = new Fn()    // Son.prototype.constructor = Fn    //方式四 Object.assgin()对象合并    Object.assign(Son.prototype,Father.prototype)    //希望子类能继承父类的属性    let  f = new Father(&#x27;路遥&#x27;)    let  s = new Son(&#x27;徐星&#x27;,19,&#x27;nan&#x27;)    f.say()    s.say()            &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\nes6类&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-cn&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;          *&#123;margin: 0;padding: 0;&#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;    &lt;script&gt;    &#x27;use strict&#x27;;    /*         es6 新增了一个关键词叫做class 作用就是创建一个类        class 运用的不是一个新的技术他就是es5原型方式的一个简写方案(语法糖)    */    //创建类    class Animal&#123;        static sex = &#x27;nan&#x27;        //书写代码的方式就是正常书写,不要把它当做对象来书写        constructor(name,age)&#123;            //构造器 存储的就是类的动态成员            this.name = name            this.age = age        &#125;        //类的行为        say()&#123;            console.log(`may name is $&#123;this.name&#125;`)        &#125;    &#125;    //创建类的实例化    let dog = new Animal(&#x27;徐星&#x27;,2)    let cat = new Animal(&#x27;无限&#x27;,1)    dog.say()    //es6类的继承只需要借助 extends 关键词就可以了    class Dog extends Animal&#123;        constructor(name,age,color)&#123;            //super关键词等价于拿到父类方法,可以执行表示拿到父类的const,也可以当做对象访问父类的方法            //super关键词继承属性的时候必须写到私有属性之前            super(name,age)//继承父类的属性            this.color = color //私有属性            super.say()        &#125;        //方法是默认继承的    &#125;    // console.log(dog.__proto__)    let wuxian = new Dog(&#x27;无限&#x27;,1,&#x27;black&#x27;)    wuxian.say()    console.log(dog.say === cat.say)//true    //访问静态属性    // console.log(Animal.sex)          &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n","categories":["WebFrontend"],"tags":["javascript"]},{"title":"关于如何HTML嵌入CSS样式（四种方法）","url":"/2021/11/21/WebFrontend/UI/%E5%85%B3%E4%BA%8E%E5%A6%82%E4%BD%95HTML%E5%B5%8C%E5%85%A5CSS%E6%A0%B7%E5%BC%8F%EF%BC%88%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%89/","content":"前言\n在写网页时，明明自己会学css，但是不会使用，我在网上整理了一些关于HTML嵌入CSS样式的学习资料，该资料仅供自己和大家作为参考。\nHTML嵌入CSS样式大致有四种方法；\n\n\n行内样式：使用 HTML 标签的 style 属性定义 CSS 样式；\n\n\n内嵌样式：使用 &lt;style&gt; 标签在 HTML 文档头部（&lt;head&gt; 和 &lt;head&gt; 之间）定义 CSS 样式；\n\n\n链接式：使用 &lt;link&gt; 标签引入外部 CSS 样式表文件。\n\n\n导入式：使用 @import 命令导入外部 CSS 样式表文件。\n\n\n第1种和第2种方法都是将 CSS 样式写到当前 HTML 文档里面，而第3种和第4种方法都是将 CSS 样式放在外部文件，然后再导入到当前 HTML 文档中。\n行内样式（内联样式）\n行内样式就是把 CSS 样式直接放在代码行内的标签中，一般都是放入标签的style属性中，由于行内样式直接插入标签中，故是最直接的一种方式，同时也是修改最不方便的样式。\n【示例】针对段落、&lt;h2&gt; 标签、&lt;em&gt; 标签、&lt;strong&gt;标签以及 &lt;div&gt; 标签，分别应用 CSS 行内样式。\n&lt;!doctype html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=&quot;UTF-8&quot;&gt;\n&lt;title&gt;行内样式&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;p style=&quot;background-color: #999900&quot;&gt;行内元素，控制段落-1&lt;/p&gt;\n    &lt;h2 style=&quot;background-color: #FF6633&quot;&gt;行内元素，h2 标题元素&lt;/h2&gt;\n    &lt;p style=&quot;background-color: #999900&quot;&gt;行内元素，控制段落-2&lt;/p&gt;\n    &lt;strong style=&quot;font-size:30px;&quot;&gt;行内元素，strong 比 em 效果要强&lt;/strong&gt;\n    &lt;div style=&quot;background-color:#66CC99; color:#993300; height:30px; line-height:30px;&quot;&gt;行内元素，div 块级元素&lt;/div&gt;\n    &lt;em style=&quot;font-size:2em;&quot;&gt;行内元素，em 强调&lt;/em&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n在上面示例中，行内样式由 HTML 元素的 style 属性嵌入，即将 CSS 代码放入style=&quot;&quot;引号内即可，多个 CSS 属性值则通过分号;间隔。例如示例中的 &lt;div&gt; 标签：\n\n\n行内元素，div 块级元素 \n>段落 `&lt;p&gt;` 标签设置背景色为褐色（background-color: #999900），标题 `&lt;h2&gt;` 标签设置背景色为红色（background-color: #FF6633）。\n`&lt;strong&gt;` 标签设置字体为 30 像素（font-size:30px;），`&lt;div&gt;` 标签设置高度和行高为 30 像素以及进行背景色、颜色的设置（background-color:#66CC99; color:#993300; height:30px; line-height:30px;），`&lt;em&gt;` 标签设置字体大小为相对单位（font-size: 2em;）。\n两个段落 `&lt;p&gt;` 标签，虽内容不同，但使用一样的背景色设置，却添加两次 CSS 行内属性设置背景色 background-color: #999900。\n\n缺点：\n\n每一个标签要设置样式都需要添加 style 属性。\n与过去网页制作者将 HTML 的标签和样式糅杂在一起的效果不同的是，现在是通过 CSS 编写行内样式，过去釆用的是 HTML 标签属性实现的样式效果。虽方式不同，但导致的后果是一样的：后期维护成本高，即当修改页面时需要逐个打开网站每个页面一一修改，根本看不到 CSS 所起到的作用。\n添加如此多的行内样式，页面体积大，门户网站若釆用这种方式编写，那将浪费服务器带宽和流量。\n\n网络上有些网页通过查看源文件可以看到这种编写方式，虽然一个网页只有一部分是如此做的， 但需要分情况：\n\n若网页制作者编写这样的行内样式，可以快速更改当前样式，不必考虑以前编写的样式冲突问题；\n网页中若存在这种情况则是后台编辑时，通过编辑器生成的样式，或后台未开发完整，需为编辑人员开发可选择样式的选项而非通过编辑器直接改变颜色、粗细、背景色、倾斜等效果。\n\n内嵌样式内嵌样式通过将 CSS 写在网页源文件的头部，即在 &amp;lt;head&amp;gt; 和 &amp;lt;head&amp;gt; 之间，通过使用 HTML 标签中的 &amp;lt;style&amp;gt; 标签将其包围，其特点是该样式只能在此页使用，解决行内样式多次书写的弊端。\n【示例】为段落设置内嵌式样式书写方法，减少代码量。\n&lt;!doctype html&gt;\n\n\n\n内嵌式\n\np{\n    text-align: left;  /*文本左对齐*/\n    font-size: 18px;  /*字体大小 18 像素*/\n    line-height: 25px;  /*行高 25 像素*/\n    text-indent: 2em;  /*首行缩进2个文字大小空间*/\n    width: 500px;  /*段落宽度 500 像素*/\n    margin: 0 auto;  /*浏览器下居中*/\n    margin-bottom: 20px;  /*段落下边距 20 像素*/\n}\n\n\n\n    “百度”这一公司名称便来自宋词“众里寻他千百度”。（百度公司会议室名为青玉案，即是这首词的词牌）。而“熊掌”图标的想法来源于“猎人巡迹熊爪”的刺激，与李博士的“分析搜索技术”非常相似，从而构成百度的搜索概念，也最终成为了百度的图标形象。在这之后，由于在搜索引擎中，大都有动物形象来形象，如 SOHU 的狐，如 GOOGLE 的狗，而百度也便顺理成章称作了熊。百度熊也便成了百度公司的形象物。\n    在百度那次更换 LOGO 的计划中，百度给出的 3 个新 LOGO 设计方案在网民的投票下，全部被否决，更多的网民将选票投给了原有的熊掌标志。\n    此次更换 LOGO 的行动共进行了 3 轮投票，直到第 2 轮投票结束，新的笑脸 LOGO 都占据了绝对优势。但到最后一轮投票时，原有的熊掌标志却戏剧性地获得了最多的网民选票，从而把 3 个新 LOGO 方案彻底否决。\n\n\n\n## 链接式\n\n链接式通过 HTML 的 &amp;lt;link&amp;gt; 标签，将外部样式表文件链接到 HTML 文档中，这也是网络上网站应用最多的方式，同时也是最实用的方式。这种方法将 HTML 文档和 CSS 文件完全分离，实现结构层和表示层的彻底分离，增强网页结构的扩展性和 CSS 样式的可维护性。\n【示例】\n&lt;!doctype html&gt;\n\n\n\n\n\n\n\n\n    我是被 lianjie-2.css 文件控制的，楼下的你呢？？\n    楼上的，lianjie.css 文件给我穿的花衣服。\n\n\n\n>在上面示例中，通过 link 链接两个 CSS 文件，且都有效，这也是网站制作者将公共部分放入一个 CSS 文件，当前页面样式编写新的样式文件。\n\nlianjie.css 文件代码：\nh3{\nfont-weight: normal;  /取消标题默认加粗效果/\nbackground-color: #66CC99;  / 设置背景色 /\nheight: 50px;  /设置标签的高度/\nline-height:50px;  / 设置标签的行高 /\n}\nspan{\ncolor: #FFOOOO;  / 字体颜色 /\nfont-weight:bold;  / 字体加粗 /\n}\n\nlianjie-2.css 文件代码：\n\np{\ncolor: #FF3333;  /字体颜色设置/\nfont-weight: bold;  / 字体加粗 /\nborder-bottom: 3px dashed #009933;  / 设置下边框线 /\nline-height: 30px;  / 设置行高 /\n}\n\n>链接式样式使 CSS 代码和 HTML 代码完全分离，达到结构与样式的分开，使 HTML 代码专门构建页面结构，而美化工作由 CSS 完成。\n\n\n链接式导入 CSS 样式的好处：\n\nCSS 文件可以放在不同的 HTML 文件中，使网站所有页面样式统一；\n再者将 CSS 代码放入一个 CSS 文件中便于管理、减少代码以及维护时间；\n当修改 CSS 文件时，所有应用此 CSS 文件的 HTML 文件都将更新，而不必从服务器上将所有的页面取回再修改完毕后上传。\n\n\n导入样式导入样式使用 @import 命令导入外部样式表。导入样式有 6 种书写方式：\n\n\n@import daoru.css;\n\n\n\n@import &amp;#039;daomxss&amp;#039;;\n@import &quot;daoru.css&quot;;\n@import url(daoru.css);\n@import url(&amp;#039;daoru.css&amp;#039;);\n@import url(&quot;daoru.css&quot;);\n\n【示例】导入样式表 lianjie.css 和 daoru.css 以及书写 &amp;lt;body&amp;gt; 标签的背景色，注意导入样式表和 &amp;lt;body&amp;gt; 标签样式的前后不可颠倒。\n\n\n\n\n\n    @import url(lianjie.css);\n    @import url(daoru.css);\n    body { background-color: #e4e929; }\n\n\n\n    \n        我是被 lianjie-2.css 文件控制的，楼下的你呢？？\n        褛上的，lianjie.css文件给我穿的花衣服。\n    \n\n\n\n>在上面示例中，必须是`@import url(&quot;lianjie-2.css&quot;); p&#123;text-indent: 3em;&#125;`，而不能是`p&#123;text-indent:3em;&#125; @import url(&quot;lianjie-2.css&quot;)`;，否则将导入效果无效。在 CSS 文件中也需要将 @import 放在前面，后面加入 CSS 样式，否则也是无效。\n>lianjie.css 文件代码，同上一个示例即链接式。\n>daoru.css 文件代码：\n>\n>&gt;@import url(&amp;quot;lianjie-2.css&amp;quot;);&gt;p &#123; text-indent: 3em; &#125;\n\n","categories":["WebFrontend"]},{"title":"Unity2017教程笔记（P1到P23，unity页面介绍）","url":"/2022/07/24/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity/Unity%E7%AC%94%E8%AE%B0%EF%BC%88%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%EF%BC%89/","content":"坐标\n坐标：X红色、Y绿色、Z蓝色\n世界坐标 ： 整个场景的固定坐标，不随物体旋转而改变\n本地坐标 ：物体自身坐标，随旋转而改变\n\n\n场景 Scenes\n一组相关联的游戏对象的集合，通常游戏中每个关卡就是一个场景，用于展现当前关卡中的所有物体。\n\n游戏对象 GameObject\n运行时出现在场景中的游戏物体\n例如：人物、地形、数目……\n\n是一种容器、可以挂载组件。\n\n父、子物体\n在Hierarchy面板中。将一个物体拖拽到另外一个物体中。\n子物体将继承父物体的移动，旋转和缩放属性，但子物体不影响父物体。\n\n\n组件 Component\n是游戏对象的功能模块。\n每个组件都是一个类的实例。\nTransform 变换组件：决定物体位置、旋转、缩放比。\nMesh Filter 网络过滤器：用于从资源中获取网络信息。\nMesh Renderer 网络渲染器 : 从网络过滤器中获得几何形状，对根据变化组件定义的位置进行渲染。\n网格过滤器 与 网格渲染器 联合使用 ，使模型显示到屏幕上。\n\nProject工程对象-Scene场景-GameObject游戏对象（容器）-Component组件（功能）\n材质 Material\n材质：物体的质地，指色彩、纹理、光滑度、透明度、反射率、发光度等。实际就是Shader的实例。\nShader 着色器 ： 专门用来渲染3D图形的技术，可以使纹理以某种方式展现。实际就是一段嵌入到渲染管线中的程序，可以控制GPU运算图像效果的算法。\nTexture 纹理 ：附加到物体表面的贴图。\n\n物理着色器\n基于物理特性的Shader是Unity 5.x的重大革新之一,所谓物理着色器(Physically Based Shading,PBS)就是遵从物理学的能量守恒定律,可以创建出在不同光照环境下都接近真实的效果。\n\n摄像机 Camera简介\n附加了摄像机Camera组件的游戏对象\n向玩家捕获和现实世界的设备\n场景中摄像机的数量不受限制\n\n组件\nTransform 变换组件\nCamera 摄像机 ： 向玩家捕获和显示世界\nFlare Layer 耀斑层 : 激活可显示光源耀斑\nGUI Layer : 激活可渲染二维GUI元素\nAudio Listener视频监听器 ； 接收场景输入的音源Audio Source并通过计算机的扬声器播放声音。\n\n属性\nClear Flags清除标识:决定屏幕的空白部分如何处理Skybox天空盒:空白部分显示天空盒图案Solid Color纯色:空白部分显示背景颜色Depth Only仅深度:画中画效果时，小画面摄像机选\n择该项可清除屏幕空部分信息只保留物体颜色信息。Don’ t Clear 不清除:不清除任何颜色或深度缓存。\n\nBackground背景:所有元素绘制后，没有天空盒的情况下，剩余屏幕的颜色。\n\nCulling Mask选择遮蔽层:选择要照射的层Layer 。\n\nProjection投射方式:Perspective透视:透视图,物体具有近大远小效果。Orthographic正交:摄像机会均匀地渲染物体,没有透视感,通常小地图使用。\n\nSize大小(正交模式) :摄影机视口的大小\n\nField of view视野(透视模式) :设置相机视野的远近距离\n\nField of view裁剪面:相机到开始和结束渲染的距离Near近:绘制的最近点。Far远:绘制的最远点。\n\nViewport Rect视矩形:标明这台相机视图将会在屏幕上绘制的屏幕坐标。X:摄像机视图的开始水平位置。Y:摄像机视图的开始垂直位置。W宽度:摄像机输出在屏幕上的宽度。H高度:摄像机输出在屏幕上的高度。\n\nDepth深度:相机在渲染顺序上的位置。具有较低深度的摄像机将在较高深度的摄像机之前渲染。\n\n\n天空盒 SkyBox\n围绕整个场景的包装器，用于模拟天空的材质\n\n天空和材质种类 ： 6 Sided ， Procedural ，Cubemap 。\n\n\n6 Sided 属性\nTint Color 色彩\nExposure 亮度\nRotation 旋转\n\nProcedural 属性\nSun 太阳模式\n– None 没有\n– Simple 简单\n–Higth  Quality 高质量\n\nAtmoshpere Thickness 大气层厚度\n\nGround 地面颜色\n\n如果为Environment Lighting的Sun属性设置一 个平行光场景中会根据平行光角度自动创建太阳,并且位置随平行光旋转而改变。如果不设置,系统将默认选择场景中最亮的平行光。\n\n\n使用太空盒\n设置摄像机 Clear Flags 属性为Skybox。\n\n方式以：摄像机添加组件 Skybox\n\n方法二 ：光照窗口\nWindow - Lighting - Environment Lighting – Skybox可作为反射源将天空色彩反射到场景中物体。\n\n\nInstantOC渲染管线\n游戏数据在GPU上经过运算处理，最后输出到屏幕的过程$$绘制调用 Draw Call： 每次引擎准备数据并通知GPU的过程。通俗讲，每帧调用显卡渲染物体的次数$$游戏 —&gt; 图形API —&gt; CPU与GPU分界线 —&gt; 顶点处理 —&gt; 图元装配 —&gt; 光栅化 —&gt; 图像处理 —&gt; 缓存\n\n顶点处理\n接受模型顶点数据。（任何的一个图形都是若干个三角组成的,三角形定点坐标）\n坐标系转换。\n\n图元装配\n组装面 ： 连接相邻的顶点，绘制为三角面\n\n光栅化\n计算三角面上的像素，并为后面着色阶段提供合理的插值参数。\n\n像素处理\n对每个像素区域进行着色。\n写入到缓存中\n\n缓存\n一个存储像素数据的内存块，最重要的缓存时帧缓存与深度缓存\n帧缓存 ：存储每个像素的色彩，即渲染后的图像。帧缓存常常在显存中，显卡不断读取并输出到屏幕中。\n深度缓存 z-buffer : 存储像素的深度信息，即物体到摄像机的距离。光栅化时便计算各像素的深度值，如果新的深度值比现有值更近，则像素颜色被写到帧缓存，并替换深度缓存。\n\n属性\nLayer mask ：参与遮挡剔除的游戏对象层。\n\nIOC Tag ：将为指定标签的游戏对象自动添加IOClod脚本对象。\n\nSamples ： 每帧相机发射的射线数目。数量多剔除效果好，但性能开销大。通常在150-500之间。\n\nRays FOV ： 射线视野，应大于摄像机事业Field of View。\n\nView Distance ： 试图距离 ， 射线长度。\n​\t\t\t\t\t\t\t\t将影响摄像机Clipping Planes -Far 数值。\n\nHide Delay： 延迟隐藏，当物体被剔除时延迟的帧数，建议50-100之间。\n\nPreCull Check ： 检查采集信息，建议勾选，可以提高剔除效率。\n\nRealtime Shadows： 实时阴影，如果场景需要实时阴影，建议启用，确保剔除物体显示正常的阴影。\n\n\nOcclusion Culling即时遮挡剔除\n即使遮挡剔除 Instant Occlusion Culling\n遮挡剔除 ： 当物体被送到渲染流水线之前，将摄像机视角内看不到的物体进行剔除，从而减少了每帧渲染数据量，提高渲染性能。\n\nLOD多细节层次\n多细节层次 Levels of Detail\nLOD技术指根据物体模型的节点在显示环境中所处的位置和重要程度，决定物体渲染的资源分配，降低非重要物体的面数和细节度，从而获得高效率的渲染运算。(根据距离进行资源渲染分配)\n\n\n光照系统Global Illumination\n简称GI，即全局光照\n能够计算直接光、间接光、环境光一级反射光的光照系统。\n通过GI算法可以使渲染出来的光照效果更为真实丰富。\n\n直接光照\n从光源直接发出的光，通过Light组件实现。\nType类型:灯光对象的当前类型\nDirectional Light平行光:平行发射光线,可以照射场景里所有物体,用于模拟太阳。\nPoint Light点光源:在灯光位置上向四周发射光线,可以照射其范围内的所有对象,用于模拟灯泡。\nSpot Light聚光灯:在灯光位置上向圆锥区域内发射光线,只有在这个区域内的物体才会受到光线照射,用于模拟探照灯。\nArea Light区域光:由一个面向一个方向发射光线,只照射该区域内物体,仅烘焙时有效，用在光线较为集中的区域。\nRange范围:光从物体的中心发射的范围。仅适用于点光源和聚光灯。\nSpot Angle聚光角度:灯光的聚光角度。只适用于聚光灯。\nColor颜色:光线的颜色。\nIntensity强度:光线的明亮程度。\nCulling Mask选择遮蔽层:选择要照射的层Layer。\n\n\n\n间接光照\n物体表面在接受光照后反射出来的光。\n通过Light组件中Bounce Intensity反弹强度控制。\n可以通过Scene面板Irradiance模式查看间接光照。\n注意:只有标记Lightmaping Static的物体才能产生间接反弹光照。\n\n环境光照\n作用于场景内所有物体的光照,通过Environment Lighting中Ambient控制。\nAmbient Source环境光源\nSkybox通过天空盒颜色设置环境光照\nGradient梯度颜色Sky天空颜色、Equator 地平线颜色、Ground 地面颜色\nAmbient Color纯色\nAmbient Intensity环境光强度\nAmbient GI环境光GI模式\nRealtime实时更新，环境光源会改变选择此项。\nBacked烘焙,环境光源不会改变选择此项。\n\n\n\n\n\n反射光照\n根据天空盒或立方体贴图计算的作用于所有物体的反射效果，通过Environment Lighting中Reflection控制。\nReflection Source反射源\nSkybox 天空盒\n\n\nResolution分辨率Compression 是否压缩\nCustom自定义\n\n\nCubemap立方体贴图\nReflection Intensity反射强度\nReflection Bounces使用Reflection Probe后允许不同游戏对象间来回反弹的次数。\n\n实时GIRealtime GI\n所谓”实时”是指在运行期间任意修改光源,而所有的变化可以立即更新。\n正是由于Unity 5引入了行业领先的实时全局光照技术Enlighten系统,才可以在运行时产生间接光照,使场景更为真实丰富。操作步骤:\n游戏对象设置为Lightmaping Static\n启用Lighting面板的Precomputed Realtime GI\n点击Build按钮(如果勾选Auto编辑器会自动检测场景的改动修复光照效果)\n\n\n\n烘焙GI烘焙Lightmap\n当场景包含大量物体时,实时光照和阴影对游戏性能有很大影响。使用烘焙技术,可以将光线效果预渲染成贴图再作用到物体上模拟光影,从而提高性能。适用于在性能较低的设备上运行的程序。\nLight 组件 Baking属性:烘培模式Realtime仅实时光照时起作用。\n-Realtime 仅实时光照时起作用。-Baked仅烘焙时起作用。-Mixed 混合,烘焙与实时光照都起作用。\n可以通过Scene面板Baked模式查看光照贴图。\n\n声音简介\nUnity支持的音频文件格式：\nmp3，ogg，wav，aif，mod，it，s3m，xm。\n\n声音分为2D、3D两类\n3D声音 : 有空间感，近大远小。\n2D声音：适合背景音乐。\n\n在场景中产生声音，主要依靠两个重要组件；\nAudio Listener音频监听器 ： 接收场景中音频源Audio\n\nSource发出的声音，通过计算机的扬声器播放声音\nAudio Source 音频源\n\n\nAudio Source\n音频源 ：\nAudio Clip 音频剪辑 ： 需要播放的音频资源。\nMute 静音 ： 如果启用，播放音频没有声音\nPlay On Awake 唤醒播放 ： 勾选后场景启动时自动播放。\nLoop 循环 ： 循环播放音频\nVolume 音量 ： 音量大小\nPitch 音调 ： 通过改变音调值调节音频播放速度。1是正常播放。\nStereo Pan ： 2D声音设置左右声道\nSpatial Blend ： 2D与3D声音切换\n\n\n\n3D Sound Settings\n3D声音设置\nVolume Rolloff 音量衰减方法\nMin Distance 开始缩减距离\nMax Distance 开始缩减距离\n\n\n\n","categories":["Unity/虚幻"],"tags":["unity"]},{"title":"XHTML","url":"/2022/12/27/WebFrontend/UI/XHTML/","content":"XHTML 简介什么是XHTML\n\nXHTML指的是可扩展性超文本标签语言（EXtensible HyperText Markup Language）。\nXHTML的目标是取代HTML。\nXHTML 与 HTML 4.01 几乎是相同的。\nXHTML是更严格纯净的HTML版本。\nXHTML是作为一种 XML 应用被重新定义的HTML\nXHTML是一个W3C标准。\n\n需要掌握的知识\nHTML\n基本的网站建设知识\n\nHTML、XHTML、XML与HTML5区别与联系\nxhtml：可扩展超文本标记语言，是一种置标语言，表现方式与超文本标记语言（HTML）类似，不过语法上更加严格。\nhtml5（h5）：更先由WHATWG（web 超文本应用技术工作组）命名的一种超文本标记语言，随后和W3C的xhtml2.0(标准)相结合，产生现在更新一代的超文本标记语言。可以简单理解为：h5 ≈ html + CSS 3 + js + API。\nXML：未来再进行讨论\nhtml特性：\n\n标识文本、建立超链接、创建列表、多媒体、制作表格表单等\n\nh5的认识：\n\n新特性应该基于HTML、CSS、DOM以及JavaScript\n\n减少对外部插件的需求（比如Flash）\n\n更优秀的错误处理\n\n更多取代脚本的标记\n\n\nh5新特性：\n\n用于绘画的canvas元素\n用于媒介回放的video和audio元素\n更具语义化的标签，便于浏览器识别\n对本地离线存储有更好的支持，可通过ofline实现\n新的特殊内容元素，比如article、footer、header、nav、section\n新的表单控件，比如calendar、date、time、email、url、search\n\nXHTML语法\nXHTML要求正确嵌套\nXHTML所有元素必须关闭\nXHTML区分大小写\nXHTML属性要用双引号\nXHTML用id属性替代name属性\nXHTML特殊字符的处理\n\nXHTML DTDXHTML 定义了三种文件类型声明。\n使用最普遍的是XHTML Transitional。\n&lt;!DOCTYPE&gt;是强制使用的一个XHTML文档有三个主要的部分：\n\nDOCTYPE\nHead\nBody\n\n&lt;!DOCTYPE ...&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;title&gt;... &lt;/title&gt;\t&lt;/head&gt;\t&lt;body&gt; ... &lt;/body&gt;&lt;/html&gt;\n\n在XHTML文档中，文档类型声明总是位于首行。\n一个XHTML的实例一个简单的（最小化的）XHTML文档：\n&lt;!DOCTYPE htmlPUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot;&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;title&gt;simple document&lt;/title&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;p&gt;a simple paragraph&lt;/p&gt;\t&lt;/body&gt;&lt;/html&gt;\n\n文档类型声明定义文档的类型：\n&lt;!DOCTYPE htmlPUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot;&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;\n\n文档的其余部分类似HTML：\n&lt;html&gt;\t&lt;head&gt;\t\t&lt;title&gt;simple document&lt;/title&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;p&gt;a simple paragraph&lt;/p&gt;\t&lt;/body&gt;&lt;/html&gt;\n\n3种文档类型声明\nDTD规定了使用通用标记语言（SGML）的网页的语法。\n诸如HTML这样的通用标记语言应该使用DTD来规定应用于某种特定文档中的标签的规则，这些规则包括一系列的元素和实体的声明。\n在通用标记语言（SGML）的文档类型声明或DTD中，XHTML被详细地进行了描述。\nXHTML DTD使用精确的可被计算机读取的语言来描述合法的XHTML标记的语法和句法。\n\nXHTML 1.0 Strict（严格模式）：\n&lt;!DOCTYPE htmlPUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;\n\n使用场景：需要干净的标记，避免表现上的混乱。与层叠样式表配合使用。\n严格 DTD 包含没有被反对使用的或不出现在框架结构中的元素和属性\nXHTML 1.0 Transitional（过度类型）：\n&lt;!DOCTYPE htmlPUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;\n\n使用场景：当需要利用HTML在表现上的特征时，并且上需要为那些不支持层叠样式表的浏览器编写XHTML时。\n过渡 DTD 包含严格 DTD 中的一切，外加那些不赞成使用的元素和属性\nXHTML 1.0 Frameset（框架类型）：\n&lt;!DOCTYPE htmlPUBLIC &quot;-//W3C//DTD XHTML 1.0 Frameset//EN&quot;&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd&quot;&gt;\n\n使用场景：需要使用HTML框架将浏览器窗口分割为两部分或更多框架时。\n框架 DTD 包含过渡 DTD 中的一切，外加框架\n详细参数请参考：XHTML参考手册\nXHTML的普及率在知名站点(在 Google 上搜索“A”时排名前 30)的随机样本中，只有1个站点(3%)仍然使用 XHTML。 自2000年1月XHTML 被推荐为HTML的下一代标准以来，已经过去了将近三年，但还不能说它已经变得非常流行，可能是因为转向 XHTML 并没有太大的优势。现在的情况。 \n顺便说一句，3个站点(10%)符合推荐的规范，例如 HTML 3.2&#x2F;4.0&#x2F;4.01，尽管存在一些错误，7 个站点 (23%) 尽管有 DOCTYPE 声明，但使用了浏览器特定的属性。19  个站点(63%)，包括雅虎、微软、网景、Adobe、NCSA 和 Amazon.com 等知名网站，不编写 DOCTYPE 声明，使用 HTML 有免费限制。  （2003 年 1 月调查） \n结论HTML 和 XHTML 都是用于创建网页和应用程序的标记语言。  HTML和XHTML一些使它们与众不同的关键区别，但它们也有一些相似之处。 XHTML是HTML的扩展版本，两种语言都用于开发基于 Web和Android 的应用程序。 \n虽然 HTML 可能更简单，但 XHTML 更结构化。  XHTML 旨在提高 HTML 的可扩展性和灵活性，使其更容易将 HTML 与其他数据格式（如 XML）集成。  因此，在做出决定时必须牢记每一方的优势和劣势。\n","categories":["WebFrontend"],"tags":["html"]},{"title":"序列化_特性","url":"/2022/08/25/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity/%E5%BA%8F%E5%88%97%E5%8C%96_%E7%89%B9%E6%80%A7/","content":"1. [SerializeField]让私有的和保护的也可以被显示\n[SerializeField]private int privateInt;[SerializeField]protected string protectedStr;\n\n \n2. [HideInInspector]公开的变量不会暴露到编辑器\n[HideInInspector]public int publicInt2 = 50;\n\n\n\n3. [System.Serializable]让自定义类型暴露到编辑器\n注意: 字典类型例外\n[System.Serializable]public struct MyStruct&#123;    public int age;    public bool sex;&#125;public class Test : MonoBehaviour&#123;    public MyStruct mystruct;&#125;\n\n \n4. [Header()]为成员分组\n[Header(&quot;分组说明&quot;)][Header(&quot;基础属性&quot;)]public int age;public bool sex;[Header(&quot;战斗属性&quot;)]public int atk;public int def;\n\n \n5. [Tooltip()]为变量添加说明\n[Tooltip(&quot;说明内容&quot;)]public int miss;\n\n \n6. [Space()]让两个字段之间出现间隔\n[Tooltip(&quot;说明内容&quot;)]public int miss;[Space()]public int crit;\n\n \n7. [Range(min, max)]限制数值范围\n[Range(0, 10)]public float luck;\n\n \n8. [ContextMenuItem(“显示按钮名”, “方法名”)] 为变量添加快捷方法\n  参数1 显示按钮名\n  参数2 方法名 不能有参数\n[ContextMenuItem(&quot;重置钱&quot;, &quot;Test&quot;)]public int money;private void Test()&#123;    money = 99;&#125;\n\n (右键参数)\n9. [ContextMenu(“测试函数”)]为方法添加特性能够在Inspector中执行\n[ContextMenu(&quot;Test&quot;)]private void TestFun()&#123;    print(&quot;测试方法&quot;);&#125;\n\n \n","categories":["Unity"],"tags":["Unity基础"]},{"title":"Update&FixedUpdate","url":"/2023/04/18/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity/Update&FixedUpdate/","content":"Updata 和 FixedUpdatarigbody组件不能写在Update函数里，要写在FixedUpdata里面\n\nUpdate()：每帧被调用一次\nFixedUpdate()：每隔Time.fixedDeltaTime被调用一次。\nMonoBehaviour.LateUpdate  晚于更新   当Behaviour启用时，其LateUpdate在每一帧被调用。LateUpdate是在所有Update函数调用后被调用。这可用于调整脚本执行顺序。例如:当物体在Update里移动时，跟随物体的相机可以在LateUpdate里实现。\n\nUpdate 和 FixedUpdate 区别update跟当前平台的帧数有关，而FixedUpdate是真实时间，所以处理物理逻辑的时候要把代码放在FixedUpdate而不是Update.\n​     Update是在每次渲染新的一帧的时候才会调用，也就是说，这个函数的更新频率和设备的性能有关以及被渲染的物体（可以认为是三角形的数量）。在性能好的机器上可能fps 30，差的可能小些。这会导致同一个游戏在不同的机器上效果不一致，有的快有的慢。因为Update的执行间隔不一样了。\n​     而FixedUpdate，是在固定的时间间隔执行，不受游戏帧率的影响。有点想Tick。所以处理Rigidbody的时候最好用FixedUpdate。\n​     PS：Time.fixedDeltaTime默认是0.02s，可以通过Edit-&gt;ProjectSettings-&gt;Time来设置\nUpdate和 LateUpdate的区别​     在圣典里LateUpdate被解释成一句话：LateUpdate是在所有Update函数调用后被调用。这可用于调整脚本执行顺序。例如:当物体在Update里移动时，跟随物体的相机可以在LateUpdate里实现。这句我看了云里雾里的，后来看了别人的解释才明白过来。\n​     LateUpdate是晚于所有Update执行的。例如：游戏中有2个脚步，脚步1含有Update和LateUpdate，脚步2含有Update，那么当游戏执行时，每一帧都是把2个脚步中的Update执行完后才执行LateUpdate 。虽然是在同一帧中执行的，但是Update会先执行，LateUpdate会晚执行。\n​     现在假设有2个不同的脚本同时在Update中控制一个物体，那么当其中一个脚本改变物体方位、旋转或者其他参数时，另一个脚步也在改变这些东西，那么这个物体的方位、旋转就会出现一定的反复。如果还有个物体在Update中跟随这个物体移动、旋转的话，那跟随的物体就会出现抖动。 如果是在LateUpdate中跟随的话就会只跟随所有Update执行完后的最后位置、旋转，这样就防止了抖动。\n​     做一个相机跟随主角的功能时，相机的位置调整写在LateUpdate（），老是不明白，看官方的SmoothFollow相机跟随写在Update（）中\n 资料参考链接：http://www.cnblogs.com/zhaoqingqing/p/3454091.html\n​                       http://www.cnblogs.com/zhaoqingqing/p/3296086.html\n","categories":["Unity"],"tags":["Unity基础"]},{"title":"从传统数据库到云数据库演进","url":"/2022/11/25/%E9%98%BF%E9%87%8C%E4%BA%91/ACA/%E4%BB%8E%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%B0%E4%BA%91%E6%95%B0%E6%8D%AE%E5%BA%93%E6%BC%94%E8%BF%9B/","content":"从传统数据库到云数据库演进该章节课程目的：\n\n了解数据库发展历史\n了解数据库的基本分类与应用场景\n掌握云数据库基本特征\n了解阿里云数据库整体概况\n\n数据库简介数据库发展历史\n\n\n时间\n基础设施\n应用场景\n数据库类型\n代表产品\n\n\n\n1950s\n大型机 &lt; 100台\n国防科学研究\n层次数据库网状数据库\nIBM IMS\n\n\n1970s\n小型机 &lt; 1万台\n大型商业处理\n关系型数据库\nDB2OracleIngres\n\n\n1990s\nPC机&#x2F;X86服务器&#x2F;局域网 &lt; 1亿台\n企业信息化：ERP&#x2F;CRM&#x2F;财务个人办公个人娱乐\n关系型数据库数据仓库PC单机数据库\nSQL ServerPostgreSQLTeradatadBase\n\n\n2000s\n互联网 &lt; 10亿台\n媒体搜索社交电子商务娱乐\n开源数据库\nMySQLRedisMongoDB\n\n\n2015\n云+端  &gt; 100亿台\n新媒体移动APP,OTO云计算物联网在线办公&#x2F;教育&#x2F;娱乐\n云数据库\nAWS         阿里云RDS          RDSAurora    PolarDBRedshift   AnalyticDB\n\n\n数据库分类\n\n\n\nOLTP\nOLAP\nNoSQL\n\n\n\n描述\n在线事物处理\n数据分析\n新数据模型\n\n\n典型场景\n银行交易、ERP、财务管理\n报表统计分析数据挖掘\n缓存数据管理图数据管理JSON文档数据管理\n\n\n业务特点\n高并发、低延迟数据请求处理\n海量数据统计分析\n通常是非关系数据模型\n\n\n代表产品\nOracleSQL ServerMySQL阿里云RDS阿里云PolarDB\nTeradataSnowflakeClickhouseAWS Redshift阿里云AnalyticDB\nRedisNeo4jMongoDBHBase阿里云Lindorm\n\n\n传统数据库与云数据库对比\n云是数据库最重要的发展方向\n\n2022预计75%的数据库都在云上\n\n2013年Leaders：Oracle、Microsoft、IBM、SAP\n\n2022年Leaders：AWS、Microsoft、Google、阿里云\nOracle、SAP、IBM、Teradata\n\n\n传统自建数据库管理的挑战：\n自建商业数据库：\n\n软件价格高\n运维压力大\n集中式设计，扩展性差\n技术体系封闭，对新数据模型支持弱\n\n\n自建开源数据库：\n\n运维压力大\n缺少商业服务保障\n可靠性、安全性难保障\n\n\n云数据库核心特征：\n\n自助服务开箱即用\n可快速弹性扩展\n按需计费\n服务保障安全稳定\n面向云计算架构设计\n\n\n\n\n\n传统数据库\n云数据库\n\n\n\n安装配置诊断优化\n需专业数据库人员操作\n可自助完成，开箱即用、简单高效\n\n\n弹性扩展\n弱，根据需求提前规划硬件网络投入，再加上数据迁移，通常需要数天\n强，可根据业务需求快速扩展，通常在分钟级可以一键完成\n\n\n计费模型\n购买License+服务费\n在线购买，可按需付费或包年包月\n\n\n服务保障安全保护\n需单独购买服务与安全保障\n内置服务保障，提供了更高的可用性SLA提供安全加密、备份恢复、操作审计等数据安全保障能力\n\n\n阿里云数据库介绍\n\n\n","categories":["阿里云ACA"],"tags":["DBMS"]},{"title":"日语","url":"/2022/08/30/%E7%A7%91%E5%AD%A6/%E4%BA%BA%E6%96%87%E7%A4%BE%E4%BC%9A%E7%A7%91%E5%AD%A6/%E6%97%A5%E8%AF%AD/","content":"IT日语\n\n\n\n日本語\n英語\n中国語\n\n\n\n\n1\nボタン\nbutton\n按钮\n\n\n\n2\nモバイル\nmobile\n移动通讯\n\n\n\n3\nインターネット\ninternet\n因特网\n\n\n\n4\nアンインストール\nuninstall\n卸载\n\n\n\n5\nダウンロード\ndownload\n下载\n\n\n\n6\nプラス\nplus\n加，正\n\n\n\n7\nロック\nlock\n加锁\n\n\n\n8\nアンロック\nunlock\n解锁\n\n\n\n9\nリターン·キー\nreturn key\n回车键\n\n\n\n10\nフォーマット\nformat\n格式\n\n\n\n11\nベース\nbase\n基极，库\n\n\n\n12\nスペース\nspace\n空格\n\n\n\n13\nシステム\nsystem\n系统\n\n\n\n14\nツール\ntool\n工具\n\n\n\n15\nコントロール\ncontrol\n控制\n\n\n\n16\nドライブ\ndrive\n驱动器\n\n\n\n17\nハードウェア\nhardware\n硬件\n\n\n\n18\nリサイクル\nrecycle\n再利用\n\n\n\n19\nメニュー\nmenu\n菜单\n\n\n\n20\nオンライン\nonline\n在线\n\n\n\n21\nパラメータ\nparameter\n参数\n\n\n\n22\nサポート\nsupport\n支持\n\n\n\n23\nフリーズ\nfreezes\n死机\n\n\n\n24\nイベント\nevent\n事件\n\n\n\n25\nトランザクション\ntransaction\n事务处理\n\n\n\n26\nフィールド\nfield\n字段\n\n\n\n27\nバイト\nbyte\n字节\n\n\n\n28\nマスタ\nmaster\n主\n\n\n\n29\nキャンセル\ncancel\n取消\n\n\n\n30\nサイクル\nCycle\n周期，循环\n\n\n\n31\nメッセージ\nmessage\n消息\n\n\n\n32\nフォーカス\nfocus\n焦点\n\n\n\n33\nアップロード\nupload\n上传\n\n\n\n34\nステータス·バー\nstatus bar\n状态栏\n\n\n\n35\nカンマ\ncomma\n逗号\n\n\n\n36\nデジタル\ndigital\n数字\n\n\n\n37\nデータ\ndata\n数据\n\n\n\n38\nデータベース\ndatabase\n数据库\n\n\n\n39\nクリア\nclear\n清除\n\n\n\n40\nサイズ\nsize\n大小\n\n\n\n41\nポート\nport\n端口\n\n\n\n42\nアドレス\naddress\n地址\n\n\n\n43\nコメント\ncomment\n注释\n\n\n\n44\nコミット\ncommit\n提交\n\n\n\n45\nプログラム\nprogram\n程序\n\n\n\n46\nクリック\nclick\n点击\n\n\n\n47\nログイン\nlog in\n登录\n\n\n\n48\nバッチ\nbatch\n批处理\n\n\n\n49\nテーブル\ntable\n表\n\n\n\n50\nウィルス\nvirus\n病毒\n\n\n\n51\nレイアウト\nlayout\n布局格式\n\n\n\n52\nサーバー\nserver\n服务器\n\n\n\n53\nファイル\nfile\n文件\n\n\n\n54\nフォルダ\nfolder\n文件夹\n\n\n\n55\nテキスト\ntext\n文本\n\n\n\n56\nドキュメント\ndocument\n文档\n\n\n\n57\nパスワード\npassword\n密码\n\n\n\n58\nテンプレート\nTemplate\n模板\n\n\n\n59\nモジュール\nmodule\n模块\n\n\n\n60\nユーザー\nuser\n用户\n\n\n\n61\nパス\npass\n路径\n\n\n\n62\nパソコン\npersonal computer\n个人电脑\n\n\n\n63\nデフォルト\ndefault\n默认\n\n\n\n64\nサイト\nsite\n网站\n\n\n\n65\nネットワーク\nnetwork\n网络\n\n\n\n66\nテンポラリファイル\ntemporary\n临时文件\n\n\n\n67\nキーワード\nkeyword\n关键词\n\n\n\n68\nマイナス\nminus\n减、负\n\n\n\n69\nプロセス\nprocess\n处理\n\n\n\n70\nアプリケーション\napplication\n应用程序\n\n\n\n71\nディスプレィ\ndisplay\n显示器\n\n\n\n72\nチェック\ncheck\n检查\nチェック\n\n\n73\nテスト\ntest\n测试\n\n\n\n74\nクラス\nclass\n类\n\n\n\n75\nタイプ\nTape\n类型\n\n\n\n76\nパターン\npattern\n模式\n\n\n\n77\nグループ\ngroup\n组件\nグループ\n\n\n78\nプログラミング\nprogramming\n编写程序\n\n\n\n79\nコード\ncode\n编码，代码\n\n\n\n80\nレコード\nrecord\n记录\n\n\n\n81\nログ\nlog\n记录，日志\n\n\n\n82\nセット\nset\n设置\n\n\n\n83\nアクセス\naccess\n访问\n\n\n\n84\nロジック\nlogic\n逻辑\n\n\n\n85\nリンク\nlink\n链接\n\n\n\n86\nエラー\nerror\n错误\n\n\n\n87\nキー\nkey\n键\n\n\n\n88\nキーボード\nkeyboard\n键盘\n\n\n\n89\nプロジェクト\nproject\n项目，工程\n\n\n\n90\nレビュー\nreview\n评论\n\n\n\n91\nスケジュール\nschedule\n日程表\n\n\n\n92\nプログラム\nprogram\n程序\n\n\n\n93\nラベル\nlabel\n标签\n\n\n\n94\nリスト\nlist\n目录\n\n\n\n95\nコピー\ncopy\n拷贝\n\n\n\n96\nメイン\nmain\n主要\n\n\n\n97\nテキストボックス\ntextbox\n文本框\n\n\n\n98\nセッション\nsession\n段，会话\n\n\n\n99\nメソッド\nmethod\n方法，方式\n\n\n\n100\n格納\nかくのう\n放置\n格納\n\n\n101\n仕様書\nしようしょ\n说明书\n\n\n\n102\n日付\nひづけ\n日期\n\n\n\n103\n新規\nしんき\n新的\n\n\n\n104\n情報\nじょうほう\n信息\n\n\n\n105\n目次\nもくじ\n目录\n\n\n\n106\n番号\nばんごう\n号码\n\n\n\n107\n桁\nけた\n位数\n\n\n\n108\n納品\nのうひん\n交货，交付\n\n\n\n109\n納期\nのうき\n缴纳期\n\n\n\n110\n参考\nさんこう\n参考，借鉴\n\n\n\n111\n参照\nさんしょう\n参照\n\n\n\n112\n拡張\nかくちょう\n扩展名，后缀\n\n\n\n113\n試験\nしけん\n测验\n\n\n\n114\n不具合\nふぐあい\n程序,文档的错误\n\n\n\n115\n進捗\nしんちょく\n进度\n\n\n\n116\n手順\nてじゅん\n操作顺序\n\n\n\n117\n弊社\nへいしゃ\n敝公司\n\n\n\n118\n御社\nおんしゃ\n贵公司\n\n\n\n119\n見積\nみつもり\n报价，估算\n\n\n\n120\n汎用\nはんよう\n通用\n\n\n\n121\n入力\nにゅうりょく\n输入\n\n\n\n122\n戻る\nもどる\n恢复，返回\n\n\n\n123\n一覧\nいちらん\n一览表\n\n\n\n124\n箇所\nかしょ\n地方，部分\n\n\n\n125\n遷移\nせんい\n跳转\n\n\n\n126\n基づく\nもとづく\n根据，基于\n\n\n\n127\n文字列\nもじれつ\n字符串\n\n\n\n128\n引数\nひきすう\n自变量，参数\n\n\n\n129\n取り込む\nとりこむ\n取得\n\n\n\n130\n要件\nようけん\n需求\n\n\n\n131\n繰り返す\nくりかえす\n重复\n\n\n\n132\n宣言\nせんげん\n声明\n\n\n\n133\n汎用\nはんよう\n通配符\n\n\n\n134\n並べる\nならべる\n排列\n\n\n\n135\n関数\nかんすう\n函数\n\n\n\n136\n異なる\nことなる\n不同\n\n\n\n137\n違う\nちがう\n不同，不对\n\n\n\n138\n添付\nてんぷ\n附带\n\n\n\n139\n表紙\nひょうし\n封面\n\n\n\n140\n分岐\nぶんき\n分支\n\n\n\n141\n戻り値\nもどりち\n返回值\n\n\n\n142\n破棄\nはき\n放弃、取消\n\n\n\n143\n障害\nしょうがい\n问题、错误\n\n\n\n144\n洗い出す\nあらいだす\n找出、跳出\n\n\n\n145\n伝送\nでんそう\n传送\n\n\n\n146\n受け渡す\nうけわたす\n传递\n\n\n\n147\n送信\nそうしん\n发送\n\n\n\n148\n変数\nへんすう\n变量\n\n\n\n149\n取り扱う\nとりあつかう\n处理\n\n\n\n150\n適用\nてきよう\n应用\n\n\n\n151\n問い合わせ\nといあわせ\n查询\n\n\n\n152\n照会\nしょうかい\n查询，核对\n\n\n\n153\n満たす\nみたす\n满足\n\n\n\n154\n組み合わせる\nくみあわせる\n组合\n\n\n\n155\n構造\nこうぞう\n结构\n\n\n\n156\n仕組み\nしくみ\n结构，方法，计划\n\n\n\n157\n編集\nへんしゅう\n编辑\n\n\n\n158\n読み込む\nよみこむ\n读入\n\n\n\n159\n行う\nおこなう\n进行\n\n\n\n160\n選ぶ\nえらぶ\n选择\n\n\n\n161\n論理\nろんり\n逻辑\n\n\n\n162\nやり取り\nやりとり\n交换，沟通\n\n\n\n163\n押す\nおす\n按下\n\n\n\n164\n依頼\nいらい\n委托要求请求\n\n\n\n165\n既に\nすでに\n已经\n\n\n\n166\n実行\nじっこう\n实行\nじっこう\n\n\n167\n結果\nけっか\n结果\n結果\n\n\n168\n書く\nかく\n写\n\n\n\n169\n同じ\nおなじ\n相同\n\n\n\n170\n通訳\nつうやく\n翻译\n\n\n\n171\n読み方\nよみかた\n读法\n\n\n\n172\n絞り込む\nしぼりこむ\n锁定，限定\n\n\n\n173\n本番\nほんばん\n正式\n\n\n\n174\n出し分け\nだしわけ\n分头\n\n\n\n175\n帳票\nちょうひょう\n账票，报表\n\n\n\n176\n従う\nしたがう\n根据，基于\n\n\n\n177\n繰り返し\nくりかえし\n循环，反复\n\n\n\n178\n切り替え\nきりかえ\n替换\n\n\n\n179\n送付\nそうふ\n发送\n\n\n\n180\n要望\nようぼう\n要求\n\n\n\n181\n上長\nじょうちょう\n上级\n\n\n\n182\n検討\nけんとう\n讨论\n\n\n\n183\n割り当て\nわりあて\n分配\n\n\n\n184\n先頭\nせんとう\n上头\n\n\n\n185\n読み取り\nよみとり\n读取\n\n\n\n186\n踏襲\nとうしゅう\n继承\n\n\n\n187\n排他\nはいた\n排斥\n\n\n\n188\n出荷\nしゅっか\n出厂，出库\n\n\n\n189\n太線\nふとせん\n太粗\n\n\n\n190\n不正\nふせい\n非法\n\n\n\n191\n保蔵\nほぞう\n保持．维持\n\n\n\n192\n出力\nしゅつりょく\n输出\n\n\n\n193\n転送\nてんそう\n转发\n\n\n\n194\n稼動\nかどう\n运行\n\n\n\n195\n共有\nきょうゆう\n共有\n\n\n\n196\n振替\nふりかえ\n转账\n\n\n\n197\n折り返し\nおりかえし\n返回\n\n\n\n\n呼び出す\nよびだす\n\n\n\n\n第1课言葉 ことば\nにほん　日本　　　　　　　　　　　　わたし　私                       いち　一\nちゅうごく　中国　　　　　　　　　　あなた　　　　　　　　　　　に　　二　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　\n～じん　　～人　　　　　　　　かれ　彼　　かのじょ　彼女　　　　さん　三　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　\nかいしゃ　会社　　　　　　　　　　　あのひと　あの人　　　　　　よん　四　し\nかいしゃいん　会社員　　　  　　　せんもん　専門　　　　　　　ご　　五　　　　　　      　　　　　　　　　　　　　　　　　　　　　　　　　\nしゃいん　社員　　　　　　　　　　　コンピューター　　　　　　　ろく　六　　　　　　　　　　　　　　　　　　　　　　　\nきぎょう　企業　　　　　　　　　　　じどうしゃ　自動車　　　　　なな　七　しち　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　\nかちょう　課長　　　　　　　　　　　なまえ　名前　　　　　　　　はち　八　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　\nしゃちょう　社長　　　　　　　　　　ゼロ　　　　　　　　　　　　きゅう九      く                   　　\nしりょう　　資料　　　　　　　　　　おきゃくさま　お客様　　　　じゅう十\nさいしんばん　最新版　　　　　　　　かいはつぶ　開発部\nプロジェクト　　　　　　　　　たんとう　担当　　　てんぷファイル　添付ファイル　\n～さん　　劉さん　徐さん　高さん\n判断句\n陈述句\n存在句\n描写句\n文型　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　\nわたしは中国人です。　　　　　　　　　彼は　課長です。　\nあなたは日本人ですか。　　　　　　　　劉さんは　開発部の人ですか。\nあの人は会社員ではありません。　　田中さんは～～プロジェクトの担当ではありません。　\n林さんはトヨタ自動車の社員です。　　　\n本文\nわたしは王です。中国人です。\n李さんも中国人です\nわたしの専門はコンピューターです。　\n林さんは日本人ですか\nはい　そうです\n林さんは中国人ですか\nいいえ　中国人ではありません　日本人です\n林さんは何歳ですか\n28（歳）です\n文法\n１～は～です 助詞は的用法\n 相当于汉语的～是～　は是主语部分  です是谓语部分\n例：\nわたしは中国人です \nあの人は　李さんです。\n李さんは　会社員です。\n李さんは　教師では　ありません\n２～は～では　ありません\n　 相当于汉语的 ～不是～\n例　：\nわたしは日本人ではありません\n張さんは　エンジニアでは　ありません。\n３～ですか\n例：\n李さんは　中国人ですか\nはい　中国人です\nいいえ　中国人ではありません。日本人です。　　　\nあなたは日本人ですか\nはい　そうです\nいいえ　そうではありません　ちがいます　違います　中国人です \n４助詞の的用法\n连接两个名词 相当于汉语“的”\nわたしの専門　　中国の自動車　　　                         \nトヨタは　日本の車です。くるま\nベルリンは　ドイツの首都ですか。\n李さんは　北京大学の　学生です。\n　　\n５助詞も的用法                                   \n有条件的提示主语 具有强调作用 相当于汉语“也”\n例　王さんは中国人です　李さんも中国人です\n6日语 100以内的数法　\n上海も　中国の町ですか\nはい　そうです。\n李さんの趣味は　魚釣です。\n北京は　アメリカの町ではありません。\n会社の名前はトヨタ自動車です。　\n練習\n1 小李是公司职员   李さんは　会社員です。\n2公司的名字是丰田汽车　会社のなまえ（名前）はトヨタ自動車です。\n3小李的专业是计算机吗？　李さんの専門は　コンピューターですか　はいそうです\n 是 是的\n4小王也是公司职员吗？　王さんも会社員ですか　いいえ、違います。学生です\n北京ではありません。\n 不 不是 是学生　\n わたしは中国人です。　　　　　　　　　彼は　課長です。　\nあなたは日本人ですか。　　　　　　　　劉さんは　開発部の人ですか。\nあの人は会社員ではありません。　　田中さんは～～プロジェクトの担当ではありません。　\n林さんはトヨタ自動車の社員です。　　　\n第2课言葉                                                               \nこれ　　　　　　　　　　　　　たばこ　煙草　　タバコ　　　　　だれ　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　\nそれ　　　　　　　　　　　　　いす　　椅子　　　　　　　　どなた　　　　　　　　　　　　　　　　　　　　\nあれ　　　　　　　　　　　　　つくえ　机　　　　　　　　　なん　何　　　　　　　　　\nこの　　　　　　　　　　　　　まど　　窓　　　　　　　　　どの　　　　　　　　　　　　　　　　　　　　　　　　　\nその　　　　　　　　　　　　　ドア　　　　　　　　　　　　どれ　　　　　　　　　　　　　　　　　　　　　　　　　　　\nあの　　　　　　　　　　　　　テレビ　　　　　　　おねがいします　お願いします　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　\nほん　本　　　　　　　　　　　パソコン　　　　　　　　　　どうぞ　　　　　　　　　　　　　　　　　\nでんわ　電話　　　　　　　　　ノート　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　\nけいたい携帯　　　　　　　　　とけい　時計　　　　　　　　しゃしん　写真　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　\nライター　　　　　　　　　　　かみ　　紙　　　　　　　　　カメラ\nつうやく　通訳　　　　　　　　えいぎょうぶ　営業部　　　　\nにっていひょう　日程表　　　　じどうしゃ　自動車　　\n人　ひと　　扉　とびら\n先生の本は　どれですか\nこれです。\nどの本　　李さんは　どの人ですか　\n文型\nこれは本です\nあの人はだれですか\nこの携帯はわたしのです\n本文\nこれはテレビですか\nいいえ　パソコンです\nそれは　何ですか\n（これは）わたしの本です\nそのライターは　だれのですか\nわたしのです\nこの携帯はあなたのですか\nいいえ　わたしのではありません\n文法\n１これ、それ、あれ、どれ\nこれ　指示离说话者近的东西时使用\nそれ 指示离听话者近的东西时使用\nあれ 指示离说话者 听话者都远的东西时候使用\n李さんのカメラは　どれですか\nこれです。\n李さんの車はどれですか　　　あれです。\n例：これは本です\nそれは　李さんの携帯ではありません。\nこれは　日本の新聞ですか。\nはい、　それは日本の新聞です。\nそれは　北京の写真ですか。\n先生の本はこれです。\nこれは　李さんの　パソコンです。\n孫さんの携帯は　これです。　\n２この　その　あの　　どの\n指示连体词 远近关系与これ、それ、あれ相同 不同的是不能单独使用 一定后续名词\n例：この本　その机　　あの人　　　\nこの携帯は　孫さんのです\nその本は　日本の　小説ではありません\n車の雑誌は　あの本ではありません。\nこのカメラは　日本産ではありません。\nどの本　　どの車　　どのパソコン　どの国\nどの人\n　李さんは　どの人ですか。\n　白夜行は　どの本ですか。\n　この本は　日本の小説です。\n　あの人は　李さんです。\nこの本はわたしのです\n３疑问词的使用\n句中有疑问词的句子回答是不用はい　いいえ\n例：\n　これは　何ですか\n　それは　先生の本です。　\n　　これは　だれの写真ですか。\n　　李さんのです。\n　　この方は　どなたですか。　　このかた　　この人はだれですか\nこれは何ですか\n　　先生の本です\n　これは　だれのパソコンですか。\n　李さんのです。\nこのノートは　李さんのではありません。\n４形式名词の的使用\n表示所有的の后续名词省略时如不影响意思的表达时 则多省略\n例：\nこれは　あなたの本ですか\nはい　わたしのです。\nこの本は　私のではありません\n何歳　なんさい　　李さんは　何歳ですか　　　２０歳です。\n何枚　　何階　　何曜日　　何本　　何時間\n練習\n1这本书不是我的\n2那是什么？ 这是我的电话\n3那是谁的伞？是我的\n4这是我的相片\n1　これは　だれの写真ですか　\n2　それは　何ですか　李さんの本です\n3　この携帯は　李さんのですか　いいえ　王さんのです。\n4　このパソコンは　だれのですか　　　李さんのです。\nあたらしい\n​      \nデータ　　コード　バグ　サイズ　コーディング　テスト　コメント　ツール　\nロジック　メール　データベース　テーブル　チェック　テンプレート　　タイトル\nリクエスト\n第3课言葉　　　　\nここ　　　　　　　　　　　　うけつけ　受付　　　　　　　　にちようび　日曜日　　　　　　　　　　　　　　　　　　　　　　　　　\nそこ　　　　　　　　　　　　トイレ　　　　　　　　　　　　げつようび　月曜日　　　　　　　　　　　　　　　\nあそこ　　　　　　　　　　　コンビニ　　　　　　　　　　　かようび　　火曜日　　　　　　　　　　　　　\nこちら　　　　　　　　　　　ぎんこう　銀行　　　　　　　　すいようび　水曜日　　　　　　　　　　　　　　　　　　　　　　　　　　\nそちら　　　　　　　　　　　ゆうびんきょく　郵便局　　　　もくようび　木曜日　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　\nあちら　　　　　　　　　　　びょういん　病院　　　　　　　きんようび　金曜日　　　　　　　　　　　　　　　　　　　　　　　　　\nじむしょ　事務所　　　　　　スーパー　　　　　　　　　　　どようび　　土曜日　　　　　　　　　　　　　　　　　　　　　　　　　　　　　\nしょくどう　食堂　　　　　　デパート　　　　　　　　　　　なんようび　何曜日　　　　　　　　　　　　　　　　　　　　　　　　\nくに　国　　　　　　　　　　へや　部屋  の鍵 かぎ　　　　どこ　　　　いくら\n食事\n文型\nここはコンビニです  \nトイレはどこですか\nこれは二万円ですか　三万円ですか\n本文\nトイレは　どこですか\nあそこです\nここは郵便局ですか　銀行ですか\n銀行です\nあなたの会社は　どちらですか　　トヨタ自動車です\nそれはどこの時計ですか\n日本の時計です                                                        \nこの時計はいくらですか                                 \n28000円です                                                          \n文法\n1场所 地点指示代词ここ　そこ　あそこ的使用\n与指示事物的これ　それ　あれ的远近关系一样\nこちら　そちら　あちら是　ここ　そこ　あそこ的礼貌体\nここの味　どちら\nこちらこそ\nあそこは　デパートではありません。\nコンビニは　ここです。\nこちらは　教室です\nあちらは　会社の食堂です。\nトイレは　そこです。\n​                                                                                             \n2疑问词   どこ　どちら的使用　どれ\nどこですか\n例　会社はどこですか是问公司的地址　会社はどちらですか 一般是问公司的名字\n食堂は　どこですか。　　教室の隣です。きょうしつ　となり\n張さんは　どこですか　　　窓の所（ところ）です\n于さんの本は　どこですか　　机の上（うえ）です。\n李さんの傘（かさ）は　どこですか　　ここです　\nトイレは　どちらですか\n君（きみ）の国は　どちらですか。中国です\n君の会社は　どちらですか。\n3 疑问句的选择表述\nここはスーパーですか　デパートですか　　それとも\nこの本は　李さんのですか　王さんのですか。　　王さんのです。\nこの小説は　日本のですか　中国のですか　　日本のです。\nこのカメラは　いくらですか　　　３万円です。えん　元　げん\n答案有多种可能 而询问一种时可以反复使用（～ですか）回答时选择一个就可以了这时不用はい或　いいえ来回答\n4 100以上的数字\n 100 ひゃく　200　にひゃく　300　さんびゃく　400　よんひゃく　500　ごひゃく\n600　ろっぴゃく　700　ななひゃく　800　はっぴゃく　900　きゅうひゃく\n1000　せん　2000　にせん　3000　さんぜん　4000　よんせん　5000　ごせん\n6000　ろくせん　7000　ななせん　8000　はっせん　9000　きゅうせん\n10000　いちまん　100000　じゅうまん　100000000　いちおく\n練習\n１小李在哪？在食堂\n2这台电视多少钱？\n3公司的名字是什么？\n4卫生间在哪？ 在那里\n5 这里是小李的房间\n第4课言葉\nおきる　　　　起きます　　　　　　あさ　朝　　　　　　　　　しごと　仕事　\nねる　　　　　寝ます　　　　　　　ひる　昼　　　　　　　　　ちこく　遅刻　　　　　　　　　　\nはたらく　　　働きます　　　　　　よる　夜 　晩　ばん　　　　しゅっちょう　出張\nやすむ　　　　休みます　　　　　　おととい　一昨日　　　　　りょこう　旅行\nべんきょうする　勉強します　　　　　きのう　昨日　　　　　　　やすみ　休み　　　　　　　\nいま　今　　　　　　　　　　　　　きょう　今日　　　　　　　いつも 副词　　　　　　\n～じ　～時　　　　　　　　　　　　あした　明日　　　　　　　～から\n～ふん～分　　　　　　　　　　　　あさって　明後日　　　　　～まで\nはん　半　　　　　　　　　　　　　けさ　　今朝\nなんじ　何時　　　　　　　　　　　こんばん　今晩\nなんぷん　何分　　　　　　　　　　まいあさ　　毎朝　　　　　　\nごぜん　午前　　　　　　　　　　　まいばん　　毎晩　\nごご　　午後　　　　　　　　　　　まいにち　　毎日　　一時半\n使う　　　　　　使い\n明日は　休みです。\nいつ　　　　何時\n毎朝　いつ　　起きますか\n会議は　いつ　始まりますか\nいつも　わたしは　　六時に起きます。　　　　　　　　　　　　　　　　　　　　　　　　　\n一時半\n今　何時ですか\nいつもの所\n文型\n今　一時十分です\nわたしは　朝　六時に起きます\n毎日　九時から　六時まで　働きます\nわたしは　きのう　勉強しました\n本文\n今　何時ですか\n４時五分です\n朝　６時に起きます\n毎日　九時から　六時まで　働きます\n仕事は　何時からですか\n八時半からです\nあした　働きますか\nはい　働きます\nいいえ　働きません\n昨日　勉強しましたか\nはい　勉強しました\nいいえ　勉強しませんでした\n文法\n１陈述句 动词做谓语\n动词的分类\n以变化规律分4类\n五段动词 　以う、く、ぐ、す、つ、ぬ、ぶ、む、る结尾 词尾都在う段上 以る结尾时 る前假名不能在い段或え****段　　行く\n一段动词 　以る结尾 る前假名在い段或え****段　みる　見る　かける掛ける　　　食べる\nサ变动词 　词尾是****する 词干是具有动作倾向的名词 する是最简单的サ****变动词  散歩する　　散歩 　　　魚釣する\nカ变动词 　只有一个　くる（来る）\nいく　行く　かう　買う　かす　貸す　読む　よむ　遊ぶ　あそぶ　泳ぐ\nおよぐ　まつ　待つ　しぬ　死ぬ　聞く　きく　はなす　話す\n切る　きる　　着る\nかかる　　始める　つくる　　くる　　勉強する　　　つける　はじまる　おわる　いれる　あげる　離れる　起きる　働く　\n帰る　かえる　へる　減る　はいる　入る　きる　切る　はしる　走る　　滑る　すべる　しる　知る　にぎる　握る　限る　かぎる　しげる　茂る\nおおきい\nコピー　する　　　キャンセルする\nよむ　かう　かす　いそぐ　たつ　\nつくる　作る　　修理する　　起きる　あげる　始まる　倒れる　さぼる\nへる　減る　きる　切る　帰る　かえる　はいる　入る　はしる　走る　しる　知る　すべる　滑る　要る　いる　にぎる　握る\n書く　かく　いそぐ　急ぐ　いう　言う　かす　貸す　たつ立つ　\nはじまる　　始まる　かける　掛ける　かかる　掛かる　ゆずる\n譲る　くる　来る　食べる　たべる　つくる　作る　しめる　　閉める　起きる　おきる　いく　行く　しかる　叱る　つもる　積もる　しげる　茂る\n連用形１　　ます\nくる　　きます\nする　　します　　　勉強する　　勉強します\nみる　　みます　　つける　つけます\nあいうえお\nかきくけこ\nさしすせそ\n買う　　買います　行く　行きます　いきます　　いきる　生きる　泳ぐ　泳ぎます　貸す　　貸します　　まつ　待ちます　　死ぬ　死にます　遊ぶ　遊びます　　飲む　飲みます　つくる　　作ります 作る　つくります\nすわる　座る　　はしる　走ります　はなす　話す\n行く　　行きます\nはなす　話す　　こわれる　壊れる　わかる　分かる　運動する\nくる　　立つ　たつ　たちます　　はしる　走る\nよむ　　かえす　　きく　さんかする　くる　たべる　はこぶ　かつ\n勝つ　かつ　　よむ　読む　　書く　かく　　いそぐ　急ぐ　\n貸す　　かす　　買う　かう　　はこぶ　運ぶ　　見学する　\nのむ　すわる　座る　　たおす　　倒す\n行く　　行きます　　いきます\n2 助词 に的用法 提示时间点 放到具有数字性的时间点\n　　いつも　わたしは　今日　六時に　起きます。\n　　　　　　　　　　　　　　　　　起きません\n昨日　わたしは　　六時に　起きました\n　　　　　　　　　　　起きませんでした\n例 朝　６時に　起きます\n李さんは　五月五日に結婚しました\n李さんは　いつも　１０時に　寝ます。\n　\n3　助詞　から　まで的用法\nから表示时间 地点的起点\nまで表示时间 地点的终点\n相当于汉语的“从～”“到～”  \n例　わたしは　九時から　五時まで　勉強します。\nこれは　母さんからの手紙です。\n　　\nわたしは　九時から　勉強します\nわたしは　五時まで　勉強しました　　勉強します\nわたしの仕事は　九時から　五時までです　　　\nわたしは　九時から　五時まで　働きます。\n仕事は　五時までです　　仕事は　5時に　終わります。\nます的变化\n4　日语的动词有时态上的变化\n\n\n\n\n非过去\n过去\n\n\n\n肯定\n起きます\n起きました\n\n\n否定\n起きません\n起きませんでした\n\n\n例　毎朝　六時に　起きます\n　　昨日　六時に　起きました\n5 时间的表述\n\n\n\n一時　　いちじ\n四時　　よじ\n七時　　しちじ\n十時　　じゅうじ\n\n\n\n二時　　にじ\n五時　　ごじ\n八時　　はちじ\n十一時じゅういちじ\n\n\n三時　　さんじ\n六時　　ろくじ\n九時　　くじ\n十二時　じゅうにじ\n\n\n\n\n\n一分　いっぷん\n四分　よんふん\n七分　ななふん\n十分　じゅっぷん\n\n\n\n二分　にふん\n五分　ごふん\n八分　はっぷん\n十一分じゅういっぷん\n\n\n三分　さんぶん\n六分　ろっぷん\n九分　きゅうふん\n二十五分にじゅうごふん\n\n\n\n\n\n三十分　さんじゅっぷん\n\n\n点\n練習\n１每天的工作是从9点到6点\n2 每天早晨5点半起床\n3 昨天干活到了8点\nよむ　読む　はなせる　話せる　　換える　かえる　　\n日本語の勉強は　いつも　１０時からです。\nわたしは　昨日　１０時まで　残業しました。ざんぎょう\nわたしは　毎日　９時から　働きます。\nわたしは　今日から　働きます。\n第5课言葉\nいく　行きます　　　　　　　　　ひと　人　　　　　　　　　　らいげつ　来月　　　　　　　　　　　　　　　　　　　\nくる　きます　　　　　　　　　　ともだち　友達　　　　　　　きょねん　去年　　　　　　　　　　　　　　　　　\nかえる　帰ります　　　　　　　　こいびと　恋人　　　　　　　ことし　　今年　　　　　　　　　　　　　　　　　\nこうじょう　工場　　　　　　　～ばんせん　～番線　　　　　　らいねん　来年　　　　　　　　　　　　　　　　　　　　\nえき　駅　　　　　　　　　　　　たんじょうび　誕生日　　　　　　　　　　　　　　　　　　　　　　\nひこうき　飛行機　　　　　　　　うち　家　　　　　　　　　　～がつ　～月　　　　　　　　　　　　　　　　　　　　　　　　\nふね　船　　　　　　　　　　　　いえ　家　　　　　　　　　　～にち　～日　　　　　　　　　\nでんしゃ　電車　　　　　　　　　せんしゅう　先週　　　　　　なんがつ　何月　　　　　　　　　　　　　　　　　\nバス　　　　　　　　　　　　　　こんしゅう　今週　　　　　　なんにち　何日　　　　　　　　　\nタクシー　　　　　　　　　　　　らいしゅう　来週　　　　いつ　だれ　どこ　なに　　　　　　　　　　　　　　　　　　　　　　　　　\nちかてつ　地下鉄　　　　　　　　せんげつ　　先月　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　\nしんかんせん　新幹線　　　　　　こんげつ　　今月\nいつも　　何時におきますか\n空港　くうこう\nくるま　しゃ　車\n君の誕生日は　いつ　ですか　　わたしの家　　家の車\n文型　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　\nわたしは　スーパーへ　行きます\nわたしは　地下鉄で　家へ　帰ります\nわたしは　友達と　日本へ　来ました\n本文\nあした　どこへ　行きますか\n東京へ　行きます\nきのう　どこへ　行きましたか\nどこ「へ」も　行きませんでした\n毎日　バスで　会社へ　行きます\n日曜日　友達と　デパートへ　行きました\nいつ　日本へ　来ましたか\n九月に　来ました\n文法\n１助词 へ　え的用法 放在表示地点的名词后表示方向 助词 へ后是表示移动的动词　　行く　来る　帰る\n例　わたしは　家へ帰ります これは　母さんへの手紙です\n李さんは　先月　大連へ　来ました。\n李さんは　今日　会社へ　行きませんでした。\n日曜日　どこへ　行きましたか。\n火曜日　大連へ帰りますか\n先週　飛行機で　大連へ来ました。\n明日　映画館へ　行きませんか　　明日　映画館へ　行きますか。\nはい　行きません\nいいえ　いきます　　いいえ　行きません\n２助词で 的用法 表示使用的方法手段 放在交通工具的名词后 表示利用这个交通工具\n例　飛行機で　日本へ行きます\n昨日　タクシーで　会社へ行きました。\n日曜日　バスで　大連へ帰りました。\n5月５日に　船で　大阪へ来ました。\n毎日　何で　学校へ　行きますか。\n３助词も 的用法 放到疑问词后 后续否定 表示完全的否定\n例　日曜日　どこ「へ」も行きませんでした。\n　　日曜日　どこへ行きましたか。\n　　図書館へ行きました。　　\n　　　何も　食べませんでした。\n４助词 と的用法 表示人的名词后接 表示和（谁）一起做  \n林檎りんごとバナナ　　　机といす　　\n例　わたしは　李さんと　飛行機で　東京へ行きます\nわたしは　王さんと　毎日　地下鉄で　会社へ行きます。\n　　　と　　　　は　　　　　\nいつも　王さんと　いっしょに　家へ帰ります\nから　　\nまで\n日曜日　日本から　中国まで　船で　行きます。\n李さんは　五月５日に　中国から　来ました。\n日本まで　何で　来ましたか\nごろ\nわたしは　六時ごろ（に）　起きます。\n今　5時ごろです。頃\n５日语的日期\n月份：\nいちがつ 一月　　にがつ　二月　さんがつ　三月　しがつ　四月　\nごがつ　 五月  ろくがつ　六月　しちがつ　七月　はちがつ　八月　\nくがつ　九月　 じゅうがつ　十月　じゅういちがつ　十一月　\nじゅうにがつ　十二月\n日期：\nついたち 一日　ふつか 二日　みっか　三日　よっか　四日　いつか　五日　むいか  六日　なのか　七日　ようか　八日　ここのか九日　とおか　十日 じゅういちにち　十一日　じゅうににち十二日　じゅうさんにち　十三日 じゅうよっか　  十四日　じゅうごにち　十五日　じゅうろくにち　十六日 じゅうしちにち　十七日　じゅうはちにち　十八日　じゅうくにち　十九日    はつか 二十日　 にじゅういちにち　二十一日　 にじゅうににち　二十二日\nにじゅうさんにち  二十三日　   にじゅうよっか 二十四日\nにじゅうごにち　二十五日   にじゅうろくにち　二十六日　\nにじゅうしちにち　二十七日　  にじゅうはちにち　二十八日\nにじゅうくにち　二十九日　    さんじゅうにち  三十日　\nさんじゅういちにち　三十一日\n６动词ます型　辞書型的活用　    \n\n\n\n类别\n辞書型\n\nます型\n\n\n\n一类动词  （五段动词）\nかく  およぐ  だす  まつ  しぬ　  あそぶ  のむ  うる  かう\n書く  泳ぐ  出す  待つ  死ぬ        遊ぶ  飲む  売る  買う\nかきます  およぎます  だします  まちます  しにます  あそびます  のみます  うります  かいます\n\n\n二类动词  （一段动词）\nおきる  たべる\n起きる  食べる\nおきます  たべます\n\n\n三类动词  (サ变动词)  (カ变动词)\nする  べんきょうする  くる\n勉強する  来る\nします  べんきょうします  きます\n\n\n阅读\n わたしは　中国の李です。先月15日に　日本へ　来ました。　専門は　コンピューターです。　きのう　わたしは　林さんと　東京へ行きました。　\n東京まで　バスで　行きました。6時に　タクシーで　帰りました。\n練習\n１和恋人坐飞机去北京\n２小李上个月从上海来的\n３星期天 哪儿也不去\n第6课言葉\nたべる　食べます　　　　ごはん　ご飯　　　ジュース\nのむ　　飲みます　　　　パン　　　　　　　ビール\nすう　　吸います　　　　たまご　玉子　　　さけ　「お」酒\nかく　　書きます　　　　にく　　肉　　　　みず　　水\nよむ　　読みます　　　　さかな　魚　　　　くつ　　靴\nきく　　聞きます　　　　やさい　野菜　　　えいが　映画\nみる　　見ます　　　　　ミルク　　　　　　いっしょに\nかう　　買います　　　　おちゃ　お茶　　　なに　　何　\nする　　します　　　　　コーヒー 　　　　　それから　 \n散歩する\n玉子\n今朝は　お粥を食べました\n文型\nわたしは　コーヒーを　飲みます。\nわたしは　デパートで　靴を買いました\nここで　休みましょう　　　いいですよ　行きましょう。\nよ　ね\n本文\nあなたは　たばこを吸いますか\nいいえ　吸いません\n毎朝　何を食べますか\nパンと卵を食べます\n昨日　日本語を勉強しました。それから　映画を見ました。\n日曜日　大阪で　ご飯を食べました。\n文法\n1助词 を的用法　他动词 自动词\n開ける　開く ドアを　開けます　　わるい\n表示提示宾语 和动词一起组成动宾关系\n例　ご飯を食べる　　ジュースを飲む　　テレビを見る\n明日　李さんと　日本料理を食べます。\n昨日　　日本語の小説を読みました。\n日曜日　何をしましたか します\n2助词で的用法\n表示动作进行的场所 相当于汉语在哪里做什么\nデパートで　靴を買いました\nわたしは　いつも　会社の隣の店で　昼ご飯を食べます。ランチ\n李さんは　毎朝　家で　新聞を　読みます。\n李さんは　毎晩　７時から　テレビを見ます。\n日曜日　家で　ご飯を食べませんでした。\n土曜日　李さんと　公園で　写真を撮りました。\n日曜日　何をしましたか。　　スーパーで　肉を買いました。\n今朝　何を　食べましたか。　　何も　食べませんでした。\n３　なん和なに的区别\n何　　何\n两者意思一样都是 什么的意思\n（１）后续で　の　と时读なん　\n（２）后续量词（事物的单位）时读なん\n以上两种情况以外都读なに\n何時　何歳　何曜日　何日　何回　何杯　何枚\n阅读\nわたしは　毎日　教室で日本語を勉強します　日本語の勉強は午後の2時から3時までです。　きのう　わたしは　友達と大連で映画を見ました。映画の名前は「～～」です。映画は6時までです。　それから　いっしょに　晩ご飯を食べました。\n練習\n1 我星期日吃了鱼\n2 在哪里买的这双鞋？\n3 我昨天看了日本电影\n4小李不喝啤酒\n第7课言葉 ことば\nきる　切ります　　　　　　　　　　　　おはし　お箸　　　　　　　　　　もう　　　　　　　　　　　　　　\nしゅうりする　修理します　　　　　　　はな　花　　　　　　　　　　　　まだ　\nかける　電話をかけます掛ける　　　　　おかね　お金\nあげる　あげます　　　　　　　　　　　レポート\nもらう　もらいます　　　　　　　　　　チケット　　きっぷ　切符\nおしえる　教えます　　　　　　　　　　スケジュールひょう　スケジュール表\nならう　　習います　　　　　　　　　　ファックス\nかす　　貸します　　　　　　　　　　　メール　\nかりる　借ります　　　　　　　　　　　プレゼント\nおくる　送ります　　　　　　　　　　　\n手紙てがみを送ります　　にもつを送ります　荷物\n文型\nわたしは李さんに時計を　あげます\nわたしは　林さんに　お金を　もらいました\n本文\nわたしは箸で　ご飯を食べます\n李さんに電話をかけます\n誕生日に　父から　プレゼントをもらいました\nわたしは　母に　時計をあげます\n文法\n１助词で的用法\n表示使用的方法手段 相当汉语的【使用~】\n包丁（ほうちょう）で　肉を切ります。 鋏（はさみ）で　紙を切ります。\n箸で　ご飯を食べる　　　パソコンで　レポートを書く\n日本語で　手紙を書きます\nアメリカ人は　ナイフと　フォークで　ご飯を食べます。\n携帯で　写真を撮る　食堂で　ご飯を食べる\n２助词に在授受关系的句子中使用\n①  表示事物给予的对象\n　　わたしは　　父さんに　ご飯を作ります\n例　李さんは　王さんに　電話をかけました\n　母さんは　父さんに　ご飯を作りました。\n　わたしは　部屋で　李さんに　携帯で　写真を送ります、\n　わたしは　公園で　李さんに　写真を撮ります。\nあげる\n王さんは　李さんに　誕生日に　プレゼントをあげました。\n　　わたしは　父に　お金を　あげます\n　　わたしは　母さんに　兄さんの写真をあげました。\nくれる\n　　日本は　我が国に　先進の技術をくれました。\n　　王さんは　わたしに　　自転車をくれました。じてんしゃ\n　　劉さんは　誕生日のプレゼントをくれませんでした。\nください　くださる　くださいます\nこれをください\nすみません　最新の資料をくださいませんか\n教える\n　　わたしは　于さんに　日本語を教えます\n　　わたしは　李さんの住所を　張さんに　教えました。\n貸す\n　　自転車を　だれに　貸しましたか。\n　　　わたしは　お金を　王さんに　貸しました。\n②    表示事物的出处方\nもらう\n　わたしは　于さんから　李さんの写真を　もらいました。\n　李さんは　張さんに　お金を　もらいました。\nわたしは　李さんに　映画のチケットをもらいました。\n習う ならう\n　わたしは　李先生に　日本語を習います\n崔先生に日本語を習います。\n借りる\n　わたしは　李さんに　（じてんしゃ）自転車を借りました。\n　李さんは　わたしに　自転車を　貸しました。\n　　会社から　ボーナスをもらいました。\n  于さんは　侯さんからお金を借りました。\n　李さんは　王さんに　自転車を貸しました。\n　\n副詞もう相当汉语的【已经】　まだ相当汉语的【还没】\n例　もう　昼ご飯を　食べましたか\n　　はい　もう　食べました。\n　　いいえ　まだ 食べません\n　この小説を　もう　読みましたか。\n　いいえ　まだです。\n阅读\n明日は　李さんの誕生日です。　昨日　わたしは　デパートで時計を　買いました。明日　李さんにあげます。\n今日は　わたしの誕生日です。　わたしは　崔先生に　時計をもらいました。\n練習\n1我用日语写报告\n2 我给公司发邮件（短信）。\n3 我从公司接到传真了\n4 小李已经回家了\n5 美国人用刀叉吃饭\n6 用传真发日程表给田中科长\n7 给小李用日语发邮件\n8从小李那得到了北京地图\n9 向小李借了小张的字典\n10把电影票给谁了？\n11 要向谁借自行车\n12 和小李学日语\n第8课言葉\nおおきい　　大きい　　　　たかい　　　高い　　　　　　はる　　春\nちいさい　　小さい　　　　ひくい　　　低い　　　　　　なつ　　夏　　\nあたらしい　新しい　　　　やすい　　　安い　　　　　　あき　　秋\nふるい　　　古い　　　　　おいしい　　美味しい　　　　ふゆ　　冬　\nいい（よい）　　　　　　　まずい　　　　　　　　　　　まち　　町\nわるい　　　悪い　　　　　しろい　　　白い　　　　　　やま　　山\nあつい　　　暑い　熱い　　くろい　　　黒い　　　　　　たべもの 食べ物\nさむい　　　寒い　つめたい　あかい　　　赤い　　　　　　どう\nむずかしい　難しい　　　　あおい　　　青い　　　　　　どんな\nやさしい　　易しい　　　　おもしろい　面白い　　　　　そして\n　　　　　　優しい\n文型\n大阪の夏は　暑いです\n大連の冬は　寒くないです\n中国は　大きい国です。\n本文\n天気は　よかったですか\nいいえ　よくなっかたです。\n大連は　どんな町ですか\n大きい町です\n日本の食べ物はどうですか\n美味しいですが　高いです\n美味しくないです　そして　高いです。\n文法\n１形容词修饰名词\nわたしの本　　　　　あの　面白い本  あの悪い人\n例　大連は　大きい町です\n大きい町　　寒くない冬　　高い山　大きい海　　甘いみかん\n甘くないりんご\n今日は寒いです。　　今日は寒くないです。\n昨日は寒かったです。　昨日は　寒くなかったです。\nこの　店の料理は　美味しいです。\n日本の車は　安いです。\nこの梨は　甘くないです。\n昨日のテストは　難しくなかったです。\n2形容词的时态\n\n\n\n\n一般\n过去\n\n\n\n肯定\n寒いです  いいです　よい\n寒かったです　　　  よかったです\n\n\n否定\n寒くないです　　　  よくないです\n寒くなかったです　  よくなかったです\n\n\n3 接续助词が　发在句尾 表示转折相当于汉语的【可是】\n例　日本語の勉強は　難しいですが、　面白いです\n　　日本の食べ物は　美味しいですが　高いです。\n　　四川料理は　辛いですが　美味しいです。\n　　李さんの部屋は　狭いですが　明るいです。 せまい　　あかるい\n　　今回の旅行は　疲れましたが　楽しかったです\n　　李さんは　中国人ですが　餃子ができません。\n　　\n4接续副词 そして放在两句之间 表示递进相当于汉语的【并且】\n日本の食べ物は安いです。　そして　美味しいです。\n中国製の商品は　安いです。　そして　デザインが　いいです。\n侯さんは　優しいです。　そして　金持ちです。\n李さんは　背が　高いです。　\n中国は歴史が長いです。\n中国の歴史は長いです。\n中国の歴史が長いです。\n中国も　日本も　歴史が長いです\n5疑问词どう　どんな的用法　\nどう相当汉语【怎么样】　　だれ　いつ　何　どこ　いくら\nどうですか　　いかがですか\nこの　果物の味は　どうですか　　とても　甘いです。\nこの果物は　どう　食べますか。\n例　日本の食べ物はどうですか　　高いですが　美味しいです。\n　大連の天気はどうですか。　 冬は　寒いですが　夏は　暑くないです。\n　コーヒーはどうですか。　ありがとう\n　大連はどうですか\n昨日のテストは　どうでしたか。　　難しかったです\n今日は　日曜日です。　　今日は　日曜日ではありません。\n昨日は　土曜日でした。　昨日は　土曜日ではありませんでした。\n昨日　雨でした。\n​                                                                           \nどんな相当汉语【什么样的~】　どの　この　その　あの\n李さんは　どんな人ですか　　\n大連は　どんな町ですか\n四川料理は　どんな料理ですか。\nこの本は　どんな本ですか\n阅读\n日曜日　わたしは　友達と大連へ　行きました。　大連は　大きい町です。デパートで黒い靴を買いました。それから　面白い映画を見ました。５時に　いっしょに　しせんりょうり（四川料理）を食べました。四川料理は美味しいですが　高いです。\n練習\n１这本书旧但是有趣\n2 日本的汽车不贵\n3 四川料理好吃 并且便宜\n第9课言葉\nきれい「な」　綺麗　　　　　　しけん　試験　　　　　おねえさん　お姉さん\nハンサム「な」　　　　　　　　さくら　桜　　　　　　ちち　父\nしんせつ「な」　親切　　　　　ところ　所　　　　　　はは　母\nゆうめい「な」　有名　　　　　おかし　お菓子　　　　あに　兄　\nげんき「な」　　元気　　　　　ネクタイ　　　　　　　あね　姉　\nしずか「な」　　静か　　　　　シャツ　　　　　　　　おとうと　弟     \nにぎやか「な」　賑やか　　　　かぞく　 ご家族　　　　いもうと　妹                 \nべんり「な」　　便利　　　　　おとうさん　お父さん　とても　たいへん\nふべん「な」　　不便　　　　　おかあさん　お母さん　あまり\nかんたん「な」　簡単　　　　　おにいさん　お兄さん　\n窓の所\n文型\n桜は　有名な花です\n李さんは　親切な人です\nこの食堂は静かではありません。\n本文    \nお父さんは　元気ですか\nおかげさまで　元気です\n大連は静かですか\nいいえ　静かではありません　とても　にぎやかです　賑やか\n今日の試験は　難しかったですか\nいいえ　あまり　難しくなかったです。　ぜんぜん\n文法\n1形容动词修饰名词 后续假名「な」\n例 静かな所　有名な映画　元気な人\n李さんは　元気な人です\n張さんはハンサムな人です。\n昨日　彼女と　人気な映画を見ました。　かのじょ にんき\nこの小説は　有名です。　　この小説は　有名ではありません。\nこの小説は　有名でした。この小説は　有名ではありませんでした\n今日は　水曜日です。　　　今日は　水曜日ではありません。\n昨日は　火曜日でした。　　昨日は　水曜日ではありませんでした。\n北京は　にぎやかではありません。\n李さんの部屋は　大きいですが　静かではありません。\n李さんの家は　綺麗ですが　　交通が　不便です。\nわたしが　中国人です。\n中国は　歴史が　長いです。\n2形容动词的时态变化\n\n\n\n\n一般\n过去\n\n\n\n肯定\n静かです\n静かでした\n\n\n否定\n静かではありません\n静かではありませんでした\n\n\nとても・たいへん＞すこし少し・ちょっと＞あまり＋否定＞ぜんぜん全然＋否定\nこの公園は　ぜんぜん　静かでは　ありません。　　大変な仕事\n今日は　あまり　暑くないです。\n3　副詞　とても　たいへん 表示程度高\n相当汉语的【很】　\n例今日は　ちょっと　暑いです　今日は　あまり　暑くないです\n　今日は　全然　暑くないです。\n　　この店の四川料理は　全然　辛くないです\n　\n4　副詞　あまり 表示程度低 后续否定\n相当汉语的【不太】\n例　今日は　あまり　寒くないです\n阅读\n大連はとても有名な町です。　大きいです。　そして　たいへん　にぎやかです。日曜日　わたしは　大連の有名な星海公園（せいかいこうえん）へ行きました。この公園はきれいですが　あまり　静かではありません。\n練習\n1 小李热心并且长得还帅\n2 教室很干静但不太安静\n3 这部电影很有名\n第10课言葉\nわかる　分かります　　　 スポーツ　　　　　　　　　ぶどう\nある　　あります　　　　 くだもの　　果物　　　　　りんご　\nすき「な」　　好き　　　　やさい　　　野菜　　　　　なし　　　梨\nきらい「な」　嫌い　　　　おんがく　　音楽　　　　　たくさん　\nじょうず「な」上手　　　　サッカー　　　　　　　　　\nへた「な」　　下手　　　　じかん　　　時間　　　　\nりょうり　　料理　　　　　バナナ　　　　　　　　　　どうして\nうた　　歌　　　　　　　　みかん　　　　　　　　　　～から\nにく　　肉　　　　　　　　すいか\n大きい国　甘いスイカ　　有名な小説　　静かな教室\n嫌いな　食べ物は　何ですか　\n大好き　　大嫌い\n上手ではありません　下手です\nとくい　得意　　にがて　苦手\n今日は　寒いです　　今日は　寒くないです。　寒かったです。　寒くなかったです。\nこの小説は　有名です　　有名ではありません。有名でした　有名ではありませんでした\n今日は　日曜日です　ではありません　でした　ではありませんでした。\n文型\nわたしは　日本語がわかります。\nわたしは　りんごが好きです。\nあなたは　歌が上手ですか。\n日曜日　時間があります。\n本文　\nあなたは　英語が分かりますか。\nいいえ　ぜんぜん　分かりません。\nお金がありますか\nはい　少し　あります。\n李さんは　歌が　たいへん　上手です。\nわたしは　肉が　好きです。\n文法\n助词が的用法\n1表示提示个人的情感 喜好 欲望的对象\n怖い こわい\nわたしは　犬（いぬ）が怖いです。\nわたしは　犬が怖くないです。\n欲しい　ほしい\n　お金が欲しいですか\nわたしは　お金が欲しくないです。\n彼女が欲しくないです\n好き　嫌い　\nわたしは　お酒が好きでは　ありません。\nわたしは　豚肉が嫌いです。\nわたしは　日本のアニメが　大好きです　だい　　\nわたしは　鶏肉が　大嫌いです。\nわたしは　君のことが大好きです。きみ\nどの料理が　好きですか。\nどこの　料理が好きですか\nどんな料理が好きですか。\n何の料理が好きですか\n例　肉が嫌いです　　　お金が　欲しい\n2表示个人能力的判定的对象\n上手　下手　　得意（とくい）　　苦手（にがて）\n李さんは　ギターが上手ではありません。\n林さんは　ピアノが上手です。\n李さんは　歌が　得意です。\n李さんは　料理が　苦手です\nわかる　分かります　　　　できる　できます\nわたしは　パソコンの操作が　分かります。\n私は　車の運転ができます。うんてん\nわたしは　ピアノができません。\n李さんは　バドミントンが　すこし　上手です。\n例　日本語が分かる　　サッカーができる　　スポーツが上手です\n3表示所有的对象\nある　いる\n李さんは　お金が　ありません。\n李さんは　犬が　います。\n李さんは　綺麗な彼女がいます。\n時間があります　お金が要ります　要る　要ります　いる　恋人がいます\n李さんは　アメリカの映画が　大好きです。\n接续助词から的用法 放在前一句的后面表示原因 后一句表示结果相当汉语的【因为**所以**】　が　　　\n5時から\n頭が痛いですから、病院へ行きます。\n李さんは中国人ですから、　餃子が好きです。\n明日　暇ですから、デパートへ行きます。\n疲れましたから、明日　どこも行きません。\nお金がありませんから、　父さんに電話を掛けました。\n忙しくないですから、　明日　友達の家へ行きます。\n時間が　ありませんから　旅行ができません。\n例　お酒が好きですから　毎日　飲みます\n疑问词どうして 的用法\n相当汉语的【为什么】回答时结尾使用から 表示原因\n　どうして　朝ご飯を食べませんか　　　食べませんでしたか\n　ダイエット中ですから、 ちゅう　　恋愛中　　旅行中　\n出張中　　仕事中\n　日本中　　学校中　　一日中　　午前中　\nどうしてですか\nきのう　病院へ行きました。\nどうしてですか\nお腹が痛かったですから、\nどうして　病院へ行きますか。\nどうして　　なんで　　なぜ\nなぜ　豚肉を食べませんか\nあまり　好きではありませんから。\n例　どうして日本語を勉強しますか\n　　日本が好きですから\nたくさん\n最近　仕事が　たくさん　ありましたから　ちょっと　疲れました。\n昨日　スーパーは　バーゲンが　ありましたから　肉を　たくさん　買いました。\nたくさんの仕事\n練習\n1　因为不喜欢鱼 所以一点也不吃\n2 我不擅长唱歌\n3 你喜欢什么样的水果 喜欢西瓜\n4 因为在学校学了 所以懂一点日语 \n","categories":["其他"]},{"title":"黑魂复刻第一季（傅老师）","url":"/2022/07/21/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity/%E9%BB%91%E9%AD%82%E5%A4%8D%E5%88%BB%E7%AC%AC%E4%B8%80%E5%AD%A3%EF%BC%88%E5%82%85%E8%80%81%E5%B8%88%EF%BC%89/","content":"1.玩家输入模块Player Input Module按键输入原理灵魂画师博老师：\n\nKey （键盘输入）–&gt; PI脚本（PlayerInput） –&gt; signal（信号）Joy\t(手柄输入)  –&gt; PI脚本（PlayerInput） –&gt; signal（信号）\n创建场景在Hierarchy窗口创建Capsule(胶囊)和Plane(平面)，并重置坐标值，Capsule的Position Y值抬高1\n添加按键输入在Capsule新建一个PalyerInput脚本\n// Variablepublic string keyUp = &quot;w&quot;;public string keyDown = &quot;s&quot;;public string keyLeft = &quot;a&quot;;public string keyRight = &quot;d&quot;;\n\n效果如下:\n把输入的信号转换成电脑能读懂的signalpublic float Dup;public float Dright;void Update ()&#123;    Dup = (Input.GetKey(keyUp)?1.0f:0) - (Input.GetKey(keyDown)?1.0f:0); //三目运算符    Dright = (Input.GetKey(keyRight)?1.0f:0) - (Input.GetKey(keyLeft)?1.0f:0); &#125;\n\n2.输入衰减与使能旗飘 Damping and Enable Flag.SmoothDamp平滑缓冲代码如下：\n// Variablepublic string keyUp = &quot;w&quot;;public string keyDown = &quot;s&quot;;public string keyLeft = &quot;a&quot;;public string keyRight = &quot;d&quot;;public float Dup;public float Dright;private float targetDup; //目标值private float targetDright;private float velocityDup; //暂存值private float velocityDright;void Update ()&#123;    targetDup = (Input.GetKey(keyUp)?1.0f:0) - (Input.GetKey(keyDown)?1.0f:0); //三目运算符    targetDright = (Input.GetKey(keyRight)?1.0f:0) - (Input.GetKey(keyLeft)?1.0f:0);         Dup = Mathf.SmoothDamp(Dup,targetDup,ref velocityDup,0.1f);    Dright = Mathf.SmoothDamp(Dright, targetDright, ref velocityDright, 0.1f);&#125;\n\nsmoothdamp（平滑缓冲）东西不是僵硬的移动而是做减速缓冲运动到指定位置Mathf.SmoothDamp(需要修改的参数, 目标值 ,ref 暂存值,平滑所需的时间);\n添加关闭输入开关public bool inputEnabled = true; //Flagvoid Update ()&#123;    if (!inputEnabled)    &#123;        targetDup = 0;        targetDright = 0;    &#125;&#125;\n\n3.导入模型Import Models导入材质更改参数\n把材质和模型导入Project文件夹中\n\n添加Plane，并把地板贴图并拖入材质球中，Tiling属性设为9，9，地板大小也放大三倍（扩大地图）\n\ncapsule改名为PlayerHandle并放入人物模型，成为PlayerHandle子物件，remove（删除）掉Mesh Renderer（网格渲染器）和Mesh Filter（网格过滤器）\n\n调整PlayerHandle和人物模型的位置及大小\n\n\n更改材质密度大小\nscene 中的gizmos设置（优化场景显示）\n3d lcons 调整场景图标大小\nselection Qutline 取消显示模型外边框\n4.新增动画控制器Add Animator Controller\n在Assets窗口中新建一个folder改名为Animator，并在Animator文件夹中新建一个Animator Controller名字就叫Actor\n没有animator创建就在windows-animator窗口可以找到\n放入idle和walk动画，并给人物模型的Animator的controller加入刚刚创建名为Actor的动画控制器\n在Project窗口找到人物模型，在rig-Animation Type的属性改为Humanoid（关于这个的详细设置以后再更新）\nHierarchy窗口的人物模型animator组件的Apply Root Motion（根运动）选项消勾\n\n5.一维混合树1D Blend Tree一个混合树可以包含多个动画\n右键单击 Animator Controller 窗口上的空白区域。 从显示的上下文菜单中，选择 Create State &gt; From New Blend Tree。 双击混合树 (Blend Tree) 以进入混合树视图 (Blend Tree Graph)。\n把BlendTree改名为ground，双击Blend改名为forward，在inspector窗口加两个motion filed并放入动画\n\n6.串联玩家控制与角色控制模块Connect PI and AC modules在PlayerHandle添加一个名为ActorController的脚本\n\n代码如下：\n//ActorControllerpublic GameObject modle;\t//挂载一个GameObject名为modlepublic PlayerInput pi;\t\t//挂载一个pi叫PlayerInput[SerializeField]//序列化的数据类型可以通过这个特性显示到编辑器上private Animator anim;\t//声明一个animator组件,把ybot子物体拖进去void Awake() //awake&gt;enable&gt;start&#123;    pi = GetComponent&lt;PlayerInput&gt;();\t//得到pi的PlayerInput脚本    anim = model.GetConmponent&lt;Animator&gt;(); //得到modle的animator动画组件&#125;void Update()\t//帧更新&#123;    anim.SetFloat(&quot;forward&quot;, pi.Dup);\t//取pi的Dup变量更改animator的forward的值&#125;\n\n7.角色行走#1Actor walks#1\nDup和Dright值数范围是-1到1，而animator的forword数值变化值数范围是0到1\n因此我们把Dup和Dright的值变为长度m，方向和由Dup和Dright的变化而变化\n根据这幅图的原理我们把以前的代码更改一下：\n//ActorControllervoid Update()&#123;    anim.SetFloat(&quot;forward&quot;, Mathf.Sqrt((pi.Dup * pi.Dright) + (pi.Dright * pi.Dright))); //图片的m值    model.transform.forward = pi.Dright * transform.right + pi.Dup * transform.forward;\t//旋转&#125;\n\n然后我们把代码进行封装一下，更改PallyerInput脚本:\n//PallyerInputpublic float Dmag;\t//D向量模,用来更改动画forward的值public Vector3 Dvec;void Update()&#123;    Dmag = Mathf.Sqrt((Dup * Dright) + (Dright * Dright));    Dvec = Dright * transform.right + Dup * transform.forward;&#125;\n\n然后我们把ActorController脚本改一下，漂漂亮亮的：\n//ActorControllervoid Update()&#123;    anim.SetFloat(&quot;forward&quot;, pi.Dmag); //图片的m值    model.transform.forward = pi.Dvec\t//旋转&#125;\n\n但是这个代码有个缺陷：停止按键会立刻朝着前方，这个我们下一课进行解决\n8.角色行走#2Actor walks#2我们是以Dup和Dright的大小作为方向的，但是松手后Dup和Dright的值数大小会组件变成0，forward向量的值不能为0导致模型方向重置，解决方法很简单在Dmag到0之前暂停这段代码执行即可：\n//ActorControllervoid Update()&#123;    anim.SetFloat(&quot;forward&quot;, pi.Dmag); //图片的m值    if (pi.Dmag &gt; 0.1f)    &#123;        model.transform.forward = pi.Dvec\t//旋转    &#125;&#125;\n\n//ActorControllerpublic float walkSpeed = 1.4fprivate Rigidbody rb;\t//声明一个rigidbody组件private Vector3 movingVec;\t//声明一个模型移动方向void Awake()&#123;    rb = GetComponent&lt;Rigidbody&gt;();&#125;void Update()&#123;    movingVec = pi.Dmag * model.transform.forward * walkSpeed; //每秒向model.transform.forward移动Dmag米&#125;    void FixedUpdate()  //注意rigidbody一定要在fixedupdate里写，update是每帧执行一次，Fixedupdate是固定每0.02秒执行uici（Unity默认值）&#123;    //rb.position += movingVec * Time.fixedDeltaTime; //胶囊速度乘以时间    rb.velocity = new Vector3(movingVec.x, rb.velocity.y, movingVec.z);&#125;\n\n完整代码如下：\n//PallyerInputpublic float Dmag;\t//D向量模,用来更改动画forward的值public Vector3 Dvec;void Update()&#123;    Dmag = Mathf.Sqrt((Dup * Dright) + (Dright * Dright));    Dvec = Dright * transform.right + Dup * transform.forward;&#125;\n\n//ActorControllerpublic float walkSpeed = 1.4fpublic GameObject modle;\t//挂载一个GameObject名为modlepublic PlayerInput pi;\t\t//挂载一个pi叫PlayerInput[SerializeField]//序列化的数据类型可以通过这个特性显示到编辑器上private Animator anim;\t//声明一个animator组件,把ybot子物体拖进去private Rigidbody rb;\t//声明一个rigidbody组件private Vector3 movingVec;\t//声明一个模型移动方向void Awake() //awake&gt;enable&gt;start&#123;    pi = GetComponent&lt;PlayerInput&gt;();\t//得到pi的PlayerInput脚本    anim = model.GetConmponent&lt;Animator&gt;(); //得到modle的animator动画组件    rb = GetComponent&lt;Rigidbody&gt;();&#125;void Update()\t//帧更新&#123;    anim.SetFloat(&quot;forward&quot;, pi.Dmag); //图片的m值    if (pi.Dmag &gt; 0.1f)    &#123;        model.transform.forward = pi.Dvec\t//旋转    &#125;    movingVec = pi.Dmag * model.transform.forward * walkSpeed; //每秒向model.transform.forward移动Dmag米&#125;void FixedUpdate()  //注意rigidbody一定要在fixedupdate里写，update是每帧执行一次，Fixedupdate是固定每0.02秒执行uici（Unity默认值）&#123;    rb.velocity = new Vector3(movingVec.x, rb.velocity.y, movingVec.z);&#125;\n\n9.角色奔跑Actor run在blend tree添加跑步动画\n\n更改Threshold的值如果改不了就把Automate Thresholds选项消勾\n因为需要实现跑步功能所以我们要添加新的按键，代码如下：\n//PlayerInput[Header(&quot;===== key settings =====&quot;)]//序列化,Inspector面板中显示文字public string keyA;public string keyB;public string keyC;public string keyD;[Header(&quot;===== Output signals =====&quot;)]// 1.pressing signalpublic bool run;void Update()&#123;    run = Input.Getkey(keyA);&#125;//ActorConntrolleranim.SetFloat(&quot;forward&quot;, pi.Dmag * ((pi.run) ? 2.0f : 1.0f));movingVec = pi.Dmag * model.transform.forward * walkSpeed *((pi.run) ? 2.7f : 1.0f); //三元运算符\n\n10.线性插值与球形线性插值Lerp &amp; Slerp//ActorConntroller//移动渐变anim.SetFloat(&quot;forward&quot;, pi.Dmag * Mathf.Lerp(anim.GetFloat(&quot;forward&quot;),(pi.run) ? 2.0f :1.0f),0.5f));//转向渐变Vector3 targetForward = Vector3.Slerp(model.transform.forward, pi.DVec, 0.5f);//渐变model.transform.forward = targetForward;//利用slerp把current值转到目标值实现平滑的转身\n\n11.椭圆映射法Elliptical Grid Mapping论文地址：https://arxiv.org/ftp/arxiv/papers/1509/1509.06344.pdf\n在游戏运行时我们会发现一个问题，玩家斜向移动速度会变快，为了修改这个我们用论文第五页公式。\n\n代码如下：\n//PlayerInputprivate void SquareToCirclie(Vector2 input)&#123;    Vector2 output = Vector2.zero;    output.x = input.x * Mathf.Sqrt(1 - (input.y * input.y)/2.0f);    output.y = input.y * Mathf.Sqrt(1 - (input.x * input.x)/2.0f);        returm output;&#125;Vector2 tempDAxis = SquareToCirclie (new Vector2(Dright,Dup));float Dright2 = tempDAxis.x;float Dup2 = tempDAxis.y;\n\n12.一次性触发控制（Trigger Oonce Signal）实现跳跃功能：\n//PlayerInput// 2. trigger once signalpublic bool jump;private bool lastJump;void Update ()&#123;    bool newJump = Input.GetKey (keyB);    if (newJump != lastJump &amp;&amp; newJump == true)//newJump == true，解释如下图    &#123;        jump = true;    &#125;    else     &#123;        jump = false;    &#125;    lastJump = newJump;&#125;\n\n这种触发器按下会触发两次信号，所以我们要触发前面的信号：\n\n13.新增跳跃动画Jump Animationanimator窗口添加Jump动画，详细操作我就不写了毕竟做了我们做很多次，所以直接上代码：\n//ActorControllerif(pi.jump)&#123;    anim.SetTrigger(&quot;jump&quot;);&#125;\n\n14.巧妙地重置动画控制器触发Reset Triggers我们会发现一个问题，跳跃键按两次会自动跳两次，所以我们在ground的Inspector窗口新建一个名为FSMClearSingnals的脚本：\n\n新建脚本会出现以下预设：\n\n\nOnStateEnter：当一个转换开始并且状态机开始评估这个状态时\n\n\n\nOnStateUpdate：OnStateUpdate 在 OnStateEnter 和 OnStateExit 回调之间的每个更新帧上调用\nOnStateExit：当转换结束并且状态机完成评估此状态时\nOnStateMove：OnStateMove 在 Animator.OnAnimatorMove () 之后被调用。处理和影响根运动的代码应该在这里实现\nOnAnimatorIK：OnStateIK 在 Animator.OnAnimatorIK () 之后被调用。设置动画 IK（反向运动学）的代码应该在这里实现。\n\n代码如下：\npublic string[] clearAtEnter;public string[] clearAtExit;override public void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)&#123;    foreach (var signal in clearAtEnter)    &#123;        animator.ResetTrigger(signal);//清除信号    &#125;override public void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)&#123;    foreach (var signal in clearAtExit)    &#123;        animator.ResetTrigger(signal);    &#125;&#125;\n\n\n15.套出FSM On Enter&amp;Exit方法FSM On Enter&amp;Exit在jump的Inspector窗口新建一个名为FSMOnEnter和FSMOnExit的脚本：\npublic string[] onEnterMessages;override public void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)&#123;    foreach (var msg in onEnterMessages)    &#123;        //animator.gameObject.SendMessage(msg);        animator.gameObject.SendMessageUpwards(msg);//向上发信息    &#125;&#125;\n\npublic string[] onExitMessages;override public void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)&#123;    foreach (var msg in onEnterMessages)    &#123;        //animator.gameObject.SendMessage(msg);        animator.gameObject.SendMessageUpwards(msg);//向上发信息    &#125;&#125;\n\n\n然后在ActorController脚本进行拦截：\n//ActorControllerpublic void OnJumpEnter()&#123;    print (&quot;On jump enter&quot;);&#125;public void OnJumpExit()&#123;    print (&quot;On jump exit&quot;);&#125;\n\n16.锁死平面移动Lock Planar解决跳跃状态移动的bug\n直接在上个脚本改：\n//ActorControllerprivate bool lockPlanar = false;//锁死平面移动void Update()&#123;    if (lockPlanar == false)    &#123;         movingVec = pi.Dmag * model.transform.forward * walkSpeed;        &#125;&#125;public void OnJumpEnter()&#123;    pi.inputEnabled = false;    lockPlanar = true;    //print (&quot;On jump enter&quot;);&#125;public void OnJumpExit()&#123;    //print (&quot;On jump exit&quot;);    pi.inputEnablie = true;    lockPlanar = false;&#125;\n\n17.跳跃向量Jump Thrust//ActorControllerpublic float jumpVelocity = 3.0f;//为了写活跳跃值private Vector3 thrustVec;\t//新增跳跃冲量向量void FixedUpdate()&#123;    rb.velocity = new Vector3(movingVec.x, rb.velocity.y, movingVec.z) + thrustVec;    thrustVec = Vector3.zero;\t//一帧触发然后变成0&#125;public void OnJumpEnter()&#123;    pi.inputEnabled = false;    lockPlanar = true;    thrustVec = new Vector3 (0, jumpVelocity, 0);    //print (&quot;On jump enter&quot;);&#125;\n\n18.新增降落状态Add Fall State在动画控制器里添加下落动画名字为fall，并调整好状态机，过程很简单就不详写了\n\n19.新增落地侦测器Add On Ground Sensor在这里傅老师用的是Physics.OverlapCapsule这个方法用来检测地面撞击,这个函数判定胶囊中有多少碰撞体：\nCollider[] OverlapCapsule(Vector3 point0, Vector3 point1, float radius, int layerMask);\n\n\n在PlayerHandle新建一个空对象，名为sensor。在sensor新建名为OnGroundSensor的脚本，代码如下：\n//OnGroundSensorpublic CapsuleCollider capcol;\t//把PlayerHandle拽进来private Vector3 point1;private Vector3 ponit2;private float radius;\t//定义半径值void Awake ()&#123;    radius = capcol.radius;\t//把PlayerHandle抓取半径值&#125;void FixedUpdate ()&#123;    point1 = transform.position + transform.up * radius;    point2 = transform.position + transform.up * capcol.height - transform.up * radius;    Collider[] outputCols = Physics.OverlapCapsule(point1, ponit2, radius, LayerMask.GetMask(&quot;Ground&quot;));//给地板加个Ground Layer    if (outputCols.Length != 0)    &#123;        foreach (var col in outputCols)        &#123;            print (&quot;collision:&quot; + col.name)        &#125;    &#125;&#125;\n\n\n20.使用落地侦测器Use On Ground Sensor我们上节课已经写好了落地检测，现在我们来使用它们：\n//OnGroundSensorif (outputCols.Length != 0)&#123;        //foreach (var col in outputCols)        //&#123;        //    print (&quot;collision:&quot; + col.name)        //&#125;    SendMessageUpwards(&quot;IsGround&quot;);//向上传递信号&#125;else &#123;    SendMessageUpwards(&quot;IsNotGround&quot;);&#125;\n\n我们在ActorController脚本进行拦截：\n//ActorControllerpublic void IsGround()&#123;    anim.SetBoll (&quot;isGround&quot;, true);&#125;public void IsNotGround()&#123;    anim.SetBoll (&quot;isGround&quot;, false);&#125;\n\n添加一个布尔类型的isGround信号并在fall-&gt;ground添加这个信号：\n\n调整动画优先级防止出现落地时优先播放fall动画,如果还是出现落地播放fall动画可以降低跳跃的高度;或者打开jump-&gt;fall动画的setting,启用interruption source下的current stage\n\n\n21.重新修正降落状态Rearrange Fall State这样更好的解决了下落的问题：\npublic void OnGroundEnter()//OnJumpExit改成OnGroundEnter&#123;    pi.inputEnablid = true;    lockPlanar = false;&#125;\n\n\n22.失足掉落 Fall form Ground State动画控制器ground-&gt;fall添加一个isGround&#x3D;false触发条件：\n\n为了防止移动下落没有抛物线的这种情况，我们加一个OnFallEnter：\n\npublic void OnFallEnter()&#123;    pi.inputEnablid = false;    lockPlanar = true;&#125;\n\n出现跳跃发生Fall动画原因：跳跃值太高会产生下落效果，但是下落动画播放之后才会返回所以有下落的僵持效果，我们把Interruption Spirce改为Curremt state打断它即可\n\n23.新增翻滚状态Add Roll State在动画控制器添加下落root的动画，然后加个roll的trigger信号来检测控制下落，动画控制roll优先\n\n//ActorControllerif (rb.velocity.magnitude &gt; 5.0f)&#123;    anim.SetTrigger(&quot;rool&quot;);&#125;\n\n烘焙roll动画添加翻滚效果：\n\n24.走路翻滚+跑步跳跃Walk Roll and Sprint Jump走路翻滚：我们要fall从ground进入roll，所以我们添加动画条件\n\n\n更改动画条件：\n\n\n由于翻滚没有高度很是不美观，所以我们添加一个向上冲量：\n//ActorControllerpublic float rollVelocity = 3.0f;public void OnRollEnter()&#123;    thrustVec = new Vector3 (0, rollVelocity, 0);    pi.inputEnable = false;    lockPlanar = true;&#125;\n\nrool动画添加OnRollEnter来触发\n\n25.新增后跳状态Add Jab Stateforward速度在0-1.1之间为roll，1.1-2.1为jump，在0-0.1之间增加jab后跳动作\n\n我们继续添加后跳Jab动画，添加条件，更改优先级，Has Exit Time 消勾，然后再拉回来驾轻就熟…\n\n\n接下来我们给jab添加向后的冲量，所以我们给jab加之前写好的FSM On Enter脚本，挂上OnJabEnter脚本\n\n添加代码如下：\n//ActorControllerpublic float jabVelocity = 3.0f;public void OnJabEnter()&#123;    //thrustVec = new Vector3 (0, 0, -javaVelocity);//错误方法，一个是方向错误，瞬时冲量类似于瞬移    thrustVec = model.transform.forward * -jabVelocity;//添加一个负的向前向量的值    pi.inputEnabled = false;    lockPlanar = true;&#125;\n\n","categories":["Unity/虚幻"],"tags":["unity","黑魂复刻(傅老师)"]}]