<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>执行流程 | WRXinYue's Blog</title><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 - 共 $1 行","copy":"复制","copyFinish":"复制成功","expand":"展开"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><script>mermaid.initialize({
 startOnLoad: true
 , theme: 'dark'
});</script><link rel="stylesheet" href="/css/arknights.css"><link rel="stylesheet" href="//unpkg.com/@highlightjs/cdn-assets@11.6.0/styles/atom-one-dark-reasonable.min.css"><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body style="background-image:url(https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg);"><main><header class="closed"><nav><div class="navBtn hide"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><ol class="navContent"><li class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></li><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/about/"><span class="navItemTitle">About</span></a></li><li class="navItem"><a class="navBlock" href="/contact/"><span class="navItemTitle">Contact</span></a></li></ol></nav><div class="search-popup"><div id="search-result"></div></div></header><article><div id="post-bg"><div id="post-title"><h1>执行流程</h1><div id="post-info"><span>文章发布时间: <div class="control"><time datetime="2023-04-18T03:51:31.246Z" id="date"> 2023-04-18</time></div></span><br><span>最后更新时间: <div class="control"><time datetime="2023-04-18T07:13:18.000Z" id="updated"> 2023-04-18</time></div></span></div></div><hr><div id="post-content"><h1 id="Web前端历史"><a href="#Web前端历史" class="headerlink" title="Web前端历史"></a>Web前端历史</h1><h2 id="Web1-0时代"><a href="#Web1-0时代" class="headerlink" title="Web1.0时代"></a>Web1.0时代</h2><p>在web1.0时代，没有前后端之分。页面由 JSP、PHP 等工程师在服务端生成，浏览器负责展现。基本上是服务端给什么浏览器就展现什么，展现的控制在 Web Server 层。</p>
<p><img src="https://wrxinyue.oss-cn-hongkong.aliyuncs.com/img/image-20230219204441797.png" alt="image-20230219204441797"></p>
<p>这种架构的好处就是简单快捷。但是，缺点也非常明显：JSP代码难以维护</p>
<p>为了让开发更加便捷，代码更易维护，前后端职责更清晰。便衍生出MVC开发模式和框架，前端展示以模板的形式出现。典型的框架就是Spring，Suructs、Hibernate。整体框架如图所示：</p>
<p><img src="https://wrxinyue.oss-cn-hongkong.aliyuncs.com/img/2062729-b718cd0a7d3b32b9.png" alt="img"></p>
<p>使用这种分层架构，职责清晰，代码易于维护。但这里的MVC仅限于后端，前后端形成了一定的分离，前端只完成了后端开发的view层</p>
<h2 id="Web2-0时代"><a href="#Web2-0时代" class="headerlink" title="Web2.0时代"></a>Web2.0时代</h2><p>自从Gmail的出现，ajax技术开始风靡全球。有了ajax之后，前后端的职责就更加清晰了。因为前端可以通过Ajax与后端进行数据交互，因此，整体的架构图也变化成了下面这幅图：</p>
<p><img src="https://wrxinyue.oss-cn-hongkong.aliyuncs.com/img/web2.0.jpg" alt="web2.0"></p>
<p>Ajax 技术与后台服务器进行数据交换，可以使得前端开发人员只需要专注于页面内容的开发，数据可以由后台提供，从而分工更加明确，提高了开发效率。而且，使用 Ajax 技术可以实现页面的部分刷新，减少了服务器端负载和流量消耗，用户体验更佳。</p>
<h1 id="前后端分离后的架构演变-MVC、MVP和MVVM"><a href="#前后端分离后的架构演变-MVC、MVP和MVVM" class="headerlink" title="前后端分离后的架构演变-MVC、MVP和MVVM"></a>前后端分离后的架构演变-MVC、MVP和MVVM</h1><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>前端的MVC与后端类似，具备View、Controller和Model。</p>
<p>Model：负责保存应用数据，与后端数据进行同步</p>
<p>Controller：负责业务逻辑，根据用户行为对Model数据进行修改</p>
<p>View：负责视图展示，将model中的数据可视化出来</p>
<p>三者形成了一个如图所示的模型：</p>
<p><img src="https://wrxinyue.oss-cn-hongkong.aliyuncs.com/img/4b233d989851c553aede751f7cdf4885.jpg" alt="4b233d989851c553aede751f7cdf4885"></p>
<p>这样的模型，在理论上是可行的。但往往在实际开发中，并不会这样操作。因为开发过程并不灵活。例如，一个小小的事件操作，都必须经历这样的一个流程，那么开发就不再便捷了。</p>
<p>在实际场景中，我们往往会看到另一种模式，如图：</p>
<p><img src="https://wrxinyue.oss-cn-hongkong.aliyuncs.com/img/0f92b4266a.jpg" alt="0f92b4266a"></p>
<p>这种模式在开发中更加灵活，backbone.js框架就是这种的模式。</p>
<p>但是，这种灵活可能导致严重的问题：</p>
<p>1.数据流混乱：</p>
<p><img src="https://wrxinyue.oss-cn-hongkong.aliyuncs.com/img/66066801154.jpg" alt="66066801154"></p>
<p>2.View比庞大，而Controller比较单薄：由于很多开发者就会在view中写一些逻辑代码，逐渐的就导致了view中的内容越来越庞大，而controller变得越来越单薄。</p>
<h2 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h2><p>MVP模式虽然在前端开发并不常见，但是在安卓等原生开发中，开发者还是考虑到它</p>
<p>MVP模式与MVC唯一不同的在于Presenter和Controller</p>
<p>再MVC模式中我们使用观察者模式，来实现当Model层数据发生变化的时候，通知View层的更新，</p>
<p>这样View和Model层耦合在一起，当项目逻辑变得复杂的时候，会造成代码的混乱</p>
<p>MVP的模式通过使用Presenter来实现对View层和Model层的解耦。</p>
<p>MVC中的Controller只知道Model的接口，因此它没有办法控制View层的更新，MVP模式中View层的接口暴露给了Presenter，因此我们可以在Presenter中将Model的变化和View的变化绑定在一起，以此来实现View和Model的同步更新，这就实现了对View和Model的解耦，Presenter还包含了其他的响应逻辑。</p>
<p>MVP与MVC很接近，P指的是Presenter，presenter可以理解为一个中间人，它负责着View和Model之间的数据流动，防止View和Model之间直接交流。我们可以看一下图示：</p>
<p><img src="https://wrxinyue.oss-cn-hongkong.aliyuncs.com/img/6364fee4b2.jpg" alt="6364fee4b2"></p>
<p>我们可以通过看到，presenter负责和Model进行双向交互，还和View进行双向交互。这种交互方式，相对于MVC来说少了一些灵活，view变成了被动视图，并且本身变得很小。虽然它分离了View和Model。但是应用逐渐变大之后，缺陷也会随之暴露。</p>
<p>缺陷：</p>
<p>由于大部分逻辑都需要presenter去进行管理，从而导致presenter的体积增大，难以维护。如果需要去解决这个问题，或许可以从MVVM的思想中找到答案。</p>
<h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>首先，何为MVVM呢？MVVM可以分解成(Model-View-VIewModel)。ViewModel可以理解为在presenter基础上的进阶版。废话不多说，先上图例：</p>
<p><img src="https://wrxinyue.oss-cn-hongkong.aliyuncs.com/img/fe2ae148d68.jpg" alt="fe2ae148d68"></p>
<p><img src="https://wrxinyue.oss-cn-hongkong.aliyuncs.com/img/alcyu8psepmvwkrbiyy8.png" alt="KZFfe.png"></p>
<p>在这里View是ViewModel的外在显示，和ViewModel的数据是同步的。一旦View中的数据发生变化，会自动同步到ViewModel，然后ViewModel可以将变化的数据传给Model；反过来也是一样的，Model中的数据一旦发生改变，就会将值传给ViewModel，而ViewModel也会同步更新到view中。现在的框架实现这样的形式，各有各的不同。主要的三个框架angular2、vue、react都是实现了这样子的模式。</p>
<p>这种的好处就是View和Model之间被分离开来。view不知道model的存在，viewmodel和model也觉察不到view。事实上，model也完全忽略viewmodel和view的存在。这是一个非常松散耦合的设计。</p>
<p>但它也不是所用地方都适用的，例如，后端开发是适用的。因为网络资源成本过高，开发成本过高导致的。</p>
<p><img src="https://wrxinyue.oss-cn-hongkong.aliyuncs.com/img/image-20230219215903465.png" alt="image-20230219215903465"></p>
<p>MVVM模式中的VM，指的是ViewModel，它和MVP的思想其实是相同的，不过它通过双向的数据绑定，将View和Model的同步更新给自动化了。当Model发生变化的时候，ViewModel就会自动更新，这样就将Presenter中的工作给自动化了</p>
<h2 id="MVVM执行流程"><a href="#MVVM执行流程" class="headerlink" title="MVVM执行流程"></a>MVVM执行流程</h2><p>MVVM 是一种基于前端的架构模式，它的执行流程如下：</p>
<ol>
<li>视图层 (View)：MVVM 模式的视图层通常由 HTML 和 CSS 组成，它负责用户界面的呈现和交互。在 Vue.js 中，视图层使用模板语法来描述 UI。</li>
<li>模型层 (Model)：模型层是应用程序的数据模型，它负责处理数据的读写操作。在 Vue.js 中，模型层由 Vue 实例的数据属性组成。</li>
<li>视图模型层 (ViewModel)：视图模型层是连接视图层和模型层的桥梁，它负责将模型层中的数据和方法绑定到视图层上。在 Vue.js 中，视图模型层由 Vue 实例的计算属性、方法和指令组成。</li>
<li>数据绑定：MVVM 模式使用双向数据绑定机制，实现视图层和模型层之间的数据同步。当模型层数据发生变化时，视图层会自动更新，反之亦然。</li>
<li>事件监听：视图层通常会触发各种事件，例如点击按钮、输入文本等。在 Vue.js 中，可以使用指令和事件监听器来处理这些事件，例如 v-on:click。</li>
<li>视图更新：当模型层数据发生变化或用户事件触发时，视图模型层会自动更新视图层，反映最新的数据状态。</li>
</ol>
<p>总的来说，MVVM 模式的执行流程是：视图层通过指令和事件监听器与视图模型层进行交互，视图模型层通过计算属性、方法和指令将模型层的数据和方法绑定到视图层上，实现视图层和模型层之间的双向数据绑定和自动更新。这种模式能够提高应用程序的可维护性和可测试性，同时也可以减少开发人员的工作量，提高开发效率。</p>
<h1 id="后端架构"><a href="#后端架构" class="headerlink" title="后端架构"></a>后端架构</h1><h2 id="B-x2F-S架构、C-x2F-S架构"><a href="#B-x2F-S架构、C-x2F-S架构" class="headerlink" title="B&#x2F;S架构、C&#x2F;S架构"></a>B&#x2F;S架构、C&#x2F;S架构</h2><p>SSM框架（Spring + SpringMVC + MyBatis）中的Spring MVC是基于MVC设计模式的实现。因此，SSM框架可以看作是一种基于MVC设计模式的WEB应用程序开发的框架</p>
<h2 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h2><p>三层架构(3-tier architecture)基于**”高内聚低耦合”**设计思想。三层架构我们都听说过，要想知道SSN工作流程就必须知道三层架构，下面我来给它们一步一步分块解析。</p>
<p>关于三层架构我不得不吐槽它们的大名：</p>
<ul>
<li>**表示层(UI、Presentation layer)**、视图层(View layer)、表现层、用户界面层、前端层、Web层等</li>
<li>**业务逻辑层(BLL、Business Logic layer)**、应用层(Application)、服务层(Service layer)等</li>
<li>**数据访问层(DAL、Data Access layer)**、数据持久层(Persistence layer)、DAO层(Data Access Object layer)等</li>
</ul>
<p><img src="https://wrxinyue.oss-cn-hongkong.aliyuncs.com/img/image-20230218200927398.png" alt="image-20230218200927398"></p>
<p>现在，它们的名字和之间的关系我们大概理解了。三层架构有表示层</p>
<p>关于上述三个主要层次，还有一些相关的层次和模块：</p>
<ol>
<li>应用服务层（Application Service layer）：用于提供面向应用的服务接口。</li>
<li>业务服务层（Business Service layer）：用于提供面向业务的服务接口。</li>
<li>领域层（Domain layer）：用于定义业务领域对象和业务规则。</li>
<li>数据库访问层（Database Access layer）：用于实现与数据库的交互。</li>
<li>数据访问对象层（Data Access Object layer）：用于封装数据访问操作。</li>
<li>模型层（Model layer）：实体类层、用于表示业务对象和业务规则。</li>
</ol>
<h2 id="MVC架构工作流程"><a href="#MVC架构工作流程" class="headerlink" title="MVC架构工作流程"></a>MVC架构工作流程</h2><p><img src="https://wrxinyue.oss-cn-hongkong.aliyuncs.com/img/image-20230218124957747.png" alt="image-20230218124957747"></p>
<ol>
<li>用户发起 request 请求，请求被控制器（Controller）接收，并将用户请求的数据委托给模型（Model）进行处理。</li>
<li>控制器通过模型处理数据，并得到处理结果。模型通常指业务逻辑。</li>
<li>模型处理结果返回给控制器。</li>
<li>控制器将模型数据传递给视图（View），视图通过控制器进行数据展示。在 Web 中，模型无法将数据直接在视图上显示，需要通过视图和控制器完成。如果在 C&#x2F;S 应用中，模型可以将数据在视图中展示。</li>
<li>控制器将视图响应（response）给用户，通过视图展示给用户所需的数据或处理结果。</li>
</ol>
<p>View和Mode应用了观察者模式，当Model层发生改变的时候。它会通知有关View层更新页面</p>
<p>controller层是View层和Model层的纽带，主要负责用户与应用的响应操作，它主要负责用户与应用程序的响应操作，当用户与页面发生交互的时候，Controller中的事件触发器就开始工作了，通过调用Model层，来完成对Model的修改，然后Model层再去通知View层更新。</p>
<p><img src="https://wrxinyue.oss-cn-hongkong.aliyuncs.com/img/image-20230219215358671.png" alt="image-20230219215358671"></p>
<p><strong>总结：</strong></p>
<p>MVC（Model-View-Controller）是一种常见的软件架构模式，它把应用程序分为三个核心组件：模型、视图和控制器，用于更好地组织代码、降低耦合度、提高可维护性。</p>
<p>MVC 的工作流程如下：</p>
<ol>
<li>用户与视图交互，触发事件。</li>
<li>视图将事件发送给控制器。</li>
<li>控制器接收事件并进行处理，可能需要从模型中获取数据或者调用模型的方法进行业务逻辑处理。</li>
<li>控制器将处理结果返回给视图。</li>
<li>视图根据控制器返回的结果更新界面。</li>
</ol>
<p>具体来说，MVC 的三个组件的作用如下：</p>
<ol>
<li>模型（Model）：模型表示应用程序的数据和业务逻辑，负责对数据进行处理、存储和检索。它提供了数据接口，供控制器和视图使用。</li>
<li>视图（View）：视图表示应用程序的用户界面，负责展示数据、接收用户输入、响应用户操作。它是用户与应用程序交互的窗口，可以是一个页面、一个组件或者一个控件。</li>
<li>控制器（Controller）：控制器是模型和视图之间的中介，负责接收用户输入、处理业务逻辑、更新模型和更新视图。它负责协调和管理视图和模型之间的通信，将用户输入转换为对模型的操作，并将模型的更新通知视图更新界面。</li>
</ol>
<p>通过这种工作流程，MVC 可以实现代码的分离和解耦，使得代码更加清晰、可维护和可扩展。同时，MVC 的工作流程也提供了一种可重用的设计模式，能够在不同的应用程序中使用。</p>
<h2 id="Spring-MVC工作流程"><a href="#Spring-MVC工作流程" class="headerlink" title="Spring MVC工作流程"></a>Spring MVC工作流程</h2><p><img src="https://wrxinyue.oss-cn-hongkong.aliyuncs.com/img/image-20230217202926943.png" alt="image-20230217202926943"></p>
<ol>
<li>用户发送请求至前端控制器 DispatcherServlet。</li>
<li>DispatcherServlet 收到请求调用 HandlerMapping 处理器映射器。</li>
<li>处理器映射器找到具体的处理器（可以根据 XML 配置、注解进行查找），生成处理器及处理器拦截器（如果有则生成并返回给 DispatcherServlet）。</li>
<li>DispatcherServlet 调用 HandlerAdapter 处理器适配器。</li>
<li>HandlerAdapter 经过适配调用具体的处理器（Controller，也叫后端控制器）。</li>
<li>Controller 执行完成返回 ModelAndView。</li>
<li>HandlerAdapter 将 Controller 执行结果 ModelAndView 返回给 DispatcherServlet。</li>
<li>DispatcherServlet 将 ModelAndView 传给 ViewResolver 视图解析器。</li>
<li>ViewResolver 解析后返回具体 View。</li>
<li>DispatcherServlet 根据 View 进行渲染视图（即将模型数据填充至视图中）。</li>
<li>DispatcherServlet 响应用户。</li>
</ol>
<p>Spring MVC 是基于 MVC 模式的 Web 框架，用于构建 Web 应用程序。Spring MVC 的工作流程如下：</p>
<ol>
<li>用户发送请求：用户在浏览器中发送请求，请求会被发送到服务器端的 DispatcherServlet。</li>
<li>DispatcherServlet 接收请求：DispatcherServlet 是 Spring MVC 中的核心组件，用于接收请求并将请求分发到相应的处理器。</li>
<li>处理器映射器解析请求：处理器映射器（HandlerMapping）用于解析请求并确定请求对应的处理器，它会将请求映射到一个或多个处理器。</li>
<li>处理器适配器调用处理器：处理器适配器（HandlerAdapter）会调用处理器对请求进行处理，处理器可以是一个控制器（Controller）、一个服务类（Service）或其他组件。</li>
<li>处理器处理请求：处理器对请求进行处理，并生成相应的模型和视图对象。</li>
<li>视图解析器解析视图：视图解析器（ViewResolver）用于解析视图，根据处理器返回的视图名称和视图类型确定最终的视图对象。</li>
<li>视图渲染：视图将模型数据渲染到 HTML、JSON、XML 或其他类型的响应体中。</li>
<li>响应结果发送给客户端：响应结果被发送回客户端，客户端接收到响应结果并显示在浏览器中。</li>
</ol>
<p>通过这个工作流程，Spring MVC 可以实现请求的处理、视图的渲染和响应的发送，实现了分离关注点，使得应用程序的开发更加模块化，代码也更加清晰和易于维护。同时，Spring MVC 提供了丰富的扩展点和定制选项，可以方便地满足不同应用程序的需求。</p>
<h2 id="SSM工作流程"><a href="#SSM工作流程" class="headerlink" title="SSM工作流程"></a>SSM工作流程</h2><ol>
<li>用户发送请求：用户在浏览器中发送请求，请求会被发送到服务器端的 DispatcherServlet。</li>
<li>DispatcherServlet 接收请求：DispatcherServlet 是 Spring MVC 中的核心组件，用于接收请求并将请求分发到相应的处理器。</li>
<li>处理器映射器解析请求：处理器映射器（HandlerMapping）用于解析请求并确定请求对应的处理器，它会将请求映射到一个或多个处理器。</li>
<li>处理器适配器调用处理器：处理器适配器（HandlerAdapter）会调用处理器对请求进行处理，处理器可以是一个控制器（Controller）、一个服务类（Service）或其他组件。</li>
<li>处理器处理请求：处理器对请求进行处理，可以通过调用服务类等方式获取业务数据并进行处理，生成相应的模型和视图对象。</li>
<li>MyBatis 数据访问：MyBatis 是一个 ORM 框架，它可以将 Java 对象映射到数据库表中，使得开发人员可以通过对象的方式访问数据库。在 SSM 中，处理器可以通过调用 MyBatis DAO 层的方法来访问数据库，获取数据并进行处理。</li>
<li>视图解析器解析视图：视图解析器（ViewResolver）用于解析视图，根据处理器返回的视图名称和视图类型确定最终的视图对象。</li>
<li>视图渲染：视图将模型数据渲染到 HTML、JSON、XML 或其他类型的响应体中。</li>
<li>响应结果发送给客户端：响应结果被发送回客户端，客户端接收到响应结果并显示在浏览器中。</li>
</ol>
<p>通过这个工作流程，SSM 框架可以实现请求的处理、数据库访问、视图的渲染和响应的发送，实现了分离关注点，使得应用程序的开发更加模块化，代码也更加清晰和易于维护。同时，SSM 框架提供了丰富的扩展点和定制选项，可以方便地满足不同应用程序的需求。</p>
<h2 id="VUE工作流程"><a href="#VUE工作流程" class="headerlink" title="VUE工作流程"></a>VUE工作流程</h2><ol>
<li>创建 Vue 实例：首先，我们需要通过创建 Vue 实例来启动应用程序。Vue 实例是 Vue.js 的核心，它包含了应用程序的数据和方法，以及用于将数据和方法绑定到视图上的指令。</li>
<li>模板解析：Vue.js 使用基于 HTML 的模板语法，将模板解析成 Virtual DOM 树。</li>
<li>数据绑定：Vue.js 使用双向数据绑定机制，可以将模型数据和视图保持同步。当模型数据发生变化时，视图会自动更新，反之亦然。</li>
<li>编译模板：Vue.js 将模板编译成渲染函数，这个函数可以将 Virtual DOM 节点渲染成真正的 DOM 节点，并将模板中的指令转换为对应的 JavaScript 代码。</li>
<li>渲染视图：Vue.js 使用 Virtual DOM 技术，将模板中的数据和方法渲染到真实的 DOM 上。</li>
<li>监听事件：Vue.js 使用指令和事件处理器，可以实现用户交互的响应，例如点击按钮、输入文本等操作。</li>
<li>更新数据：当用户交互或其他事件发生时，Vue.js 会自动更新模型数据，触发重新渲染视图。这个过程中，Vue.js 会根据依赖关系自动进行优化，只更新必要的组件，提高性能。</li>
</ol>
<p>通过这个工作流程，Vue.js 可以实现高效的视图渲染、双向数据绑定和组件化开发，使得应用程序的开发更加快速和灵活。同时，Vue.js 提供了丰富的插件和组件库，可以方便地扩展和定制应用程序，满足不同应用程序的需求。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>这三者都是框架模式，它们设计的目标都是为了解决Model和View的耦合问题。</li>
<li>MVC模式出现较早主要应用在后端，如Spring MVC、ASP.NET MVC等，在前端领域的早期也有应用，如<br>Backbone.js。。它的优点是分层清晰，缺点是数据流混乱，灵活性带来的维护性问题。</li>
<li>MVP模式在是MVC的进化形式，Presenter作为中间层负责M通信，解决了两者耦合问题，但P层过于臃肿会<br>导致维护问题。</li>
<li>MWM模式在前端领域有广泛应用，它不仅解决MV耦合问题，还同时解决了维护两者映射关系的大量繁杂代<br>码和DOM操作代码，在提高开发效率、可读性同时还保持了优越的性能表现。</li>
</ul>
<h1 id="Re-ferences"><a href="#Re-ferences" class="headerlink" title="Re ferences"></a>Re ferences</h1><p><a target="_blank" rel="noopener" href="https://www.freesion.com/article/3175878285/">java进阶之三层架构+MVC - 灰信网</a></p>
<p><a target="_blank" rel="noopener" href="https://gngsn.tistory.com/84">Spring, 3-Tier-Architecture</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Ji4y1U7Y1/">mvc，mvp，mvvm 的区别</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/770897">Web开发的历史发展技术演变-阿里云开发者社区</a></p>
<p><a target="_blank" rel="noopener" href="https://toutiao.io/posts/fklq1v/preview">前端框架模式的变迁</a></p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2023/04/18/WebBackend/Java/%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E5%AE%9E%E4%BE%8B/">← Next 目录结构实例</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2023/04/18/%E5%8D%9A%E5%AE%A2/Hexo%20and%20OBSIDIAN%20%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE/">Hexo + OBSIDIAN 插件配置 Prev →</a></div></div></div></div><div id="bottom-btn"><a id="to-index" href="#toc-div" title="文章目录">≡</a><a id="to-top" onClick="scrolls.scrolltop();" title="to top" style="opacity: 0; display: none;">∧</a></div></article><aside><div id="aside-top"><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/">WRXinYue</a></h1><div id="description"><p></p></div></div><div id="aside-block"><div id="toc-div"><h1>文章目录</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Web%E5%89%8D%E7%AB%AF%E5%8E%86%E5%8F%B2"><span class="toc-number">1.</span> <span class="toc-text">Web前端历史</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Web1-0%E6%97%B6%E4%BB%A3"><span class="toc-number">1.1.</span> <span class="toc-text">Web1.0时代</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Web2-0%E6%97%B6%E4%BB%A3"><span class="toc-number">1.2.</span> <span class="toc-text">Web2.0时代</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E5%90%8E%E7%9A%84%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8F%98-MVC%E3%80%81MVP%E5%92%8CMVVM"><span class="toc-number">2.</span> <span class="toc-text">前后端分离后的架构演变-MVC、MVP和MVVM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MVC"><span class="toc-number">2.1.</span> <span class="toc-text">MVC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MVP"><span class="toc-number">2.2.</span> <span class="toc-text">MVP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MVVM"><span class="toc-number">2.3.</span> <span class="toc-text">MVVM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MVVM%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">2.4.</span> <span class="toc-text">MVVM执行流程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">后端架构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#B-x2F-S%E6%9E%B6%E6%9E%84%E3%80%81C-x2F-S%E6%9E%B6%E6%9E%84"><span class="toc-number">3.1.</span> <span class="toc-text">B&#x2F;S架构、C&#x2F;S架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84"><span class="toc-number">3.2.</span> <span class="toc-text">三层架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MVC%E6%9E%B6%E6%9E%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">3.3.</span> <span class="toc-text">MVC架构工作流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-MVC%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">3.4.</span> <span class="toc-text">Spring MVC工作流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SSM%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">3.5.</span> <span class="toc-text">SSM工作流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#VUE%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">3.6.</span> <span class="toc-text">VUE工作流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.7.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Re-ferences"><span class="toc-number">4.</span> <span class="toc-text">Re ferences</span></a></li></ol></div></div></div><footer><nobr>构建自 <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> 使用主题 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknight</a></nobr><wbr><nobr>主题作者 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script class="pjax-js">reset=_=>{code.findCode();mermaid.init(undefined, ('.mermaid'));}</script><script src="/js/arknights.js"></script><script>window.addEventListener("load",()=>{reset()})</script></body></html>